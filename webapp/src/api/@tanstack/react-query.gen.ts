// This file is auto-generated by @hey-api/openapi-ts

import { type Options, listGlobalContributors, slackCallback, deleteUser, getUserSettings, updateUserSettings, disconnectSlack, getSlackConnection, syncSlackConnection, listWorkspaces, createWorkspace, purgeWorkspace, getWorkspace, provideFeedbackForBadPractice, resolveBadPractice, detectBadPracticesForPullRequest, detectBadPracticesByUser, getActivityByUser, voteMessage, getUserDocuments, createDocument, deleteDocument, getDocument, updateDocument, deleteVersionsAfterTimestamp, getDocumentVersions, getDocumentVersion, getLeaderboard, getUserLeagueStats, resetAndRecalculateLeagues, listMembers, assignRole, getCurrentUserMembership, removeMember, getMember, getThread, getThreads, getGroupedThreads, updateNotifications, getUserProfile, updatePublicVisibility, getRepositoriesToMonitor, removeRepositoryToMonitor, addRepositoryToMonitor, updateSchedule, updateSlackCredentials, installSlackBot, renameSlug, updateStatus, getAllTeams, updateTeamVisibility, updateRepositoryVisibility, removeLabelFromTeam, addLabelToTeam, updateToken, getUsersWithTeams } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { ListGlobalContributorsData, SlackCallbackData, DeleteUserData, GetUserSettingsData, UpdateUserSettingsData, UpdateUserSettingsResponse, DisconnectSlackData, DisconnectSlackResponse, GetSlackConnectionData, SyncSlackConnectionData, SyncSlackConnectionResponse, ListWorkspacesData, CreateWorkspaceData, CreateWorkspaceResponse, PurgeWorkspaceData, PurgeWorkspaceResponse, GetWorkspaceData, ProvideFeedbackForBadPracticeData, ResolveBadPracticeData, DetectBadPracticesForPullRequestData, DetectBadPracticesByUserData, GetActivityByUserData, VoteMessageData, VoteMessageError, VoteMessageResponse, GetUserDocumentsData, GetUserDocumentsResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, DeleteDocumentData, DeleteDocumentResponse, GetDocumentData, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, DeleteVersionsAfterTimestampData, DeleteVersionsAfterTimestampError, DeleteVersionsAfterTimestampResponse, GetDocumentVersionsData, GetDocumentVersionsError, GetDocumentVersionsResponse, GetDocumentVersionData, GetLeaderboardData, GetLeaderboardResponse, GetUserLeagueStatsData, GetUserLeagueStatsResponse, ResetAndRecalculateLeaguesData, ListMembersData, ListMembersResponse, AssignRoleData, AssignRoleResponse, GetCurrentUserMembershipData, RemoveMemberData, GetMemberData, GetThreadData, GetThreadsData, GetGroupedThreadsData, UpdateNotificationsData, UpdateNotificationsResponse, GetUserProfileData, GetUserProfileResponse, UpdatePublicVisibilityData, UpdatePublicVisibilityResponse, GetRepositoriesToMonitorData, RemoveRepositoryToMonitorData, AddRepositoryToMonitorData, UpdateScheduleData, UpdateScheduleResponse, UpdateSlackCredentialsData, UpdateSlackCredentialsResponse, InstallSlackBotData, RenameSlugData, RenameSlugResponse, UpdateStatusData, UpdateStatusResponse, GetAllTeamsData, UpdateTeamVisibilityData, UpdateRepositoryVisibilityData, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, AddLabelToTeamData, AddLabelToTeamResponse, UpdateTokenData, UpdateTokenResponse, GetUsersWithTeamsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const listGlobalContributorsQueryKey = (options?: Options<ListGlobalContributorsData>) => createQueryKey('listGlobalContributors', options);

/**
 * List global contributors
 * Returns all contributors across all workspaces
 */
export const listGlobalContributorsOptions = (options?: Options<ListGlobalContributorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGlobalContributors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGlobalContributorsQueryKey(options)
    });
};

export const slackCallbackQueryKey = (options: Options<SlackCallbackData>) => createQueryKey('slackCallback', options);

/**
 * Slack OAuth Callback
 * Handles the callback from Slack after bot installation.
 */
export const slackCallbackOptions = (options: Options<SlackCallbackData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await slackCallback({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: slackCallbackQueryKey(options)
    });
};

/**
 * Delete user account
 * Permanently delete the current user's account and all associated data (GDPR)
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

/**
 * Get user settings
 * Get the current user's notification and research participation preferences
 */
export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsQueryKey = (options: Options<UpdateUserSettingsData>) => createQueryKey('updateUserSettings', options);

/**
 * Update user settings
 * Update the current user's notification and research participation preferences
 */
export const updateUserSettingsOptions = (options: Options<UpdateUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateUserSettingsQueryKey(options)
    });
};

/**
 * Update user settings
 * Update the current user's notification and research participation preferences
 */
export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disconnect Slack account
 * Clears the stored Slack User ID. Note: To fully disconnect, the user should also unlink Slack in Keycloak Account Management.
 */
export const disconnectSlackMutation = (options?: Partial<Options<DisconnectSlackData>>): UseMutationOptions<DisconnectSlackResponse, DefaultError, Options<DisconnectSlackData>> => {
    const mutationOptions: UseMutationOptions<DisconnectSlackResponse, DefaultError, Options<DisconnectSlackData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disconnectSlack({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSlackConnectionQueryKey = (options?: Options<GetSlackConnectionData>) => createQueryKey('getSlackConnection', options);

/**
 * Get Slack connection status
 * Check if the current user has linked their Slack account. If Slack is enabled, also returns the URL where users can link their Slack account in Keycloak.
 */
export const getSlackConnectionOptions = (options?: Options<GetSlackConnectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSlackConnection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSlackConnectionQueryKey(options)
    });
};

export const syncSlackConnectionQueryKey = (options?: Options<SyncSlackConnectionData>) => createQueryKey('syncSlackConnection', options);

/**
 * Sync Slack connection from Keycloak
 * Re-syncs the Slack User ID from Keycloak federated identities. Call this after linking or unlinking Slack in Keycloak Account Management.
 */
export const syncSlackConnectionOptions = (options?: Options<SyncSlackConnectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await syncSlackConnection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: syncSlackConnectionQueryKey(options)
    });
};

/**
 * Sync Slack connection from Keycloak
 * Re-syncs the Slack User ID from Keycloak federated identities. Call this after linking or unlinking Slack in Keycloak Account Management.
 */
export const syncSlackConnectionMutation = (options?: Partial<Options<SyncSlackConnectionData>>): UseMutationOptions<SyncSlackConnectionResponse, DefaultError, Options<SyncSlackConnectionData>> => {
    const mutationOptions: UseMutationOptions<SyncSlackConnectionResponse, DefaultError, Options<SyncSlackConnectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await syncSlackConnection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWorkspacesQueryKey = (options?: Options<ListWorkspacesData>) => createQueryKey('listWorkspaces', options);

/**
 * List all workspaces
 */
export const listWorkspacesOptions = (options?: Options<ListWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWorkspacesQueryKey(options)
    });
};

export const createWorkspaceQueryKey = (options: Options<CreateWorkspaceData>) => createQueryKey('createWorkspace', options);

/**
 * Create a new workspace
 */
export const createWorkspaceOptions = (options: Options<CreateWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWorkspaceQueryKey(options)
    });
};

/**
 * Create a new workspace
 */
export const createWorkspaceMutation = (options?: Partial<Options<CreateWorkspaceData>>): UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Purge (soft delete) a workspace
 */
export const purgeWorkspaceMutation = (options?: Partial<Options<PurgeWorkspaceData>>): UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await purgeWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspaceQueryKey = (options: Options<GetWorkspaceData>) => createQueryKey('getWorkspace', options);

/**
 * Fetch a workspace by slug
 */
export const getWorkspaceOptions = (options: Options<GetWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspaceQueryKey(options)
    });
};

export const provideFeedbackForBadPracticeQueryKey = (options: Options<ProvideFeedbackForBadPracticeData>) => createQueryKey('provideFeedbackForBadPractice', options);

export const provideFeedbackForBadPracticeOptions = (options: Options<ProvideFeedbackForBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: provideFeedbackForBadPracticeQueryKey(options)
    });
};

export const provideFeedbackForBadPracticeMutation = (options?: Partial<Options<ProvideFeedbackForBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveBadPracticeQueryKey = (options: Options<ResolveBadPracticeData>) => createQueryKey('resolveBadPractice', options);

export const resolveBadPracticeOptions = (options: Options<ResolveBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveBadPracticeQueryKey(options)
    });
};

export const resolveBadPracticeMutation = (options?: Partial<Options<ResolveBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesForPullRequestQueryKey = (options: Options<DetectBadPracticesForPullRequestData>) => createQueryKey('detectBadPracticesForPullRequest', options);

export const detectBadPracticesForPullRequestOptions = (options: Options<DetectBadPracticesForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesForPullRequestQueryKey(options)
    });
};

export const detectBadPracticesForPullRequestMutation = (options?: Partial<Options<DetectBadPracticesForPullRequestData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesByUserQueryKey = (options: Options<DetectBadPracticesByUserData>) => createQueryKey('detectBadPracticesByUser', options);

export const detectBadPracticesByUserOptions = (options: Options<DetectBadPracticesByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesByUserQueryKey(options)
    });
};

export const detectBadPracticesByUserMutation = (options?: Partial<Options<DetectBadPracticesByUserData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActivityByUserQueryKey = (options: Options<GetActivityByUserData>) => createQueryKey('getActivityByUser', options);

export const getActivityByUserOptions = (options: Options<GetActivityByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActivityByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActivityByUserQueryKey(options)
    });
};

/**
 * Vote on a message
 * Cast an upvote or downvote on a chat message
 */
export const voteMessageMutation = (options?: Partial<Options<VoteMessageData>>): UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> => {
    const mutationOptions: UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await voteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserDocumentsQueryKey = (options: Options<GetUserDocumentsData>) => createQueryKey('getUserDocuments', options);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsOptions = (options: Options<GetUserDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getUserDocumentsInfiniteQueryKey = (options: Options<GetUserDocumentsData>): QueryKey<Options<GetUserDocumentsData>> => createQueryKey('getUserDocuments', options, true);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsInfiniteOptions = (options: Options<GetUserDocumentsData>) => {
    return infiniteQueryOptions<GetUserDocumentsResponse, DefaultError, InfiniteData<GetUserDocumentsResponse>, QueryKey<Options<GetUserDocumentsData>>, number | Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getUserDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsInfiniteQueryKey(options)
    });
};

export const createDocumentQueryKey = (options: Options<CreateDocumentData>) => createQueryKey('createDocument', options);

/**
 * Create a new document
 */
export const createDocumentOptions = (options: Options<CreateDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDocumentQueryKey(options)
    });
};

/**
 * Create a new document
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all its versions
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get latest version of a document
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentQueryKey(options)
    });
};

/**
 * Update a document (creates new version)
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete document versions after specified timestamp
 */
export const deleteVersionsAfterTimestampMutation = (options?: Partial<Options<DeleteVersionsAfterTimestampData>>): UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> => {
    const mutationOptions: UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteVersionsAfterTimestamp({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentVersionsQueryKey = (options: Options<GetDocumentVersionsData>) => createQueryKey('getDocumentVersions', options);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsOptions = (options: Options<GetDocumentVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsQueryKey(options)
    });
};

export const getDocumentVersionsInfiniteQueryKey = (options: Options<GetDocumentVersionsData>): QueryKey<Options<GetDocumentVersionsData>> => createQueryKey('getDocumentVersions', options, true);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsInfiniteOptions = (options: Options<GetDocumentVersionsData>) => {
    return infiniteQueryOptions<GetDocumentVersionsResponse, GetDocumentVersionsError, InfiniteData<GetDocumentVersionsResponse>, QueryKey<Options<GetDocumentVersionsData>>, number | Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocumentVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsInfiniteQueryKey(options)
    });
};

export const getDocumentVersionQueryKey = (options: Options<GetDocumentVersionData>) => createQueryKey('getDocumentVersion', options);

/**
 * Get specific version of a document by version number
 */
export const getDocumentVersionOptions = (options: Options<GetDocumentVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionQueryKey(options)
    });
};

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

/**
 * Generate leaderboard
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLeaderboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardQueryKey(options)
    });
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

/**
 * Generate leaderboard
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => {
    return infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLeaderboard({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardInfiniteQueryKey(options)
    });
};

export const getUserLeagueStatsQueryKey = (options: Options<GetUserLeagueStatsData>) => createQueryKey('getUserLeagueStats', options);

/**
 * Get user league stats
 * Calculates league changes for a specific user
 */
export const getUserLeagueStatsOptions = (options: Options<GetUserLeagueStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLeagueStatsQueryKey(options)
    });
};

/**
 * Get user league stats
 * Calculates league changes for a specific user
 */
export const getUserLeagueStatsMutation = (options?: Partial<Options<GetUserLeagueStatsData>>): UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset and recalculate workspace leagues
 */
export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List all members of the workspace with pagination.
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersOptions = (options: Options<ListMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersQueryKey(options)
    });
};

export const listMembersInfiniteQueryKey = (options: Options<ListMembersData>): QueryKey<Options<ListMembersData>> => createQueryKey('listMembers', options, true);

/**
 * List all members of the workspace with pagination.
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersInfiniteOptions = (options: Options<ListMembersData>) => {
    return infiniteQueryOptions<ListMembersResponse, DefaultError, InfiniteData<ListMembersResponse>, QueryKey<Options<ListMembersData>>, number | Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listMembers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersInfiniteQueryKey(options)
    });
};

export const assignRoleQueryKey = (options: Options<AssignRoleData>) => createQueryKey('assignRole', options);

/**
 * Assign or update a role for a workspace member.
 * Assign or update a role for a workspace member.
 * OWNER can assign any role. ADMIN can assign ADMIN or MEMBER roles.
 */
export const assignRoleOptions = (options: Options<AssignRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignRoleQueryKey(options)
    });
};

/**
 * Assign or update a role for a workspace member.
 * Assign or update a role for a workspace member.
 * OWNER can assign any role. ADMIN can assign ADMIN or MEMBER roles.
 */
export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserMembershipQueryKey = (options: Options<GetCurrentUserMembershipData>) => createQueryKey('getCurrentUserMembership', options);

/**
 * Get the current user's membership in this workspace.
 * Get the current user's membership in this workspace.
 */
export const getCurrentUserMembershipOptions = (options: Options<GetCurrentUserMembershipData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUserMembership({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserMembershipQueryKey(options)
    });
};

/**
 * Revoke a user's membership (remove them from workspace).
 * Revoke a user's membership (remove them from workspace).
 * OWNER can remove anyone except themselves if they are the last OWNER.
 * ADMIN can remove MEMBER and ADMIN roles.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMemberQueryKey = (options: Options<GetMemberData>) => createQueryKey('getMember', options);

/**
 * Get a specific member's details.
 * Get a specific member's details.
 * Accessible to all workspace members.
 */
export const getMemberOptions = (options: Options<GetMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMemberQueryKey(options)
    });
};

export const getThreadQueryKey = (options: Options<GetThreadData>) => createQueryKey('getThread', options);

/**
 * Get chat thread detail
 * Retrieve a specific chat thread with all messages
 */
export const getThreadOptions = (options: Options<GetThreadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThread({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadQueryKey(options)
    });
};

export const getThreadsQueryKey = (options: Options<GetThreadsData>) => createQueryKey('getThreads', options);

/**
 * Get user's chat threads
 * Retrieve all chat threads for the authenticated user
 */
export const getThreadsOptions = (options: Options<GetThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadsQueryKey(options)
    });
};

export const getGroupedThreadsQueryKey = (options: Options<GetGroupedThreadsData>) => createQueryKey('getGroupedThreads', options);

/**
 * Get user's grouped chat threads
 * Retrieve all chat threads for the authenticated user grouped by time periods
 */
export const getGroupedThreadsOptions = (options: Options<GetGroupedThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupedThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupedThreadsQueryKey(options)
    });
};

/**
 * Update leaderboard notification preferences
 */
export const updateNotificationsMutation = (options?: Partial<Options<UpdateNotificationsData>>): UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> => {
    const mutationOptions: UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

/**
 * Get user profile
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileOptions = (options: Options<GetUserProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileQueryKey(options)
    });
};

export const getUserProfileInfiniteQueryKey = (options: Options<GetUserProfileData>): QueryKey<Options<GetUserProfileData>> => createQueryKey('getUserProfile', options, true);

/**
 * Get user profile
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileInfiniteOptions = (options: Options<GetUserProfileData>) => {
    return infiniteQueryOptions<GetUserProfileResponse, DefaultError, InfiniteData<GetUserProfileResponse>, QueryKey<Options<GetUserProfileData>>, Date | Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getUserProfile({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileInfiniteQueryKey(options)
    });
};

/**
 * Toggle public visibility for a workspace
 */
export const updatePublicVisibilityMutation = (options?: Partial<Options<UpdatePublicVisibilityData>>): UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePublicVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

/**
 * List repositories monitored by a workspace
 */
export const getRepositoriesToMonitorOptions = (options: Options<GetRepositoriesToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoriesToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesToMonitorQueryKey(options)
    });
};

/**
 * Remove a repository from a workspace monitor list
 */
export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToMonitorQueryKey = (options: Options<AddRepositoryToMonitorData>) => createQueryKey('addRepositoryToMonitor', options);

/**
 * Add a repository to a workspace monitor list
 */
export const addRepositoryToMonitorOptions = (options: Options<AddRepositoryToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToMonitorQueryKey(options)
    });
};

/**
 * Add a repository to a workspace monitor list
 */
export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update leaderboard schedule configuration
 */
export const updateScheduleMutation = (options?: Partial<Options<UpdateScheduleData>>): UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> => {
    const mutationOptions: UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSchedule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Slack credentials for a workspace
 */
export const updateSlackCredentialsMutation = (options?: Partial<Options<UpdateSlackCredentialsData>>): UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> => {
    const mutationOptions: UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSlackCredentials({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const installSlackBotQueryKey = (options: Options<InstallSlackBotData>) => createQueryKey('installSlackBot', options);

/**
 * Initiate Slack Bot Installation
 * Redirects to Slack authorization page to install the Hephaestus bot to this workspace.
 */
export const installSlackBotOptions = (options: Options<InstallSlackBotData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installSlackBot({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installSlackBotQueryKey(options)
    });
};

/**
 * Rename workspace slug and create redirect
 */
export const renameSlugMutation = (options?: Partial<Options<RenameSlugData>>): UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> => {
    const mutationOptions: UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await renameSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace lifecycle status
 */
export const updateStatusMutation = (options?: Partial<Options<UpdateStatusData>>): UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTeamsQueryKey = (options: Options<GetAllTeamsData>) => createQueryKey('getAllTeams', options);

/**
 * List teams
 * Returns all teams in the workspace organization
 */
export const getAllTeamsOptions = (options: Options<GetAllTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTeamsQueryKey(options)
    });
};

export const updateTeamVisibilityQueryKey = (options: Options<UpdateTeamVisibilityData>) => createQueryKey('updateTeamVisibility', options);

/**
 * Update team visibility
 * Show or hide a team in leaderboard calculations
 */
export const updateTeamVisibilityOptions = (options: Options<UpdateTeamVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateTeamVisibilityQueryKey(options)
    });
};

/**
 * Update team visibility
 * Show or hide a team in leaderboard calculations
 */
export const updateTeamVisibilityMutation = (options?: Partial<Options<UpdateTeamVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateRepositoryVisibilityQueryKey = (options: Options<UpdateRepositoryVisibilityData>) => createQueryKey('updateRepositoryVisibility', options);

export const updateRepositoryVisibilityOptions = (options: Options<UpdateRepositoryVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateRepositoryVisibilityQueryKey(options)
    });
};

export const updateRepositoryVisibilityMutation = (options?: Partial<Options<UpdateRepositoryVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a repository label from a team
 */
export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelToTeamQueryKey = (options: Options<AddLabelToTeamData>) => createQueryKey('addLabelToTeam', options);

/**
 * Add a repository label to a team
 */
export const addLabelToTeamOptions = (options: Options<AddLabelToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelToTeamQueryKey(options)
    });
};

/**
 * Add a repository label to a team
 */
export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace Personal Access Token
 */
export const updateTokenMutation = (options?: Partial<Options<UpdateTokenData>>): UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

/**
 * List workspace users and the teams they belong to
 */
export const getUsersWithTeamsOptions = (options: Options<GetUsersWithTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersWithTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersWithTeamsQueryKey(options)
    });
};