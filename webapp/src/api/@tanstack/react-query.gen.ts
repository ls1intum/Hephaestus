// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { addLabelFilter, addLabelToTeam, addRepositoryToMonitor, assignRole, computeUserLeagueStats, createDocument, createWorkspace, deleteDocument, deleteDocumentVersionsAfter, deleteUser, detectForPullRequest, detectForUser, getAllTeams, getBadPractice, getBadPracticesForPullRequest, getBadPracticesForUser, getCurrentUserMembership, getDocument, getGroupedThreads, getLabelFilters, getLeaderboard, getMember, getRepositoriesToMonitor, getRepositorySettings, getTeamSettings, getThread, getUserAchievements, getUserProfile, getUserSettings, getUsersWithTeams, getVersion, getWorkspace, listDocuments, listGlobalContributors, listMembers, listVersions, listWorkspaces, type Options, provideFeedback, purgeWorkspace, removeLabelFilter, removeLabelFromTeam, removeMember, removeRepositoryToMonitor, renameSlug, resetAndRecalculateLeagues, resolve, updateDocument, updateNotifications, updatePublicVisibility, updateRepositorySettings, updateRepositoryVisibility, updateSchedule, updateSlackCredentials, updateStatus, updateTeamSettings, updateTeamVisibility, updateToken, updateUserSettings, voteMessage } from '../sdk.gen';
import type { AddLabelFilterData, AddLabelToTeamData, AddLabelToTeamResponse, AddRepositoryToMonitorData, AssignRoleData, AssignRoleResponse, ComputeUserLeagueStatsData, ComputeUserLeagueStatsResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, CreateWorkspaceData, CreateWorkspaceResponse, DeleteDocumentData, DeleteDocumentError, DeleteDocumentResponse, DeleteDocumentVersionsAfterData, DeleteDocumentVersionsAfterError, DeleteDocumentVersionsAfterResponse, DeleteUserData, DetectForPullRequestData, DetectForPullRequestError, DetectForPullRequestResponse, DetectForUserData, DetectForUserError, DetectForUserResponse, GetAllTeamsData, GetAllTeamsResponse, GetBadPracticeData, GetBadPracticeResponse, GetBadPracticesForPullRequestData, GetBadPracticesForPullRequestResponse, GetBadPracticesForUserData, GetBadPracticesForUserResponse, GetCurrentUserMembershipData, GetCurrentUserMembershipResponse, GetDocumentData, GetDocumentError, GetDocumentResponse, GetGroupedThreadsData, GetGroupedThreadsError, GetGroupedThreadsResponse, GetLabelFiltersData, GetLabelFiltersResponse, GetLeaderboardData, GetLeaderboardResponse, GetMemberData, GetMemberResponse, GetRepositoriesToMonitorData, GetRepositoriesToMonitorResponse, GetRepositorySettingsData, GetRepositorySettingsResponse, GetTeamSettingsData, GetTeamSettingsResponse, GetThreadData, GetThreadError, GetThreadResponse, GetUserAchievementsData, GetUserAchievementsResponse, GetUserProfileData, GetUserProfileResponse, GetUserSettingsData, GetUserSettingsResponse, GetUsersWithTeamsData, GetUsersWithTeamsResponse, GetVersionData, GetVersionError, GetVersionResponse, GetWorkspaceData, GetWorkspaceResponse, ListDocumentsData, ListDocumentsError, ListDocumentsResponse, ListGlobalContributorsData, ListGlobalContributorsResponse, ListMembersData, ListMembersResponse, ListVersionsData, ListVersionsError, ListVersionsResponse, ListWorkspacesData, ListWorkspacesResponse, ProvideFeedbackData, PurgeWorkspaceData, PurgeWorkspaceResponse, RemoveLabelFilterData, RemoveLabelFilterResponse, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, RemoveMemberData, RemoveRepositoryToMonitorData, RenameSlugData, RenameSlugResponse, ResetAndRecalculateLeaguesData, ResolveData, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, UpdateNotificationsData, UpdateNotificationsResponse, UpdatePublicVisibilityData, UpdatePublicVisibilityResponse, UpdateRepositorySettingsData, UpdateRepositorySettingsError, UpdateRepositorySettingsResponse, UpdateRepositoryVisibilityData, UpdateScheduleData, UpdateScheduleResponse, UpdateSlackCredentialsData, UpdateSlackCredentialsResponse, UpdateStatusData, UpdateStatusResponse, UpdateTeamSettingsData, UpdateTeamSettingsError, UpdateTeamSettingsResponse, UpdateTeamVisibilityData, UpdateTokenData, UpdateTokenResponse, UpdateUserSettingsData, UpdateUserSettingsResponse, VoteMessageData, VoteMessageError, VoteMessageResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const listGlobalContributorsQueryKey = (options?: Options<ListGlobalContributorsData>) => createQueryKey('listGlobalContributors', options);

/**
 * List global contributors
 *
 * Returns contributors to the Hephaestus project (for the About page)
 */
export const listGlobalContributorsOptions = (options?: Options<ListGlobalContributorsData>) => queryOptions<ListGlobalContributorsResponse, DefaultError, ListGlobalContributorsResponse, ReturnType<typeof listGlobalContributorsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listGlobalContributors({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGlobalContributorsQueryKey(options)
});

/**
 * Delete user account
 *
 * Permanently delete the current user's account and all associated data (GDPR)
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

/**
 * Get user settings
 *
 * Get the current user's notification and research participation preferences
 */
export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => queryOptions<GetUserSettingsResponse, DefaultError, GetUserSettingsResponse, ReturnType<typeof getUserSettingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserSettings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserSettingsQueryKey(options)
});

/**
 * Update user settings
 *
 * Update the current user's notification and research participation preferences
 */
export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWorkspacesQueryKey = (options?: Options<ListWorkspacesData>) => createQueryKey('listWorkspaces', options);

/**
 * List all workspaces
 */
export const listWorkspacesOptions = (options?: Options<ListWorkspacesData>) => queryOptions<ListWorkspacesResponse, DefaultError, ListWorkspacesResponse, ReturnType<typeof listWorkspacesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listWorkspaces({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkspacesQueryKey(options)
});

/**
 * Create a new workspace
 */
export const createWorkspaceMutation = (options?: Partial<Options<CreateWorkspaceData>>): UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Purge (soft delete) a workspace
 */
export const purgeWorkspaceMutation = (options?: Partial<Options<PurgeWorkspaceData>>): UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await purgeWorkspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspaceQueryKey = (options: Options<GetWorkspaceData>) => createQueryKey('getWorkspace', options);

/**
 * Fetch a workspace by slug
 */
export const getWorkspaceOptions = (options: Options<GetWorkspaceData>) => queryOptions<GetWorkspaceResponse, DefaultError, GetWorkspaceResponse, ReturnType<typeof getWorkspaceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWorkspace({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWorkspaceQueryKey(options)
});

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

/**
 * Generate leaderboard
 *
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => queryOptions<GetLeaderboardResponse, DefaultError, GetLeaderboardResponse, ReturnType<typeof getLeaderboardQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLeaderboard({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLeaderboardQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

/**
 * Generate leaderboard
 *
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                after: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getLeaderboard({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLeaderboardInfiniteQueryKey(options)
});

/**
 * Calculate user league stats
 *
 * Computes projected league point changes for a specific user based on their leaderboard entry
 */
export const computeUserLeagueStatsMutation = (options?: Partial<Options<ComputeUserLeagueStatsData>>): UseMutationOptions<ComputeUserLeagueStatsResponse, DefaultError, Options<ComputeUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<ComputeUserLeagueStatsResponse, DefaultError, Options<ComputeUserLeagueStatsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await computeUserLeagueStats({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset and recalculate workspace leagues
 */
export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List all members of the workspace with pagination.
 *
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersOptions = (options: Options<ListMembersData>) => queryOptions<ListMembersResponse, DefaultError, ListMembersResponse, ReturnType<typeof listMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMembersQueryKey(options)
});

export const listMembersInfiniteQueryKey = (options: Options<ListMembersData>): QueryKey<Options<ListMembersData>> => createQueryKey('listMembers', options, true);

/**
 * List all members of the workspace with pagination.
 *
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersInfiniteOptions = (options: Options<ListMembersData>) => infiniteQueryOptions<ListMembersResponse, DefaultError, InfiniteData<ListMembersResponse>, QueryKey<Options<ListMembersData>>, number | Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listMembers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listMembersInfiniteQueryKey(options)
});

/**
 * Assign or update a role for a workspace member.
 *
 * Assign or update a role for a workspace member.
 * OWNER can assign any role. ADMIN can assign ADMIN or MEMBER roles.
 */
export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await assignRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserMembershipQueryKey = (options: Options<GetCurrentUserMembershipData>) => createQueryKey('getCurrentUserMembership', options);

/**
 * Get the current user's membership in this workspace.
 *
 * Get the current user's membership in this workspace.
 */
export const getCurrentUserMembershipOptions = (options: Options<GetCurrentUserMembershipData>) => queryOptions<GetCurrentUserMembershipResponse, DefaultError, GetCurrentUserMembershipResponse, ReturnType<typeof getCurrentUserMembershipQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCurrentUserMembership({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCurrentUserMembershipQueryKey(options)
});

/**
 * Revoke a user's membership (remove them from workspace).
 *
 * Revoke a user's membership (remove them from workspace).
 * OWNER can remove anyone except themselves if they are the last OWNER.
 * ADMIN can remove MEMBER and ADMIN roles.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMemberQueryKey = (options: Options<GetMemberData>) => createQueryKey('getMember', options);

/**
 * Get a specific member's details.
 *
 * Get a specific member's details.
 * Accessible to all workspace members.
 */
export const getMemberOptions = (options: Options<GetMemberData>) => queryOptions<GetMemberResponse, DefaultError, GetMemberResponse, ReturnType<typeof getMemberQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getMember({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getMemberQueryKey(options)
});

export const listDocumentsQueryKey = (options: Options<ListDocumentsData>) => createQueryKey('listDocuments', options);

/**
 * List documents owned by the authenticated user
 */
export const listDocumentsOptions = (options: Options<ListDocumentsData>) => queryOptions<ListDocumentsResponse, ListDocumentsError, ListDocumentsResponse, ReturnType<typeof listDocumentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDocuments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDocumentsQueryKey(options)
});

export const listDocumentsInfiniteQueryKey = (options: Options<ListDocumentsData>): QueryKey<Options<ListDocumentsData>> => createQueryKey('listDocuments', options, true);

/**
 * List documents owned by the authenticated user
 */
export const listDocumentsInfiniteOptions = (options: Options<ListDocumentsData>) => infiniteQueryOptions<ListDocumentsResponse, ListDocumentsError, InfiniteData<ListDocumentsResponse>, QueryKey<Options<ListDocumentsData>>, number | null | Pick<QueryKey<Options<ListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDocuments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDocumentsInfiniteQueryKey(options)
});

/**
 * Create a new document
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all versions
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get latest version of a document
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => queryOptions<GetDocumentResponse, GetDocumentError, GetDocumentResponse, ReturnType<typeof getDocumentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDocument({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDocumentQueryKey(options)
});

/**
 * Update a document (creates new version)
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete versions after timestamp
 */
export const deleteDocumentVersionsAfterMutation = (options?: Partial<Options<DeleteDocumentVersionsAfterData>>): UseMutationOptions<DeleteDocumentVersionsAfterResponse, DeleteDocumentVersionsAfterError, Options<DeleteDocumentVersionsAfterData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentVersionsAfterResponse, DeleteDocumentVersionsAfterError, Options<DeleteDocumentVersionsAfterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDocumentVersionsAfter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listVersionsQueryKey = (options: Options<ListVersionsData>) => createQueryKey('listVersions', options);

/**
 * List versions of a document
 */
export const listVersionsOptions = (options: Options<ListVersionsData>) => queryOptions<ListVersionsResponse, ListVersionsError, ListVersionsResponse, ReturnType<typeof listVersionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listVersions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listVersionsQueryKey(options)
});

export const listVersionsInfiniteQueryKey = (options: Options<ListVersionsData>): QueryKey<Options<ListVersionsData>> => createQueryKey('listVersions', options, true);

/**
 * List versions of a document
 */
export const listVersionsInfiniteOptions = (options: Options<ListVersionsData>) => infiniteQueryOptions<ListVersionsResponse, ListVersionsError, InfiniteData<ListVersionsResponse>, QueryKey<Options<ListVersionsData>>, number | null | Pick<QueryKey<Options<ListVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listVersions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listVersionsInfiniteQueryKey(options)
});

export const getVersionQueryKey = (options: Options<GetVersionData>) => createQueryKey('getVersion', options);

/**
 * Get specific version
 */
export const getVersionOptions = (options: Options<GetVersionData>) => queryOptions<GetVersionResponse, GetVersionError, GetVersionResponse, ReturnType<typeof getVersionQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getVersion({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getVersionQueryKey(options)
});

/**
 * Vote on a chat message (upvote/downvote) - idempotent upsert
 */
export const voteMessageMutation = (options?: Partial<Options<VoteMessageData>>): UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> => {
    const mutationOptions: UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await voteMessage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupedThreadsQueryKey = (options: Options<GetGroupedThreadsData>) => createQueryKey('getGroupedThreads', options);

/**
 * List chat threads grouped by time buckets
 */
export const getGroupedThreadsOptions = (options: Options<GetGroupedThreadsData>) => queryOptions<GetGroupedThreadsResponse, GetGroupedThreadsError, GetGroupedThreadsResponse, ReturnType<typeof getGroupedThreadsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getGroupedThreads({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getGroupedThreadsQueryKey(options)
});

export const getThreadQueryKey = (options: Options<GetThreadData>) => createQueryKey('getThread', options);

/**
 * Get mentor chat thread detail
 */
export const getThreadOptions = (options: Options<GetThreadData>) => queryOptions<GetThreadResponse, GetThreadError, GetThreadResponse, ReturnType<typeof getThreadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getThread({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getThreadQueryKey(options)
});

/**
 * Update leaderboard notification preferences
 */
export const updateNotificationsMutation = (options?: Partial<Options<UpdateNotificationsData>>): UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> => {
    const mutationOptions: UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateNotifications({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticeQueryKey = (options: Options<GetBadPracticeData>) => createQueryKey('getBadPractice', options);

/**
 * Get a specific bad practice
 *
 * Retrieves details of a specific bad practice by ID
 */
export const getBadPracticeOptions = (options: Options<GetBadPracticeData>) => queryOptions<GetBadPracticeResponse, DefaultError, GetBadPracticeResponse, ReturnType<typeof getBadPracticeQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBadPractice({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBadPracticeQueryKey(options)
});

/**
 * Provide feedback for a bad practice
 *
 * Submits user feedback for a detected bad practice
 */
export const provideFeedbackMutation = (options?: Partial<Options<ProvideFeedbackData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await provideFeedback({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve a bad practice
 *
 * Updates the state of a bad practice to FIXED, WONT_FIX, or WRONG
 */
export const resolveMutation = (options?: Partial<Options<ResolveData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resolve({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticesForPullRequestQueryKey = (options: Options<GetBadPracticesForPullRequestData>) => createQueryKey('getBadPracticesForPullRequest', options);

/**
 * Get bad practices for a pull request
 *
 * Retrieves all detected bad practices for a specific pull request
 */
export const getBadPracticesForPullRequestOptions = (options: Options<GetBadPracticesForPullRequestData>) => queryOptions<GetBadPracticesForPullRequestResponse, DefaultError, GetBadPracticesForPullRequestResponse, ReturnType<typeof getBadPracticesForPullRequestQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBadPracticesForPullRequest({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBadPracticesForPullRequestQueryKey(options)
});

/**
 * Detect bad practices for a pull request
 *
 * Triggers bad practice detection for a specific pull request
 */
export const detectForPullRequestMutation = (options?: Partial<Options<DetectForPullRequestData>>): UseMutationOptions<DetectForPullRequestResponse, DetectForPullRequestError, Options<DetectForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<DetectForPullRequestResponse, DetectForPullRequestError, Options<DetectForPullRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await detectForPullRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticesForUserQueryKey = (options: Options<GetBadPracticesForUserData>) => createQueryKey('getBadPracticesForUser', options);

/**
 * Get bad practices for a user
 *
 * Retrieves all detected bad practices for pull requests assigned to the user
 */
export const getBadPracticesForUserOptions = (options: Options<GetBadPracticesForUserData>) => queryOptions<GetBadPracticesForUserResponse, DefaultError, GetBadPracticesForUserResponse, ReturnType<typeof getBadPracticesForUserQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBadPracticesForUser({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBadPracticesForUserQueryKey(options)
});

/**
 * Detect bad practices for a user
 *
 * Triggers bad practice detection for all pull requests of the specified user
 */
export const detectForUserMutation = (options?: Partial<Options<DetectForUserData>>): UseMutationOptions<DetectForUserResponse, DetectForUserError, Options<DetectForUserData>> => {
    const mutationOptions: UseMutationOptions<DetectForUserResponse, DetectForUserError, Options<DetectForUserData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await detectForUser({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

/**
 * Get user profile
 *
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileOptions = (options: Options<GetUserProfileData>) => queryOptions<GetUserProfileResponse, DefaultError, GetUserProfileResponse, ReturnType<typeof getUserProfileQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserProfile({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserProfileQueryKey(options)
});

export const getUserProfileInfiniteQueryKey = (options: Options<GetUserProfileData>): QueryKey<Options<GetUserProfileData>> => createQueryKey('getUserProfile', options, true);

/**
 * Get user profile
 *
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileInfiniteOptions = (options: Options<GetUserProfileData>) => infiniteQueryOptions<GetUserProfileResponse, DefaultError, InfiniteData<GetUserProfileResponse>, QueryKey<Options<GetUserProfileData>>, Date | Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                after: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserProfile({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserProfileInfiniteQueryKey(options)
});

/**
 * Toggle public visibility for a workspace
 */
export const updatePublicVisibilityMutation = (options?: Partial<Options<UpdatePublicVisibilityData>>): UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePublicVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

/**
 * List repositories monitored by a workspace
 */
export const getRepositoriesToMonitorOptions = (options: Options<GetRepositoriesToMonitorData>) => queryOptions<GetRepositoriesToMonitorResponse, DefaultError, GetRepositoriesToMonitorResponse, ReturnType<typeof getRepositoriesToMonitorQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRepositoriesToMonitor({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRepositoriesToMonitorQueryKey(options)
});

/**
 * Remove a repository from a workspace monitor list
 */
export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add a repository to a workspace monitor list
 */
export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update leaderboard schedule configuration
 */
export const updateScheduleMutation = (options?: Partial<Options<UpdateScheduleData>>): UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> => {
    const mutationOptions: UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSchedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Slack credentials for a workspace
 */
export const updateSlackCredentialsMutation = (options?: Partial<Options<UpdateSlackCredentialsData>>): UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> => {
    const mutationOptions: UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateSlackCredentials({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rename workspace slug and create redirect
 */
export const renameSlugMutation = (options?: Partial<Options<RenameSlugData>>): UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> => {
    const mutationOptions: UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await renameSlug({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace lifecycle status
 */
export const updateStatusMutation = (options?: Partial<Options<UpdateStatusData>>): UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateStatus({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTeamsQueryKey = (options: Options<GetAllTeamsData>) => createQueryKey('getAllTeams', options);

/**
 * List teams
 *
 * Returns all teams in the workspace organization
 */
export const getAllTeamsOptions = (options: Options<GetAllTeamsData>) => queryOptions<GetAllTeamsResponse, DefaultError, GetAllTeamsResponse, ReturnType<typeof getAllTeamsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllTeams({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllTeamsQueryKey(options)
});

/**
 * Update team visibility
 *
 * Show or hide a team in leaderboard calculations
 */
export const updateTeamVisibilityMutation = (options?: Partial<Options<UpdateTeamVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateRepositoryVisibilityMutation = (options?: Partial<Options<UpdateRepositoryVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a repository label from a team
 */
export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add a repository label to a team
 */
export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTeamSettingsQueryKey = (options: Options<GetTeamSettingsData>) => createQueryKey('getTeamSettings', options);

/**
 * Get team settings
 *
 * Returns the visibility settings for a team in the workspace
 */
export const getTeamSettingsOptions = (options: Options<GetTeamSettingsData>) => queryOptions<GetTeamSettingsResponse, DefaultError, GetTeamSettingsResponse, ReturnType<typeof getTeamSettingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getTeamSettings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getTeamSettingsQueryKey(options)
});

/**
 * Update team settings
 *
 * Updates the visibility settings for a team in the workspace
 */
export const updateTeamSettingsMutation = (options?: Partial<Options<UpdateTeamSettingsData>>): UseMutationOptions<UpdateTeamSettingsResponse, UpdateTeamSettingsError, Options<UpdateTeamSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateTeamSettingsResponse, UpdateTeamSettingsError, Options<UpdateTeamSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateTeamSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLabelFiltersQueryKey = (options: Options<GetLabelFiltersData>) => createQueryKey('getLabelFilters', options);

/**
 * Get team label filters
 *
 * Returns all labels configured as filters for a team in the workspace
 */
export const getLabelFiltersOptions = (options: Options<GetLabelFiltersData>) => queryOptions<GetLabelFiltersResponse, DefaultError, GetLabelFiltersResponse, ReturnType<typeof getLabelFiltersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLabelFilters({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLabelFiltersQueryKey(options)
});

/**
 * Remove label filter
 *
 * Removes a label filter from a team in the workspace
 */
export const removeLabelFilterMutation = (options?: Partial<Options<RemoveLabelFilterData>>): UseMutationOptions<RemoveLabelFilterResponse, DefaultError, Options<RemoveLabelFilterData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFilterResponse, DefaultError, Options<RemoveLabelFilterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeLabelFilter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Add label filter
 *
 * Adds a label as a filter for a team in the workspace
 */
export const addLabelFilterMutation = (options?: Partial<Options<AddLabelFilterData>>): UseMutationOptions<unknown, DefaultError, Options<AddLabelFilterData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddLabelFilterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addLabelFilter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositorySettingsQueryKey = (options: Options<GetRepositorySettingsData>) => createQueryKey('getRepositorySettings', options);

/**
 * Get repository settings
 *
 * Returns the contribution visibility settings for a repository in a team
 */
export const getRepositorySettingsOptions = (options: Options<GetRepositorySettingsData>) => queryOptions<GetRepositorySettingsResponse, DefaultError, GetRepositorySettingsResponse, ReturnType<typeof getRepositorySettingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRepositorySettings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRepositorySettingsQueryKey(options)
});

/**
 * Update repository settings
 *
 * Updates the contribution visibility settings for a repository in a team
 */
export const updateRepositorySettingsMutation = (options?: Partial<Options<UpdateRepositorySettingsData>>): UseMutationOptions<UpdateRepositorySettingsResponse, UpdateRepositorySettingsError, Options<UpdateRepositorySettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateRepositorySettingsResponse, UpdateRepositorySettingsError, Options<UpdateRepositorySettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRepositorySettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace Personal Access Token
 */
export const updateTokenMutation = (options?: Partial<Options<UpdateTokenData>>): UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

/**
 * List workspace users and the teams they belong to
 */
export const getUsersWithTeamsOptions = (options: Options<GetUsersWithTeamsData>) => queryOptions<GetUsersWithTeamsResponse, DefaultError, GetUsersWithTeamsResponse, ReturnType<typeof getUsersWithTeamsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUsersWithTeams({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUsersWithTeamsQueryKey(options)
});

export const getUserAchievementsQueryKey = (options: Options<GetUserAchievementsData>) => createQueryKey('getUserAchievements', options);

/**
 * Get user achievements
 *
 * Returns all achievements with progress information for the specified user
 */
export const getUserAchievementsOptions = (options: Options<GetUserAchievementsData>) => queryOptions<GetUserAchievementsResponse, DefaultError, GetUserAchievementsResponse, ReturnType<typeof getUserAchievementsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserAchievements({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserAchievementsQueryKey(options)
});
