// This file is auto-generated by @hey-api/openapi-ts

import { type Options, provideFeedbackForBadPractice, resolveBadPractice, detectBadPracticesForPullRequest, detectBadPracticesByUser, getActivityByUser, getLeaderboard, getUserLeagueStats, postMentorChat, postMentorChatMessagesByMessageIdVote, getMentorDocuments, postMentorDocuments, deleteMentorDocumentsById, getMentorDocumentsById, putMentorDocumentsById, deleteMentorDocumentsByIdVersions, getMentorDocumentsByIdVersions, getMentorDocumentsByIdVersionsByVersionNumber, getMentorThreadsByThreadId, getMetaData, getContributors, getAllTeams, updateTeamVisibility, deleteUser, getUserSettings, updateUserSettings, getUserProfile, resetAndRecalculateLeagues, getRepositoriesToMonitor, removeRepositoryToMonitor, addRepositoryToMonitor, removeLabelFromTeam, addLabelToTeam, getUsersWithTeams } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { ProvideFeedbackForBadPracticeData, ResolveBadPracticeData, DetectBadPracticesForPullRequestData, DetectBadPracticesByUserData, GetActivityByUserData, GetLeaderboardData, GetLeaderboardResponse, GetUserLeagueStatsData, GetUserLeagueStatsResponse, PostMentorChatData, PostMentorChatResponse, PostMentorChatMessagesByMessageIdVoteData, PostMentorChatMessagesByMessageIdVoteError, PostMentorChatMessagesByMessageIdVoteResponse, GetMentorDocumentsData, GetMentorDocumentsError, GetMentorDocumentsResponse, PostMentorDocumentsData, PostMentorDocumentsError, PostMentorDocumentsResponse, DeleteMentorDocumentsByIdData, DeleteMentorDocumentsByIdError, DeleteMentorDocumentsByIdResponse, GetMentorDocumentsByIdData, PutMentorDocumentsByIdData, PutMentorDocumentsByIdError, PutMentorDocumentsByIdResponse, DeleteMentorDocumentsByIdVersionsData, DeleteMentorDocumentsByIdVersionsError, DeleteMentorDocumentsByIdVersionsResponse, GetMentorDocumentsByIdVersionsData, GetMentorDocumentsByIdVersionsError, GetMentorDocumentsByIdVersionsResponse, GetMentorDocumentsByIdVersionsByVersionNumberData, GetMentorThreadsByThreadIdData, GetMetaDataData, GetContributorsData, GetAllTeamsData, UpdateTeamVisibilityData, DeleteUserData, GetUserSettingsData, UpdateUserSettingsData, UpdateUserSettingsResponse, GetUserProfileData, ResetAndRecalculateLeaguesData, GetRepositoriesToMonitorData, RemoveRepositoryToMonitorData, AddRepositoryToMonitorData, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, AddLabelToTeamData, AddLabelToTeamResponse, GetUsersWithTeamsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const provideFeedbackForBadPracticeQueryKey = (options: Options<ProvideFeedbackForBadPracticeData>) => createQueryKey('provideFeedbackForBadPractice', options);

export const provideFeedbackForBadPracticeOptions = (options: Options<ProvideFeedbackForBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: provideFeedbackForBadPracticeQueryKey(options)
    });
};

export const provideFeedbackForBadPracticeMutation = (options?: Partial<Options<ProvideFeedbackForBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveBadPracticeQueryKey = (options: Options<ResolveBadPracticeData>) => createQueryKey('resolveBadPractice', options);

export const resolveBadPracticeOptions = (options: Options<ResolveBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveBadPracticeQueryKey(options)
    });
};

export const resolveBadPracticeMutation = (options?: Partial<Options<ResolveBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesForPullRequestQueryKey = (options: Options<DetectBadPracticesForPullRequestData>) => createQueryKey('detectBadPracticesForPullRequest', options);

export const detectBadPracticesForPullRequestOptions = (options: Options<DetectBadPracticesForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesForPullRequestQueryKey(options)
    });
};

export const detectBadPracticesForPullRequestMutation = (options?: Partial<Options<DetectBadPracticesForPullRequestData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesByUserQueryKey = (options: Options<DetectBadPracticesByUserData>) => createQueryKey('detectBadPracticesByUser', options);

export const detectBadPracticesByUserOptions = (options: Options<DetectBadPracticesByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesByUserQueryKey(options)
    });
};

export const detectBadPracticesByUserMutation = (options?: Partial<Options<DetectBadPracticesByUserData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActivityByUserQueryKey = (options: Options<GetActivityByUserData>) => createQueryKey('getActivityByUser', options);

export const getActivityByUserOptions = (options: Options<GetActivityByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActivityByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActivityByUserQueryKey(options)
    });
};

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLeaderboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => {
    return infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLeaderboard({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardInfiniteQueryKey(options)
    });
};

export const getUserLeagueStatsQueryKey = (options: Options<GetUserLeagueStatsData>) => createQueryKey('getUserLeagueStats', options);

export const getUserLeagueStatsOptions = (options: Options<GetUserLeagueStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLeagueStatsQueryKey(options)
    });
};

export const getUserLeagueStatsMutation = (options?: Partial<Options<GetUserLeagueStatsData>>): UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postMentorChatQueryKey = (options: Options<PostMentorChatData>) => createQueryKey('postMentorChat', options);

/**
 * Handle mentor chat
 */
export const postMentorChatOptions = (options: Options<PostMentorChatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMentorChat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMentorChatQueryKey(options)
    });
};

/**
 * Handle mentor chat
 */
export const postMentorChatMutation = (options?: Partial<Options<PostMentorChatData>>): UseMutationOptions<PostMentorChatResponse, DefaultError, Options<PostMentorChatData>> => {
    const mutationOptions: UseMutationOptions<PostMentorChatResponse, DefaultError, Options<PostMentorChatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMentorChat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postMentorChatMessagesByMessageIdVoteQueryKey = (options: Options<PostMentorChatMessagesByMessageIdVoteData>) => createQueryKey('postMentorChatMessagesByMessageIdVote', options);

/**
 * Vote on a chat message (upvote/downvote)
 */
export const postMentorChatMessagesByMessageIdVoteOptions = (options: Options<PostMentorChatMessagesByMessageIdVoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMentorChatMessagesByMessageIdVote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMentorChatMessagesByMessageIdVoteQueryKey(options)
    });
};

/**
 * Vote on a chat message (upvote/downvote)
 */
export const postMentorChatMessagesByMessageIdVoteMutation = (options?: Partial<Options<PostMentorChatMessagesByMessageIdVoteData>>): UseMutationOptions<PostMentorChatMessagesByMessageIdVoteResponse, PostMentorChatMessagesByMessageIdVoteError, Options<PostMentorChatMessagesByMessageIdVoteData>> => {
    const mutationOptions: UseMutationOptions<PostMentorChatMessagesByMessageIdVoteResponse, PostMentorChatMessagesByMessageIdVoteError, Options<PostMentorChatMessagesByMessageIdVoteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMentorChatMessagesByMessageIdVote({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMentorDocumentsQueryKey = (options?: Options<GetMentorDocumentsData>) => createQueryKey('getMentorDocuments', options);

/**
 * List latest version of documents (no auth; all users)
 */
export const getMentorDocumentsOptions = (options?: Options<GetMentorDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMentorDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsQueryKey(options)
    });
};

export const getMentorDocumentsInfiniteQueryKey = (options?: Options<GetMentorDocumentsData>): QueryKey<Options<GetMentorDocumentsData>> => createQueryKey('getMentorDocuments', options, true);

/**
 * List latest version of documents (no auth; all users)
 */
export const getMentorDocumentsInfiniteOptions = (options?: Options<GetMentorDocumentsData>) => {
    return infiniteQueryOptions<GetMentorDocumentsResponse, GetMentorDocumentsError, InfiniteData<GetMentorDocumentsResponse>, QueryKey<Options<GetMentorDocumentsData>>, number | null | Pick<QueryKey<Options<GetMentorDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMentorDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMentorDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsInfiniteQueryKey(options)
    });
};

export const postMentorDocumentsQueryKey = (options: Options<PostMentorDocumentsData>) => createQueryKey('postMentorDocuments', options);

/**
 * Create a new document
 */
export const postMentorDocumentsOptions = (options: Options<PostMentorDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMentorDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMentorDocumentsQueryKey(options)
    });
};

/**
 * Create a new document
 */
export const postMentorDocumentsMutation = (options?: Partial<Options<PostMentorDocumentsData>>): UseMutationOptions<PostMentorDocumentsResponse, PostMentorDocumentsError, Options<PostMentorDocumentsData>> => {
    const mutationOptions: UseMutationOptions<PostMentorDocumentsResponse, PostMentorDocumentsError, Options<PostMentorDocumentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMentorDocuments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all versions
 */
export const deleteMentorDocumentsByIdMutation = (options?: Partial<Options<DeleteMentorDocumentsByIdData>>): UseMutationOptions<DeleteMentorDocumentsByIdResponse, DeleteMentorDocumentsByIdError, Options<DeleteMentorDocumentsByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteMentorDocumentsByIdResponse, DeleteMentorDocumentsByIdError, Options<DeleteMentorDocumentsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMentorDocumentsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMentorDocumentsByIdQueryKey = (options: Options<GetMentorDocumentsByIdData>) => createQueryKey('getMentorDocumentsById', options);

/**
 * Get latest version of a document
 */
export const getMentorDocumentsByIdOptions = (options: Options<GetMentorDocumentsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMentorDocumentsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsByIdQueryKey(options)
    });
};

/**
 * Update a document (creates new version)
 */
export const putMentorDocumentsByIdMutation = (options?: Partial<Options<PutMentorDocumentsByIdData>>): UseMutationOptions<PutMentorDocumentsByIdResponse, PutMentorDocumentsByIdError, Options<PutMentorDocumentsByIdData>> => {
    const mutationOptions: UseMutationOptions<PutMentorDocumentsByIdResponse, PutMentorDocumentsByIdError, Options<PutMentorDocumentsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putMentorDocumentsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete versions after timestamp
 */
export const deleteMentorDocumentsByIdVersionsMutation = (options?: Partial<Options<DeleteMentorDocumentsByIdVersionsData>>): UseMutationOptions<DeleteMentorDocumentsByIdVersionsResponse, DeleteMentorDocumentsByIdVersionsError, Options<DeleteMentorDocumentsByIdVersionsData>> => {
    const mutationOptions: UseMutationOptions<DeleteMentorDocumentsByIdVersionsResponse, DeleteMentorDocumentsByIdVersionsError, Options<DeleteMentorDocumentsByIdVersionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMentorDocumentsByIdVersions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMentorDocumentsByIdVersionsQueryKey = (options: Options<GetMentorDocumentsByIdVersionsData>) => createQueryKey('getMentorDocumentsByIdVersions', options);

/**
 * List versions of a document
 */
export const getMentorDocumentsByIdVersionsOptions = (options: Options<GetMentorDocumentsByIdVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMentorDocumentsByIdVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsByIdVersionsQueryKey(options)
    });
};

export const getMentorDocumentsByIdVersionsInfiniteQueryKey = (options: Options<GetMentorDocumentsByIdVersionsData>): QueryKey<Options<GetMentorDocumentsByIdVersionsData>> => createQueryKey('getMentorDocumentsByIdVersions', options, true);

/**
 * List versions of a document
 */
export const getMentorDocumentsByIdVersionsInfiniteOptions = (options: Options<GetMentorDocumentsByIdVersionsData>) => {
    return infiniteQueryOptions<GetMentorDocumentsByIdVersionsResponse, GetMentorDocumentsByIdVersionsError, InfiniteData<GetMentorDocumentsByIdVersionsResponse>, QueryKey<Options<GetMentorDocumentsByIdVersionsData>>, number | null | Pick<QueryKey<Options<GetMentorDocumentsByIdVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMentorDocumentsByIdVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMentorDocumentsByIdVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsByIdVersionsInfiniteQueryKey(options)
    });
};

export const getMentorDocumentsByIdVersionsByVersionNumberQueryKey = (options: Options<GetMentorDocumentsByIdVersionsByVersionNumberData>) => createQueryKey('getMentorDocumentsByIdVersionsByVersionNumber', options);

/**
 * Get specific version
 */
export const getMentorDocumentsByIdVersionsByVersionNumberOptions = (options: Options<GetMentorDocumentsByIdVersionsByVersionNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMentorDocumentsByIdVersionsByVersionNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorDocumentsByIdVersionsByVersionNumberQueryKey(options)
    });
};

export const getMentorThreadsByThreadIdQueryKey = (options: Options<GetMentorThreadsByThreadIdData>) => createQueryKey('getMentorThreadsByThreadId', options);

/**
 * Get mentor chat thread detail
 */
export const getMentorThreadsByThreadIdOptions = (options: Options<GetMentorThreadsByThreadIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMentorThreadsByThreadId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMentorThreadsByThreadIdQueryKey(options)
    });
};

export const getMetaDataQueryKey = (options?: Options<GetMetaDataData>) => createQueryKey('getMetaData', options);

export const getMetaDataOptions = (options?: Options<GetMetaDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetaData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetaDataQueryKey(options)
    });
};

export const getContributorsQueryKey = (options?: Options<GetContributorsData>) => createQueryKey('getContributors', options);

export const getContributorsOptions = (options?: Options<GetContributorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContributors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContributorsQueryKey(options)
    });
};

export const getAllTeamsQueryKey = (options?: Options<GetAllTeamsData>) => createQueryKey('getAllTeams', options);

export const getAllTeamsOptions = (options?: Options<GetAllTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTeamsQueryKey(options)
    });
};

export const updateTeamVisibilityQueryKey = (options: Options<UpdateTeamVisibilityData>) => createQueryKey('updateTeamVisibility', options);

export const updateTeamVisibilityOptions = (options: Options<UpdateTeamVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateTeamVisibilityQueryKey(options)
    });
};

export const updateTeamVisibilityMutation = (options?: Partial<Options<UpdateTeamVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsQueryKey = (options: Options<UpdateUserSettingsData>) => createQueryKey('updateUserSettings', options);

export const updateUserSettingsOptions = (options: Options<UpdateUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

export const getUserProfileOptions = (options: Options<GetUserProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileQueryKey(options)
    });
};

export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options?: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

export const getRepositoriesToMonitorOptions = (options?: Options<GetRepositoriesToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoriesToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesToMonitorQueryKey(options)
    });
};

export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToMonitorQueryKey = (options: Options<AddRepositoryToMonitorData>) => createQueryKey('addRepositoryToMonitor', options);

export const addRepositoryToMonitorOptions = (options: Options<AddRepositoryToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToMonitorQueryKey(options)
    });
};

export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelToTeamQueryKey = (options: Options<AddLabelToTeamData>) => createQueryKey('addLabelToTeam', options);

export const addLabelToTeamOptions = (options: Options<AddLabelToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelToTeamQueryKey(options)
    });
};

export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options?: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

export const getUsersWithTeamsOptions = (options?: Options<GetUsersWithTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersWithTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersWithTeamsQueryKey(options)
    });
};