// This file is auto-generated by @hey-api/openapi-ts

import { type Options, provideFeedbackForBadPractice, resolveBadPractice, detectBadPracticesForPullRequest, detectBadPracticesByUser, getActivityByUser, voteMessage, getUserDocuments, createDocument, deleteDocument, getDocument, updateDocument, deleteVersionsAfterTimestamp, getDocumentVersions, getDocumentVersion, getLeaderboard, getUserLeagueStats, getThread, getThreads, getGroupedThreads, getMetaData, getContributors, getAllTeams, updateTeamVisibility, updateRepositoryVisibility, deleteUser, getUserSettings, updateUserSettings, getUserProfile, listWorkspaces, createWorkspace, resetAndRecalculateLeagues, getRepositoriesToMonitor, removeRepositoryToMonitor, addRepositoryToMonitor, removeLabelFromTeam, addLabelToTeam, getUsersWithTeams, purgeWorkspace, getWorkspace, updateNotifications, updatePublicVisibility, resumeWorkspace, updateSchedule, updateSlackCredentials, suspendWorkspace, updateToken } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { ProvideFeedbackForBadPracticeData, ResolveBadPracticeData, DetectBadPracticesForPullRequestData, DetectBadPracticesByUserData, GetActivityByUserData, VoteMessageData, VoteMessageError, VoteMessageResponse, GetUserDocumentsData, GetUserDocumentsResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, DeleteDocumentData, DeleteDocumentResponse, GetDocumentData, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, DeleteVersionsAfterTimestampData, DeleteVersionsAfterTimestampError, DeleteVersionsAfterTimestampResponse, GetDocumentVersionsData, GetDocumentVersionsError, GetDocumentVersionsResponse, GetDocumentVersionData, GetLeaderboardData, GetLeaderboardResponse, GetUserLeagueStatsData, GetUserLeagueStatsResponse, GetThreadData, GetThreadsData, GetGroupedThreadsData, GetMetaDataData, GetContributorsData, GetAllTeamsData, UpdateTeamVisibilityData, UpdateRepositoryVisibilityData, DeleteUserData, GetUserSettingsData, UpdateUserSettingsData, UpdateUserSettingsResponse, GetUserProfileData, ListWorkspacesData, CreateWorkspaceData, CreateWorkspaceResponse, ResetAndRecalculateLeaguesData, GetRepositoriesToMonitorData, RemoveRepositoryToMonitorData, AddRepositoryToMonitorData, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, AddLabelToTeamData, AddLabelToTeamResponse, GetUsersWithTeamsData, PurgeWorkspaceData, PurgeWorkspaceResponse, GetWorkspaceData, UpdateNotificationsData, UpdateNotificationsResponse, UpdatePublicVisibilityData, UpdatePublicVisibilityResponse, ResumeWorkspaceData, ResumeWorkspaceResponse, UpdateScheduleData, UpdateScheduleResponse, UpdateSlackCredentialsData, UpdateSlackCredentialsResponse, SuspendWorkspaceData, SuspendWorkspaceResponse, UpdateTokenData, UpdateTokenResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const provideFeedbackForBadPracticeQueryKey = (options: Options<ProvideFeedbackForBadPracticeData>) => createQueryKey('provideFeedbackForBadPractice', options);

export const provideFeedbackForBadPracticeOptions = (options: Options<ProvideFeedbackForBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: provideFeedbackForBadPracticeQueryKey(options)
    });
};

export const provideFeedbackForBadPracticeMutation = (options?: Partial<Options<ProvideFeedbackForBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveBadPracticeQueryKey = (options: Options<ResolveBadPracticeData>) => createQueryKey('resolveBadPractice', options);

export const resolveBadPracticeOptions = (options: Options<ResolveBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveBadPracticeQueryKey(options)
    });
};

export const resolveBadPracticeMutation = (options?: Partial<Options<ResolveBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesForPullRequestQueryKey = (options: Options<DetectBadPracticesForPullRequestData>) => createQueryKey('detectBadPracticesForPullRequest', options);

export const detectBadPracticesForPullRequestOptions = (options: Options<DetectBadPracticesForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesForPullRequestQueryKey(options)
    });
};

export const detectBadPracticesForPullRequestMutation = (options?: Partial<Options<DetectBadPracticesForPullRequestData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesByUserQueryKey = (options: Options<DetectBadPracticesByUserData>) => createQueryKey('detectBadPracticesByUser', options);

export const detectBadPracticesByUserOptions = (options: Options<DetectBadPracticesByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesByUserQueryKey(options)
    });
};

export const detectBadPracticesByUserMutation = (options?: Partial<Options<DetectBadPracticesByUserData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActivityByUserQueryKey = (options: Options<GetActivityByUserData>) => createQueryKey('getActivityByUser', options);

export const getActivityByUserOptions = (options: Options<GetActivityByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActivityByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActivityByUserQueryKey(options)
    });
};

export const voteMessageQueryKey = (options: Options<VoteMessageData>) => createQueryKey('voteMessage', options);

/**
 * Vote on a message
 * Cast an upvote or downvote on a chat message
 */
export const voteMessageOptions = (options: Options<VoteMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await voteMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: voteMessageQueryKey(options)
    });
};

/**
 * Vote on a message
 * Cast an upvote or downvote on a chat message
 */
export const voteMessageMutation = (options?: Partial<Options<VoteMessageData>>): UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> => {
    const mutationOptions: UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await voteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserDocumentsQueryKey = (options?: Options<GetUserDocumentsData>) => createQueryKey('getUserDocuments', options);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsOptions = (options?: Options<GetUserDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getUserDocumentsInfiniteQueryKey = (options?: Options<GetUserDocumentsData>): QueryKey<Options<GetUserDocumentsData>> => createQueryKey('getUserDocuments', options, true);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsInfiniteOptions = (options?: Options<GetUserDocumentsData>) => {
    return infiniteQueryOptions<GetUserDocumentsResponse, DefaultError, InfiniteData<GetUserDocumentsResponse>, QueryKey<Options<GetUserDocumentsData>>, number | Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getUserDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsInfiniteQueryKey(options)
    });
};

export const createDocumentQueryKey = (options: Options<CreateDocumentData>) => createQueryKey('createDocument', options);

/**
 * Create a new document
 */
export const createDocumentOptions = (options: Options<CreateDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDocumentQueryKey(options)
    });
};

/**
 * Create a new document
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all its versions
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get latest version of a document
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentQueryKey(options)
    });
};

/**
 * Update a document (creates new version)
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete document versions after specified timestamp
 */
export const deleteVersionsAfterTimestampMutation = (options?: Partial<Options<DeleteVersionsAfterTimestampData>>): UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> => {
    const mutationOptions: UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteVersionsAfterTimestamp({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentVersionsQueryKey = (options: Options<GetDocumentVersionsData>) => createQueryKey('getDocumentVersions', options);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsOptions = (options: Options<GetDocumentVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsQueryKey(options)
    });
};

export const getDocumentVersionsInfiniteQueryKey = (options: Options<GetDocumentVersionsData>): QueryKey<Options<GetDocumentVersionsData>> => createQueryKey('getDocumentVersions', options, true);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsInfiniteOptions = (options: Options<GetDocumentVersionsData>) => {
    return infiniteQueryOptions<GetDocumentVersionsResponse, GetDocumentVersionsError, InfiniteData<GetDocumentVersionsResponse>, QueryKey<Options<GetDocumentVersionsData>>, number | Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocumentVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsInfiniteQueryKey(options)
    });
};

export const getDocumentVersionQueryKey = (options: Options<GetDocumentVersionData>) => createQueryKey('getDocumentVersion', options);

/**
 * Get specific version of a document by version number
 */
export const getDocumentVersionOptions = (options: Options<GetDocumentVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionQueryKey(options)
    });
};

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLeaderboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardQueryKey(options)
    });
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => {
    return infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLeaderboard({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardInfiniteQueryKey(options)
    });
};

export const getUserLeagueStatsQueryKey = (options: Options<GetUserLeagueStatsData>) => createQueryKey('getUserLeagueStats', options);

export const getUserLeagueStatsOptions = (options: Options<GetUserLeagueStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLeagueStatsQueryKey(options)
    });
};

export const getUserLeagueStatsMutation = (options?: Partial<Options<GetUserLeagueStatsData>>): UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getThreadQueryKey = (options: Options<GetThreadData>) => createQueryKey('getThread', options);

/**
 * Get chat thread detail
 * Retrieve a specific chat thread with all messages
 */
export const getThreadOptions = (options: Options<GetThreadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThread({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadQueryKey(options)
    });
};

export const getThreadsQueryKey = (options?: Options<GetThreadsData>) => createQueryKey('getThreads', options);

/**
 * Get user's chat threads
 * Retrieve all chat threads for the authenticated user
 */
export const getThreadsOptions = (options?: Options<GetThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadsQueryKey(options)
    });
};

export const getGroupedThreadsQueryKey = (options?: Options<GetGroupedThreadsData>) => createQueryKey('getGroupedThreads', options);

/**
 * Get user's grouped chat threads
 * Retrieve all chat threads for the authenticated user grouped by time periods
 */
export const getGroupedThreadsOptions = (options?: Options<GetGroupedThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupedThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupedThreadsQueryKey(options)
    });
};

export const getMetaDataQueryKey = (options?: Options<GetMetaDataData>) => createQueryKey('getMetaData', options);

export const getMetaDataOptions = (options?: Options<GetMetaDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetaData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetaDataQueryKey(options)
    });
};

export const getContributorsQueryKey = (options?: Options<GetContributorsData>) => createQueryKey('getContributors', options);

export const getContributorsOptions = (options?: Options<GetContributorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContributors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContributorsQueryKey(options)
    });
};

export const getAllTeamsQueryKey = (options?: Options<GetAllTeamsData>) => createQueryKey('getAllTeams', options);

export const getAllTeamsOptions = (options?: Options<GetAllTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTeamsQueryKey(options)
    });
};

export const updateTeamVisibilityQueryKey = (options: Options<UpdateTeamVisibilityData>) => createQueryKey('updateTeamVisibility', options);

export const updateTeamVisibilityOptions = (options: Options<UpdateTeamVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateTeamVisibilityQueryKey(options)
    });
};

export const updateTeamVisibilityMutation = (options?: Partial<Options<UpdateTeamVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateRepositoryVisibilityQueryKey = (options: Options<UpdateRepositoryVisibilityData>) => createQueryKey('updateRepositoryVisibility', options);

export const updateRepositoryVisibilityOptions = (options: Options<UpdateRepositoryVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateRepositoryVisibilityQueryKey(options)
    });
};

export const updateRepositoryVisibilityMutation = (options?: Partial<Options<UpdateRepositoryVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsQueryKey = (options: Options<UpdateUserSettingsData>) => createQueryKey('updateUserSettings', options);

export const updateUserSettingsOptions = (options: Options<UpdateUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

export const getUserProfileOptions = (options: Options<GetUserProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileQueryKey(options)
    });
};

export const listWorkspacesQueryKey = (options?: Options<ListWorkspacesData>) => createQueryKey('listWorkspaces', options);

export const listWorkspacesOptions = (options?: Options<ListWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWorkspacesQueryKey(options)
    });
};

export const createWorkspaceQueryKey = (options: Options<CreateWorkspaceData>) => createQueryKey('createWorkspace', options);

export const createWorkspaceOptions = (options: Options<CreateWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWorkspaceQueryKey(options)
    });
};

export const createWorkspaceMutation = (options?: Partial<Options<CreateWorkspaceData>>): UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

export const getRepositoriesToMonitorOptions = (options: Options<GetRepositoriesToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoriesToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesToMonitorQueryKey(options)
    });
};

export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToMonitorQueryKey = (options: Options<AddRepositoryToMonitorData>) => createQueryKey('addRepositoryToMonitor', options);

export const addRepositoryToMonitorOptions = (options: Options<AddRepositoryToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToMonitorQueryKey(options)
    });
};

export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelToTeamQueryKey = (options: Options<AddLabelToTeamData>) => createQueryKey('addLabelToTeam', options);

export const addLabelToTeamOptions = (options: Options<AddLabelToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelToTeamQueryKey(options)
    });
};

export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

export const getUsersWithTeamsOptions = (options: Options<GetUsersWithTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersWithTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersWithTeamsQueryKey(options)
    });
};

export const purgeWorkspaceMutation = (options?: Partial<Options<PurgeWorkspaceData>>): UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await purgeWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspaceQueryKey = (options: Options<GetWorkspaceData>) => createQueryKey('getWorkspace', options);

export const getWorkspaceOptions = (options: Options<GetWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspaceQueryKey(options)
    });
};

export const updateNotificationsMutation = (options?: Partial<Options<UpdateNotificationsData>>): UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> => {
    const mutationOptions: UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePublicVisibilityMutation = (options?: Partial<Options<UpdatePublicVisibilityData>>): UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePublicVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resumeWorkspaceQueryKey = (options: Options<ResumeWorkspaceData>) => createQueryKey('resumeWorkspace', options);

export const resumeWorkspaceOptions = (options: Options<ResumeWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resumeWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resumeWorkspaceQueryKey(options)
    });
};

export const resumeWorkspaceMutation = (options?: Partial<Options<ResumeWorkspaceData>>): UseMutationOptions<ResumeWorkspaceResponse, DefaultError, Options<ResumeWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<ResumeWorkspaceResponse, DefaultError, Options<ResumeWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resumeWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateScheduleMutation = (options?: Partial<Options<UpdateScheduleData>>): UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> => {
    const mutationOptions: UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSchedule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateSlackCredentialsMutation = (options?: Partial<Options<UpdateSlackCredentialsData>>): UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> => {
    const mutationOptions: UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSlackCredentials({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const suspendWorkspaceQueryKey = (options: Options<SuspendWorkspaceData>) => createQueryKey('suspendWorkspace', options);

export const suspendWorkspaceOptions = (options: Options<SuspendWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await suspendWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: suspendWorkspaceQueryKey(options)
    });
};

export const suspendWorkspaceMutation = (options?: Partial<Options<SuspendWorkspaceData>>): UseMutationOptions<SuspendWorkspaceResponse, DefaultError, Options<SuspendWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<SuspendWorkspaceResponse, DefaultError, Options<SuspendWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await suspendWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateTokenMutation = (options?: Partial<Options<UpdateTokenData>>): UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};