// This file is auto-generated by @hey-api/openapi-ts

import { type Options, listGlobalContributors, deleteUser, getUserSettings, updateUserSettings, listWorkspaces, createWorkspace, purgeWorkspace, getWorkspace, getLeaderboard, getUserLeagueStats, resetAndRecalculateLeagues, listMembers, assignRole, getCurrentUserMembership, removeMember, getMember, mentorChat, listDocuments, createDocument, deleteDocument, getDocument, updateDocument, deleteDocumentVersionsAfter, listVersions, getVersion, voteMessage, getGroupedThreads, getThread, updateNotifications, getBadPractice, provideFeedback, resolve, getBadPracticesForPullRequest, detectForPullRequest, getBadPracticesForUser, detectForUser, getUserProfile, updatePublicVisibility, getRepositoriesToMonitor, removeRepositoryToMonitor, addRepositoryToMonitor, updateSchedule, updateSlackCredentials, renameSlug, updateStatus, getAllTeams, updateTeamVisibility, updateRepositoryVisibility, removeLabelFromTeam, addLabelToTeam, getTeamSettings, updateTeamSettings, getLabelFilters, removeLabelFilter, addLabelFilter, getRepositorySettings, updateRepositorySettings, updateToken, getUsersWithTeams } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { ListGlobalContributorsData, DeleteUserData, GetUserSettingsData, UpdateUserSettingsData, UpdateUserSettingsResponse, ListWorkspacesData, CreateWorkspaceData, CreateWorkspaceResponse, PurgeWorkspaceData, PurgeWorkspaceResponse, GetWorkspaceData, GetLeaderboardData, GetLeaderboardResponse, GetUserLeagueStatsData, GetUserLeagueStatsResponse, ResetAndRecalculateLeaguesData, ListMembersData, ListMembersResponse, AssignRoleData, AssignRoleResponse, GetCurrentUserMembershipData, RemoveMemberData, GetMemberData, MentorChatData, MentorChatResponse, ListDocumentsData, ListDocumentsError, ListDocumentsResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, DeleteDocumentData, DeleteDocumentError, DeleteDocumentResponse, GetDocumentData, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, DeleteDocumentVersionsAfterData, DeleteDocumentVersionsAfterError, DeleteDocumentVersionsAfterResponse, ListVersionsData, ListVersionsError, ListVersionsResponse, GetVersionData, VoteMessageData, VoteMessageError, VoteMessageResponse, GetGroupedThreadsData, GetThreadData, UpdateNotificationsData, UpdateNotificationsResponse, GetBadPracticeData, ProvideFeedbackData, ResolveData, GetBadPracticesForPullRequestData, DetectForPullRequestData, DetectForPullRequestError, DetectForPullRequestResponse, GetBadPracticesForUserData, DetectForUserData, DetectForUserError, DetectForUserResponse, GetUserProfileData, GetUserProfileResponse, UpdatePublicVisibilityData, UpdatePublicVisibilityResponse, GetRepositoriesToMonitorData, RemoveRepositoryToMonitorData, AddRepositoryToMonitorData, UpdateScheduleData, UpdateScheduleResponse, UpdateSlackCredentialsData, UpdateSlackCredentialsResponse, RenameSlugData, RenameSlugResponse, UpdateStatusData, UpdateStatusResponse, GetAllTeamsData, UpdateTeamVisibilityData, UpdateRepositoryVisibilityData, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, AddLabelToTeamData, AddLabelToTeamResponse, GetTeamSettingsData, UpdateTeamSettingsData, UpdateTeamSettingsError, UpdateTeamSettingsResponse, GetLabelFiltersData, RemoveLabelFilterData, RemoveLabelFilterResponse, AddLabelFilterData, GetRepositorySettingsData, UpdateRepositorySettingsData, UpdateRepositorySettingsError, UpdateRepositorySettingsResponse, UpdateTokenData, UpdateTokenResponse, GetUsersWithTeamsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const listGlobalContributorsQueryKey = (options?: Options<ListGlobalContributorsData>) => createQueryKey('listGlobalContributors', options);

/**
 * List global contributors
 * Returns contributors to the Hephaestus project (for the About page)
 */
export const listGlobalContributorsOptions = (options?: Options<ListGlobalContributorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listGlobalContributors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listGlobalContributorsQueryKey(options)
    });
};

/**
 * Delete user account
 * Permanently delete the current user's account and all associated data (GDPR)
 */
export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

/**
 * Get user settings
 * Get the current user's notification and research participation preferences
 */
export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsQueryKey = (options: Options<UpdateUserSettingsData>) => createQueryKey('updateUserSettings', options);

/**
 * Update user settings
 * Update the current user's notification and research participation preferences
 */
export const updateUserSettingsOptions = (options: Options<UpdateUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateUserSettingsQueryKey(options)
    });
};

/**
 * Update user settings
 * Update the current user's notification and research participation preferences
 */
export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWorkspacesQueryKey = (options?: Options<ListWorkspacesData>) => createQueryKey('listWorkspaces', options);

/**
 * List all workspaces
 */
export const listWorkspacesOptions = (options?: Options<ListWorkspacesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWorkspaces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWorkspacesQueryKey(options)
    });
};

export const createWorkspaceQueryKey = (options: Options<CreateWorkspaceData>) => createQueryKey('createWorkspace', options);

/**
 * Create a new workspace
 */
export const createWorkspaceOptions = (options: Options<CreateWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWorkspaceQueryKey(options)
    });
};

/**
 * Create a new workspace
 */
export const createWorkspaceMutation = (options?: Partial<Options<CreateWorkspaceData>>): UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkspaceResponse, DefaultError, Options<CreateWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Purge (soft delete) a workspace
 */
export const purgeWorkspaceMutation = (options?: Partial<Options<PurgeWorkspaceData>>): UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> => {
    const mutationOptions: UseMutationOptions<PurgeWorkspaceResponse, DefaultError, Options<PurgeWorkspaceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await purgeWorkspace({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkspaceQueryKey = (options: Options<GetWorkspaceData>) => createQueryKey('getWorkspace', options);

/**
 * Fetch a workspace by slug
 */
export const getWorkspaceOptions = (options: Options<GetWorkspaceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkspace({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkspaceQueryKey(options)
    });
};

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

/**
 * Generate leaderboard
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLeaderboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

/**
 * Generate leaderboard
 * Creates a ranked contributor list for the specified time range
 */
export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => {
    return infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLeaderboard({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardInfiniteQueryKey(options)
    });
};

export const getUserLeagueStatsQueryKey = (options: Options<GetUserLeagueStatsData>) => createQueryKey('getUserLeagueStats', options);

/**
 * Calculate user league stats
 * Computes projected league point changes for a specific user based on their leaderboard entry
 */
export const getUserLeagueStatsOptions = (options: Options<GetUserLeagueStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLeagueStatsQueryKey(options)
    });
};

/**
 * Calculate user league stats
 * Computes projected league point changes for a specific user based on their leaderboard entry
 */
export const getUserLeagueStatsMutation = (options?: Partial<Options<GetUserLeagueStatsData>>): UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset and recalculate workspace leagues
 */
export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listMembersQueryKey = (options: Options<ListMembersData>) => createQueryKey('listMembers', options);

/**
 * List all members of the workspace with pagination.
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersOptions = (options: Options<ListMembersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listMembers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersQueryKey(options)
    });
};

export const listMembersInfiniteQueryKey = (options: Options<ListMembersData>): QueryKey<Options<ListMembersData>> => createQueryKey('listMembers', options, true);

/**
 * List all members of the workspace with pagination.
 * List all members of the workspace with pagination.
 * Accessible to all workspace members (MEMBER role and above).
 */
export const listMembersInfiniteOptions = (options: Options<ListMembersData>) => {
    return infiniteQueryOptions<ListMembersResponse, DefaultError, InfiniteData<ListMembersResponse>, QueryKey<Options<ListMembersData>>, number | Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listMembers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listMembersInfiniteQueryKey(options)
    });
};

export const assignRoleQueryKey = (options: Options<AssignRoleData>) => createQueryKey('assignRole', options);

/**
 * Assign or update a role for a workspace member.
 * Assign or update a role for a workspace member.
 * OWNER can assign any role. ADMIN can assign ADMIN or MEMBER roles.
 */
export const assignRoleOptions = (options: Options<AssignRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignRoleQueryKey(options)
    });
};

/**
 * Assign or update a role for a workspace member.
 * Assign or update a role for a workspace member.
 * OWNER can assign any role. ADMIN can assign ADMIN or MEMBER roles.
 */
export const assignRoleMutation = (options?: Partial<Options<AssignRoleData>>): UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignRoleResponse, DefaultError, Options<AssignRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserMembershipQueryKey = (options: Options<GetCurrentUserMembershipData>) => createQueryKey('getCurrentUserMembership', options);

/**
 * Get the current user's membership in this workspace.
 * Get the current user's membership in this workspace.
 */
export const getCurrentUserMembershipOptions = (options: Options<GetCurrentUserMembershipData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUserMembership({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserMembershipQueryKey(options)
    });
};

/**
 * Revoke a user's membership (remove them from workspace).
 * Revoke a user's membership (remove them from workspace).
 * OWNER can remove anyone except themselves if they are the last OWNER.
 * ADMIN can remove MEMBER and ADMIN roles.
 */
export const removeMemberMutation = (options?: Partial<Options<RemoveMemberData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMemberQueryKey = (options: Options<GetMemberData>) => createQueryKey('getMember', options);

/**
 * Get a specific member's details.
 * Get a specific member's details.
 * Accessible to all workspace members.
 */
export const getMemberOptions = (options: Options<GetMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMemberQueryKey(options)
    });
};

export const mentorChatQueryKey = (options: Options<MentorChatData>) => createQueryKey('mentorChat', options);

/**
 * Handle mentor chat (set greeting=true for initial greeting without user message)
 */
export const mentorChatOptions = (options: Options<MentorChatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await mentorChat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: mentorChatQueryKey(options)
    });
};

/**
 * Handle mentor chat (set greeting=true for initial greeting without user message)
 */
export const mentorChatMutation = (options?: Partial<Options<MentorChatData>>): UseMutationOptions<MentorChatResponse, DefaultError, Options<MentorChatData>> => {
    const mutationOptions: UseMutationOptions<MentorChatResponse, DefaultError, Options<MentorChatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await mentorChat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDocumentsQueryKey = (options: Options<ListDocumentsData>) => createQueryKey('listDocuments', options);

/**
 * List documents owned by the authenticated user
 */
export const listDocumentsOptions = (options: Options<ListDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDocumentsQueryKey(options)
    });
};

export const listDocumentsInfiniteQueryKey = (options: Options<ListDocumentsData>): QueryKey<Options<ListDocumentsData>> => createQueryKey('listDocuments', options, true);

/**
 * List documents owned by the authenticated user
 */
export const listDocumentsInfiniteOptions = (options: Options<ListDocumentsData>) => {
    return infiniteQueryOptions<ListDocumentsResponse, ListDocumentsError, InfiniteData<ListDocumentsResponse>, QueryKey<Options<ListDocumentsData>>, number | null | Pick<QueryKey<Options<ListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDocumentsInfiniteQueryKey(options)
    });
};

export const createDocumentQueryKey = (options: Options<CreateDocumentData>) => createQueryKey('createDocument', options);

/**
 * Create a new document
 */
export const createDocumentOptions = (options: Options<CreateDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDocumentQueryKey(options)
    });
};

/**
 * Create a new document
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all versions
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DeleteDocumentError, Options<DeleteDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get latest version of a document
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentQueryKey(options)
    });
};

/**
 * Update a document (creates new version)
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete versions after timestamp
 */
export const deleteDocumentVersionsAfterMutation = (options?: Partial<Options<DeleteDocumentVersionsAfterData>>): UseMutationOptions<DeleteDocumentVersionsAfterResponse, DeleteDocumentVersionsAfterError, Options<DeleteDocumentVersionsAfterData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentVersionsAfterResponse, DeleteDocumentVersionsAfterError, Options<DeleteDocumentVersionsAfterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDocumentVersionsAfter({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listVersionsQueryKey = (options: Options<ListVersionsData>) => createQueryKey('listVersions', options);

/**
 * List versions of a document
 */
export const listVersionsOptions = (options: Options<ListVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listVersionsQueryKey(options)
    });
};

export const listVersionsInfiniteQueryKey = (options: Options<ListVersionsData>): QueryKey<Options<ListVersionsData>> => createQueryKey('listVersions', options, true);

/**
 * List versions of a document
 */
export const listVersionsInfiniteOptions = (options: Options<ListVersionsData>) => {
    return infiniteQueryOptions<ListVersionsResponse, ListVersionsError, InfiniteData<ListVersionsResponse>, QueryKey<Options<ListVersionsData>>, number | null | Pick<QueryKey<Options<ListVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listVersionsInfiniteQueryKey(options)
    });
};

export const getVersionQueryKey = (options: Options<GetVersionData>) => createQueryKey('getVersion', options);

/**
 * Get specific version
 */
export const getVersionOptions = (options: Options<GetVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVersionQueryKey(options)
    });
};

/**
 * Vote on a chat message (upvote/downvote) - idempotent upsert
 */
export const voteMessageMutation = (options?: Partial<Options<VoteMessageData>>): UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> => {
    const mutationOptions: UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await voteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getGroupedThreadsQueryKey = (options: Options<GetGroupedThreadsData>) => createQueryKey('getGroupedThreads', options);

/**
 * List chat threads grouped by time buckets
 */
export const getGroupedThreadsOptions = (options: Options<GetGroupedThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupedThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupedThreadsQueryKey(options)
    });
};

export const getThreadQueryKey = (options: Options<GetThreadData>) => createQueryKey('getThread', options);

/**
 * Get mentor chat thread detail
 */
export const getThreadOptions = (options: Options<GetThreadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThread({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadQueryKey(options)
    });
};

/**
 * Update leaderboard notification preferences
 */
export const updateNotificationsMutation = (options?: Partial<Options<UpdateNotificationsData>>): UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> => {
    const mutationOptions: UseMutationOptions<UpdateNotificationsResponse, DefaultError, Options<UpdateNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticeQueryKey = (options: Options<GetBadPracticeData>) => createQueryKey('getBadPractice', options);

/**
 * Get a specific bad practice
 * Retrieves details of a specific bad practice by ID
 */
export const getBadPracticeOptions = (options: Options<GetBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBadPracticeQueryKey(options)
    });
};

export const provideFeedbackQueryKey = (options: Options<ProvideFeedbackData>) => createQueryKey('provideFeedback', options);

/**
 * Provide feedback for a bad practice
 * Submits user feedback for a detected bad practice
 */
export const provideFeedbackOptions = (options: Options<ProvideFeedbackData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await provideFeedback({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: provideFeedbackQueryKey(options)
    });
};

/**
 * Provide feedback for a bad practice
 * Submits user feedback for a detected bad practice
 */
export const provideFeedbackMutation = (options?: Partial<Options<ProvideFeedbackData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await provideFeedback({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveQueryKey = (options: Options<ResolveData>) => createQueryKey('resolve', options);

/**
 * Resolve a bad practice
 * Updates the state of a bad practice to FIXED, WONT_FIX, or WRONG
 */
export const resolveOptions = (options: Options<ResolveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolve({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveQueryKey(options)
    });
};

/**
 * Resolve a bad practice
 * Updates the state of a bad practice to FIXED, WONT_FIX, or WRONG
 */
export const resolveMutation = (options?: Partial<Options<ResolveData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resolve({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticesForPullRequestQueryKey = (options: Options<GetBadPracticesForPullRequestData>) => createQueryKey('getBadPracticesForPullRequest', options);

/**
 * Get bad practices for a pull request
 * Retrieves all detected bad practices for a specific pull request
 */
export const getBadPracticesForPullRequestOptions = (options: Options<GetBadPracticesForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBadPracticesForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBadPracticesForPullRequestQueryKey(options)
    });
};

export const detectForPullRequestQueryKey = (options: Options<DetectForPullRequestData>) => createQueryKey('detectForPullRequest', options);

/**
 * Detect bad practices for a pull request
 * Triggers bad practice detection for a specific pull request
 */
export const detectForPullRequestOptions = (options: Options<DetectForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectForPullRequestQueryKey(options)
    });
};

/**
 * Detect bad practices for a pull request
 * Triggers bad practice detection for a specific pull request
 */
export const detectForPullRequestMutation = (options?: Partial<Options<DetectForPullRequestData>>): UseMutationOptions<DetectForPullRequestResponse, DetectForPullRequestError, Options<DetectForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<DetectForPullRequestResponse, DetectForPullRequestError, Options<DetectForPullRequestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectForPullRequest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBadPracticesForUserQueryKey = (options: Options<GetBadPracticesForUserData>) => createQueryKey('getBadPracticesForUser', options);

/**
 * Get bad practices for a user
 * Retrieves all detected bad practices for pull requests assigned to the user
 */
export const getBadPracticesForUserOptions = (options: Options<GetBadPracticesForUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBadPracticesForUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBadPracticesForUserQueryKey(options)
    });
};

export const detectForUserQueryKey = (options: Options<DetectForUserData>) => createQueryKey('detectForUser', options);

/**
 * Detect bad practices for a user
 * Triggers bad practice detection for all pull requests of the specified user
 */
export const detectForUserOptions = (options: Options<DetectForUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectForUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectForUserQueryKey(options)
    });
};

/**
 * Detect bad practices for a user
 * Triggers bad practice detection for all pull requests of the specified user
 */
export const detectForUserMutation = (options?: Partial<Options<DetectForUserData>>): UseMutationOptions<DetectForUserResponse, DetectForUserError, Options<DetectForUserData>> => {
    const mutationOptions: UseMutationOptions<DetectForUserResponse, DetectForUserError, Options<DetectForUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectForUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

/**
 * Get user profile
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileOptions = (options: Options<GetUserProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileQueryKey(options)
    });
};

export const getUserProfileInfiniteQueryKey = (options: Options<GetUserProfileData>): QueryKey<Options<GetUserProfileData>> => createQueryKey('getUserProfile', options, true);

/**
 * Get user profile
 * Returns user profile with workspace-scoped activity data including open PRs, review activity, and league points
 */
export const getUserProfileInfiniteOptions = (options: Options<GetUserProfileData>) => {
    return infiniteQueryOptions<GetUserProfileResponse, DefaultError, InfiniteData<GetUserProfileResponse>, QueryKey<Options<GetUserProfileData>>, Date | Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetUserProfileData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getUserProfile({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileInfiniteQueryKey(options)
    });
};

/**
 * Toggle public visibility for a workspace
 */
export const updatePublicVisibilityMutation = (options?: Partial<Options<UpdatePublicVisibilityData>>): UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> => {
    const mutationOptions: UseMutationOptions<UpdatePublicVisibilityResponse, DefaultError, Options<UpdatePublicVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePublicVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

/**
 * List repositories monitored by a workspace
 */
export const getRepositoriesToMonitorOptions = (options: Options<GetRepositoriesToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoriesToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesToMonitorQueryKey(options)
    });
};

/**
 * Remove a repository from a workspace monitor list
 */
export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToMonitorQueryKey = (options: Options<AddRepositoryToMonitorData>) => createQueryKey('addRepositoryToMonitor', options);

/**
 * Add a repository to a workspace monitor list
 */
export const addRepositoryToMonitorOptions = (options: Options<AddRepositoryToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToMonitorQueryKey(options)
    });
};

/**
 * Add a repository to a workspace monitor list
 */
export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update leaderboard schedule configuration
 */
export const updateScheduleMutation = (options?: Partial<Options<UpdateScheduleData>>): UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> => {
    const mutationOptions: UseMutationOptions<UpdateScheduleResponse, DefaultError, Options<UpdateScheduleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSchedule({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Slack credentials for a workspace
 */
export const updateSlackCredentialsMutation = (options?: Partial<Options<UpdateSlackCredentialsData>>): UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> => {
    const mutationOptions: UseMutationOptions<UpdateSlackCredentialsResponse, DefaultError, Options<UpdateSlackCredentialsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSlackCredentials({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rename workspace slug and create redirect
 */
export const renameSlugMutation = (options?: Partial<Options<RenameSlugData>>): UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> => {
    const mutationOptions: UseMutationOptions<RenameSlugResponse, DefaultError, Options<RenameSlugData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await renameSlug({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace lifecycle status
 */
export const updateStatusMutation = (options?: Partial<Options<UpdateStatusData>>): UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateStatusResponse, DefaultError, Options<UpdateStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTeamsQueryKey = (options: Options<GetAllTeamsData>) => createQueryKey('getAllTeams', options);

/**
 * List teams
 * Returns all teams in the workspace organization
 */
export const getAllTeamsOptions = (options: Options<GetAllTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTeamsQueryKey(options)
    });
};

export const updateTeamVisibilityQueryKey = (options: Options<UpdateTeamVisibilityData>) => createQueryKey('updateTeamVisibility', options);

/**
 * Update team visibility
 * Show or hide a team in leaderboard calculations
 */
export const updateTeamVisibilityOptions = (options: Options<UpdateTeamVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateTeamVisibilityQueryKey(options)
    });
};

/**
 * Update team visibility
 * Show or hide a team in leaderboard calculations
 */
export const updateTeamVisibilityMutation = (options?: Partial<Options<UpdateTeamVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateTeamVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeamVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateRepositoryVisibilityQueryKey = (options: Options<UpdateRepositoryVisibilityData>) => createQueryKey('updateRepositoryVisibility', options);

export const updateRepositoryVisibilityOptions = (options: Options<UpdateRepositoryVisibilityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateRepositoryVisibilityQueryKey(options)
    });
};

export const updateRepositoryVisibilityMutation = (options?: Partial<Options<UpdateRepositoryVisibilityData>>): UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UpdateRepositoryVisibilityData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRepositoryVisibility({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a repository label from a team
 */
export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelToTeamQueryKey = (options: Options<AddLabelToTeamData>) => createQueryKey('addLabelToTeam', options);

/**
 * Add a repository label to a team
 */
export const addLabelToTeamOptions = (options: Options<AddLabelToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelToTeamQueryKey(options)
    });
};

/**
 * Add a repository label to a team
 */
export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTeamSettingsQueryKey = (options: Options<GetTeamSettingsData>) => createQueryKey('getTeamSettings', options);

/**
 * Get team settings
 * Returns the visibility settings for a team in the workspace
 */
export const getTeamSettingsOptions = (options: Options<GetTeamSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTeamSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTeamSettingsQueryKey(options)
    });
};

/**
 * Update team settings
 * Updates the visibility settings for a team in the workspace
 */
export const updateTeamSettingsMutation = (options?: Partial<Options<UpdateTeamSettingsData>>): UseMutationOptions<UpdateTeamSettingsResponse, UpdateTeamSettingsError, Options<UpdateTeamSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateTeamSettingsResponse, UpdateTeamSettingsError, Options<UpdateTeamSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTeamSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLabelFiltersQueryKey = (options: Options<GetLabelFiltersData>) => createQueryKey('getLabelFilters', options);

/**
 * Get team label filters
 * Returns all labels configured as filters for a team in the workspace
 */
export const getLabelFiltersOptions = (options: Options<GetLabelFiltersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLabelFilters({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLabelFiltersQueryKey(options)
    });
};

/**
 * Remove label filter
 * Removes a label filter from a team in the workspace
 */
export const removeLabelFilterMutation = (options?: Partial<Options<RemoveLabelFilterData>>): UseMutationOptions<RemoveLabelFilterResponse, DefaultError, Options<RemoveLabelFilterData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFilterResponse, DefaultError, Options<RemoveLabelFilterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFilter({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelFilterQueryKey = (options: Options<AddLabelFilterData>) => createQueryKey('addLabelFilter', options);

/**
 * Add label filter
 * Adds a label as a filter for a team in the workspace
 */
export const addLabelFilterOptions = (options: Options<AddLabelFilterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelFilter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelFilterQueryKey(options)
    });
};

/**
 * Add label filter
 * Adds a label as a filter for a team in the workspace
 */
export const addLabelFilterMutation = (options?: Partial<Options<AddLabelFilterData>>): UseMutationOptions<unknown, DefaultError, Options<AddLabelFilterData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddLabelFilterData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelFilter({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositorySettingsQueryKey = (options: Options<GetRepositorySettingsData>) => createQueryKey('getRepositorySettings', options);

/**
 * Get repository settings
 * Returns the contribution visibility settings for a repository in a team
 */
export const getRepositorySettingsOptions = (options: Options<GetRepositorySettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositorySettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositorySettingsQueryKey(options)
    });
};

/**
 * Update repository settings
 * Updates the contribution visibility settings for a repository in a team
 */
export const updateRepositorySettingsMutation = (options?: Partial<Options<UpdateRepositorySettingsData>>): UseMutationOptions<UpdateRepositorySettingsResponse, UpdateRepositorySettingsError, Options<UpdateRepositorySettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateRepositorySettingsResponse, UpdateRepositorySettingsError, Options<UpdateRepositorySettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRepositorySettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update workspace Personal Access Token
 */
export const updateTokenMutation = (options?: Partial<Options<UpdateTokenData>>): UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateTokenResponse, DefaultError, Options<UpdateTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

/**
 * List workspace users and the teams they belong to
 */
export const getUsersWithTeamsOptions = (options: Options<GetUsersWithTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersWithTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersWithTeamsQueryKey(options)
    });
};