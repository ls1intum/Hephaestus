// This file is auto-generated by @hey-api/openapi-ts

export type Activity = {
    pullRequests: Array<PullRequestWithBadPractices>;
};

export type BadPracticeFeedback = {
    explanation: string;
    type: string;
};

/**
 * DTO for returning vote information.
 */
export type ChatMessageVote = {
    createdAt?: Date;
    isUpvoted?: boolean;
    messageId?: string;
    updatedAt?: Date;
};

/**
 * DTO for chat thread with full message content.
 * Used for initializing useChat in the frontend.
 */
export type ChatThreadDetail = {
    /**
     * When the thread was created
     */
    createdAt?: Date;
    /**
     * Unique identifier for the thread
     */
    id?: string;
    /**
     * All messages in the conversation path (as JSON objects for useChat initialization)
     * As exception, we do not use a DTO here since we included those intelligece-service models in the OpenAPI spec.
     */
    messages?: Array<UiMessage>;
    /**
     * ID of the currently selected leaf message (end of active conversation path)
     */
    selectedLeafMessageId?: string;
    /**
     * Thread title (may be null for untitled threads)
     */
    title?: string;
    /**
     * Votes for messages in this thread
     */
    votes?: Array<ChatMessageVote>;
};

/**
 * DTO for grouped chat threads.
 * Used for organizing threads by time periods (today, yesterday, etc.).
 */
export type ChatThreadGroup = {
    /**
     * Group name (e.g., "Today", "Yesterday", "Last 7 Days", "Last 30 Days")
     */
    groupName: string;
    /**
     * List of thread summaries in this group
     */
    threads: Array<ChatThreadSummary>;
};

/**
 * DTO for chat thread summary information.
 * Used for listing threads without loading full message content.
 */
export type ChatThreadSummary = {
    /**
     * When the thread was created
     */
    createdAt: Date;
    /**
     * Unique identifier for the thread
     */
    id: string;
    /**
     * Thread title (may be null for untitled threads)
     */
    title: string;
};

export type Contributor = {
    avatarUrl: string;
    contributions?: number;
    htmlUrl: string;
    id: number;
    login: string;
    name: string;
};

/**
 * CreateDocumentInput
 * Input for createDocument tool.
 */
export type CreateDocumentInput = {
    /**
     * Document Id
     * Do not populate this field, will automatically be set by the system
     */
    document_id: string;
    /**
     * Kind
     */
    kind: 'text';
    /**
     * Title
     */
    title: string;
};

/**
 * CreateDocumentOutput
 * Output for createDocument tool.
 */
export type CreateDocumentOutput = {
    /**
     * Content
     */
    content: string;
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'TEXT';
    /**
     * Title
     */
    title: string;
};

/**
 * DTO for creating a new document.
 * Server generates UUID and timestamps.
 */
export type CreateDocumentRequest = {
    content: string;
    kind: 'TEXT';
    title: string;
};

/**
 * DataUIPart
 * A data part with dynamic type.
 *
 * Note: In UI messages, data can be of any JSON type (object, array, string, number, etc.).
 */
export type DataUiPart = {
    /**
     * Data
     */
    data: unknown;
    /**
     * Id
     */
    id?: string | null;
    /**
     * Type
     */
    type: string;
};

/**
 * DTO for complete document responses.
 * Used when returning full document details (includes content).
 */
export type Document = {
    content: string;
    createdAt: Date;
    id: string;
    kind: 'TEXT';
    title: string;
    userId: string;
    versionNumber: number;
};

/**
 * DocumentCreateData
 */
export type DocumentCreateData = {
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'text';
    /**
     * Title
     */
    title: string;
};

/**
 * DocumentDeltaData
 */
export type DocumentDeltaData = {
    /**
     * Delta
     */
    delta: string;
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'text';
};

/**
 * DocumentFinishData
 */
export type DocumentFinishData = {
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'text';
};

/**
 * DTO for document summary in list views.
 * Excludes content for performance - only metadata.
 */
export type DocumentSummary = {
    createdAt: Date;
    id: string;
    kind: 'TEXT';
    title: string;
    userId: string;
};

/**
 * DocumentUpdateData
 */
export type DocumentUpdateData = {
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'text';
};

/**
 * FileUIPart
 * A file part of a message.
 */
export type FileUiPart = {
    /**
     * Filename
     */
    filename?: string | null;
    /**
     * Mediatype
     */
    mediaType: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'file';
    /**
     * Url
     */
    url: string;
};

/**
 * GetWeatherInput
 * Input for getWeather tool.
 */
export type GetWeatherInput = {
    /**
     * Latitude
     */
    latitude: number;
    /**
     * Longitude
     */
    longitude: number;
};

/**
 * GetWeatherOutput
 * Output for getWeather tool, aligned with WeatherTool.tsx expectations.
 */
export type GetWeatherOutput = {
    current?: WeatherCurrent | null;
    current_units?: WeatherCurrentUnits | null;
    daily?: WeatherDaily | null;
    daily_units?: WeatherDailyUnits | null;
    /**
     * Elevation
     */
    elevation?: number | null;
    /**
     * Generationtime Ms
     */
    generationtime_ms?: number | null;
    hourly?: WeatherHourly | null;
    hourly_units?: WeatherHourlyUnits | null;
    /**
     * Latitude
     */
    latitude?: number | null;
    /**
     * Longitude
     */
    longitude?: number | null;
    /**
     * Timezone
     */
    timezone?: string | null;
    /**
     * Timezone Abbreviation
     */
    timezone_abbreviation?: string | null;
    /**
     * Utc Offset Seconds
     */
    utc_offset_seconds?: number | null;
};

export type LabelInfo = {
    color: string;
    id: number;
    name: string;
    repository?: RepositoryInfo;
};

export type LeaderboardEntry = {
    numberOfApprovals: number;
    numberOfChangeRequests: number;
    numberOfCodeComments: number;
    numberOfComments: number;
    numberOfReviewedPRs: number;
    numberOfUnknowns: number;
    rank: number;
    reviewedPullRequests: Array<PullRequestInfo>;
    score: number;
    team?: TeamInfo;
    user?: UserInfo;
};

export type LeagueChange = {
    leaguePointsChange: number;
    login: string;
};

export type MetaData = {
    scheduledDay: string;
    scheduledTime: string;
    teams: Array<TeamInfo>;
};

export type PageDocument = {
    content?: Array<Document>;
    empty?: boolean;
    first?: boolean;
    last?: boolean;
    number?: number;
    numberOfElements?: number;
    pageable?: PageableObject;
    size?: number;
    sort?: SortObject;
    totalElements?: number;
    totalPages?: number;
};

export type PageDocumentSummary = {
    content?: Array<DocumentSummary>;
    empty?: boolean;
    first?: boolean;
    last?: boolean;
    number?: number;
    numberOfElements?: number;
    pageable?: PageableObject;
    size?: number;
    sort?: SortObject;
    totalElements?: number;
    totalPages?: number;
};

export type PageableObject = {
    offset?: number;
    pageNumber?: number;
    pageSize?: number;
    paged?: boolean;
    sort?: SortObject;
    unpaged?: boolean;
};

export type PullRequestBadPractice = {
    description: string;
    id: number;
    state: 'GOOD_PRACTICE' | 'FIXED' | 'CRITICAL_ISSUE' | 'NORMAL_ISSUE' | 'MINOR_ISSUE' | 'WONT_FIX' | 'WRONG';
    title: string;
};

export type PullRequestBaseInfo = {
    htmlUrl: string;
    id: number;
    isDraft: boolean;
    isMerged: boolean;
    number: number;
    repository?: RepositoryInfo;
    state: 'OPEN' | 'CLOSED';
    title: string;
};

export type PullRequestInfo = {
    additions: number;
    assignees?: Array<UserInfo>;
    author?: UserInfo;
    closedAt?: Date;
    commentsCount: number;
    createdAt?: Date;
    deletions: number;
    htmlUrl: string;
    id: number;
    isDraft: boolean;
    isMerged: boolean;
    labels?: Array<LabelInfo>;
    mergedAt?: Date;
    number: number;
    repository?: RepositoryInfo;
    state: 'OPEN' | 'CLOSED';
    title: string;
    updatedAt?: Date;
};

export type PullRequestReviewInfo = {
    author?: UserInfo;
    codeComments: number;
    htmlUrl: string;
    id: number;
    isDismissed: boolean;
    pullRequest?: PullRequestBaseInfo;
    score: number;
    state: 'COMMENTED' | 'APPROVED' | 'CHANGES_REQUESTED' | 'UNKNOWN';
    submittedAt?: Date;
};

export type PullRequestWithBadPractices = {
    additions: number;
    badPracticeSummary: string;
    badPractices: Array<PullRequestBadPractice>;
    createdAt: Date;
    deletions: number;
    htmlUrl: string;
    id: number;
    isDraft: boolean;
    isMerged: boolean;
    labels: Array<LabelInfo>;
    number: number;
    oldBadPractices: Array<PullRequestBadPractice>;
    repository: RepositoryInfo;
    state: 'OPEN' | 'CLOSED';
    title: string;
    updatedAt: Date;
};

/**
 * ReasoningUIPart
 * A reasoning part of a message.
 */
export type ReasoningUiPart = {
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * State
     */
    state?: ('streaming' | 'done') | null;
    /**
     * Text
     */
    text: string;
    /**
     * Type
     */
    type?: 'reasoning';
};

export type RepositoryInfo = {
    description?: string;
    htmlUrl: string;
    id: number;
    labels?: Array<LabelInfo>;
    name: string;
    nameWithOwner: string;
};

export type SortObject = {
    empty?: boolean;
    sorted?: boolean;
    unsorted?: boolean;
};

/**
 * SourceDocumentUIPart
 * A document source part of a message.
 */
export type SourceDocumentUiPart = {
    /**
     * Filename
     */
    filename?: string | null;
    /**
     * Mediatype
     */
    mediaType: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Sourceid
     */
    sourceId: string;
    /**
     * Title
     */
    title: string;
    /**
     * Type
     */
    type?: 'source-document';
};

/**
 * SourceUrlUIPart
 * A URL source part of a message.
 */
export type SourceUrlUiPart = {
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Sourceid
     */
    sourceId: string;
    /**
     * Title
     */
    title?: string | null;
    /**
     * Type
     */
    type?: 'source-url';
    /**
     * Url
     */
    url: string;
};

/**
 * StepStartUIPart
 * A step boundary part of a message.
 */
export type StepStartUiPart = {
    /**
     * Type
     */
    type?: 'step-start';
};

/**
 * StreamDataPart
 * Data part with dynamic type.
 *
 * AI SDK v5 stream chunks support a `transient` flag that indicates the data
 * should not be added to the persisted message state.
 */
export type StreamDataPart = {
    /**
     * Data
     */
    data: unknown;
    /**
     * Id
     */
    id?: string | null;
    /**
     * Transient
     */
    transient?: boolean | null;
    /**
     * Type
     */
    type: string;
};

/**
 * StreamErrorPart
 * Error stream part.
 */
export type StreamErrorPart = {
    /**
     * Errortext
     */
    errorText: string;
    /**
     * Type
     */
    type?: 'error';
};

/**
 * StreamFilePart
 * File part of a message.
 */
export type StreamFilePart = {
    /**
     * Mediatype
     */
    mediaType: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'file';
    /**
     * Url
     */
    url: string;
};

/**
 * StreamFinishPart
 * End of stream event.
 */
export type StreamFinishPart = {
    /**
     * Messagemetadata
     */
    messageMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'finish';
};

/**
 * StreamMessageMetadataPart
 * Message metadata part.
 */
export type StreamMessageMetadataPart = {
    /**
     * Messagemetadata
     */
    messageMetadata: {
        [key: string]: unknown;
    };
    /**
     * Type
     */
    type?: 'message-metadata';
};

/**
 * StreamReasoningDeltaPart
 * Reasoning stream delta part.
 */
export type StreamReasoningDeltaPart = {
    /**
     * Delta
     */
    delta: string;
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'reasoning-delta';
};

/**
 * StreamReasoningEndPart
 * Reasoning stream end part.
 */
export type StreamReasoningEndPart = {
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'reasoning-end';
};

/**
 * StreamReasoningStartPart
 * Reasoning stream start part.
 */
export type StreamReasoningStartPart = {
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'reasoning-start';
};

/**
 * StreamSourceDocumentPart
 * Source document part of a message.
 */
export type StreamSourceDocumentPart = {
    /**
     * Filename
     */
    filename?: string | null;
    /**
     * Mediatype
     */
    mediaType: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Sourceid
     */
    sourceId: string;
    /**
     * Title
     */
    title: string;
    /**
     * Type
     */
    type?: 'source-document';
};

/**
 * StreamSourceUrlPart
 * Source URL part of a message.
 */
export type StreamSourceUrlPart = {
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Sourceid
     */
    sourceId: string;
    /**
     * Title
     */
    title?: string | null;
    /**
     * Type
     */
    type?: 'source-url';
    /**
     * Url
     */
    url: string;
};

/**
 * StreamStartPart
 * Start of stream event.
 */
export type StreamStartPart = {
    /**
     * Messageid
     */
    messageId?: string | null;
    /**
     * Messagemetadata
     */
    messageMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'start';
};

/**
 * StreamStepFinishPart
 * Step finish event.
 */
export type StreamStepFinishPart = {
    /**
     * Type
     */
    type?: 'finish-step';
};

/**
 * StreamStepStartPart
 * Step start event.
 */
export type StreamStepStartPart = {
    /**
     * Type
     */
    type?: 'start-step';
};

/**
 * StreamTextDeltaPart
 * Text stream delta part.
 */
export type StreamTextDeltaPart = {
    /**
     * Delta
     */
    delta: string;
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'text-delta';
};

/**
 * StreamTextEndPart
 * Text stream end part.
 */
export type StreamTextEndPart = {
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'text-end';
};

/**
 * StreamTextStartPart
 * Text stream start part.
 */
export type StreamTextStartPart = {
    /**
     * Id
     */
    id: string;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Type
     */
    type?: 'text-start';
};

/**
 * StreamToolInputAvailablePart
 * Tool input available event.
 *
 * AI SDK v5 uses `providerMetadata` on the stream chunk; the UI part maps this
 * to `callProviderMetadata` when persisting tool invocation parts.
 */
export type StreamToolInputAvailablePart = {
    /**
     * Dynamic
     */
    dynamic?: boolean | null;
    /**
     * Input
     */
    input: {
        [key: string]: unknown;
    };
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Toolname
     */
    toolName: string;
    /**
     * Type
     */
    type?: 'tool-input-available';
};

/**
 * StreamToolInputDeltaPart
 * Tool input delta event.
 */
export type StreamToolInputDeltaPart = {
    /**
     * Inputtextdelta
     */
    inputTextDelta: string;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type?: 'tool-input-delta';
};

/**
 * StreamToolInputErrorPart
 * Tool input error event (signals an error occurred while preparing input).
 *
 * Mirrors AI SDK 'tool-input-error' chunk. For non-dynamic tools, the server should
 * record an 'output-error' tool UI part where rawInput may be used for diagnostics.
 */
export type StreamToolInputErrorPart = {
    /**
     * Dynamic
     */
    dynamic?: boolean | null;
    /**
     * Errortext
     */
    errorText: string;
    /**
     * Input
     */
    input: unknown;
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Toolname
     */
    toolName: string;
    /**
     * Type
     */
    type?: 'tool-input-error';
};

/**
 * StreamToolInputStartPart
 * Tool input start event.
 */
export type StreamToolInputStartPart = {
    /**
     * Dynamic
     */
    dynamic?: boolean | null;
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Toolname
     */
    toolName: string;
    /**
     * Type
     */
    type?: 'tool-input-start';
};

/**
 * StreamToolOutputAvailablePart
 * Tool output available event.
 */
export type StreamToolOutputAvailablePart = {
    /**
     * Dynamic
     */
    dynamic?: boolean | null;
    /**
     * Output
     */
    output: {
        [key: string]: unknown;
    };
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type?: 'tool-output-available';
};

/**
 * StreamToolOutputErrorPart
 * Tool output error event.
 */
export type StreamToolOutputErrorPart = {
    /**
     * Dynamic
     */
    dynamic?: boolean | null;
    /**
     * Errortext
     */
    errorText: string;
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type?: 'tool-output-error';
};

export type TeamInfo = {
    description?: string;
    hidden: boolean;
    htmlUrl?: string;
    id: number;
    labels: Array<LabelInfo>;
    members: Array<UserInfo>;
    membershipCount: number;
    name: string;
    organization?: string;
    parentId?: number;
    privacy?: 'SECRET' | 'CLOSED';
    repoPermissionCount: number;
    repositories: Array<RepositoryInfo>;
};

/**
 * TextUIPart
 * A text part of a message.
 */
export type TextUiPart = {
    /**
     * Providermetadata
     */
    providerMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * State
     */
    state?: ('streaming' | 'done') | null;
    /**
     * Text
     */
    text: string;
    /**
     * Type
     */
    type?: 'text';
};

/**
 * ToolInputAvailablePart
 * Tool part with input available.
 */
export type ToolInputAvailablePart = {
    /**
     * Callprovidermetadata
     */
    callProviderMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Input
     */
    input: {
        [key: string]: unknown;
    };
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * State
     */
    state: 'input-available';
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type: string;
};

/**
 * ToolInputStreamingPart
 * Tool part with input being streamed.
 */
export type ToolInputStreamingPart = {
    /**
     * Input
     */
    input?: {
        [key: string]: unknown;
    } | null;
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * State
     */
    state: 'input-streaming';
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type: string;
};

/**
 * ToolOutputAvailablePart
 * Tool part with output available.
 */
export type ToolOutputAvailablePart = {
    /**
     * Callprovidermetadata
     */
    callProviderMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Input
     */
    input: {
        [key: string]: unknown;
    };
    /**
     * Output
     */
    output: {
        [key: string]: unknown;
    };
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * State
     */
    state: 'output-available';
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type: string;
};

/**
 * ToolOutputErrorPart
 * Tool part with output error.
 */
export type ToolOutputErrorPart = {
    /**
     * Callprovidermetadata
     */
    callProviderMetadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Errortext
     */
    errorText: string;
    /**
     * Input
     */
    input: {
        [key: string]: unknown;
    };
    /**
     * Providerexecuted
     */
    providerExecuted?: boolean | null;
    /**
     * State
     */
    state: 'output-error';
    /**
     * Toolcallid
     */
    toolCallId: string;
    /**
     * Type
     */
    type: string;
};

/**
 * UIMessage
 * Message model that matches the TypeScript interface.
 */
export type UiMessage = {
    /**
     * Id
     * A unique identifier for the message
     */
    id: string;
    /**
     * Metadata
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Parts
     */
    parts: Array<TextUiPart | ReasoningUiPart | ToolInputStreamingPart | ToolInputAvailablePart | ToolOutputAvailablePart | ToolOutputErrorPart | SourceUrlUiPart | SourceDocumentUiPart | FileUiPart | DataUiPart | StepStartUiPart>;
    /**
     * Role
     */
    role: 'system' | 'user' | 'assistant';
};

/**
 * UpdateDocumentInput
 * Input for updateDocument tool.
 */
export type UpdateDocumentInput = {
    /**
     * Description
     * The description of changes that need to be made
     */
    description: string;
    /**
     * Id
     * The ID of the document to update
     */
    id: string;
};

/**
 * UpdateDocumentOutput
 * Output for updateDocument tool.
 */
export type UpdateDocumentOutput = {
    /**
     * Content
     */
    content: string;
    /**
     * Id
     */
    id: string;
    /**
     * Kind
     */
    kind: 'TEXT';
    /**
     * Title
     */
    title: string;
};

/**
 * DTO for updating an existing document.
 * Creates a new version with the updated content.
 */
export type UpdateDocumentRequest = {
    content: string;
    kind: 'TEXT';
    title: string;
};

export type UserInfo = {
    avatarUrl: string;
    email?: string;
    htmlUrl: string;
    id: number;
    leaguePoints?: number;
    login: string;
    name: string;
};

export type UserProfile = {
    contributedRepositories: Array<RepositoryInfo>;
    firstContribution: Date;
    openPullRequests?: Array<PullRequestInfo>;
    reviewActivity?: Array<PullRequestReviewInfo>;
    userInfo: UserInfo;
};

export type UserSettings = {
    receiveNotifications?: boolean;
};

export type UserTeams = {
    email?: string;
    id: number;
    login: string;
    name: string;
    teams: Array<TeamInfo>;
    url: string;
};

/**
 * Request DTO for voting on a message.
 */
export type VoteMessageRequest = {
    isUpvoted: boolean;
};

/**
 * WeatherCurrent
 */
export type WeatherCurrent = {
    /**
     * Interval
     */
    interval?: number | null;
    /**
     * Temperature 2M
     */
    temperature_2m?: number | null;
    /**
     * Time
     */
    time?: string | null;
};

/**
 * WeatherCurrentUnits
 */
export type WeatherCurrentUnits = {
    /**
     * Interval
     */
    interval?: string | null;
    /**
     * Temperature 2M
     */
    temperature_2m?: string | null;
    /**
     * Time
     */
    time?: string | null;
};

/**
 * WeatherDaily
 */
export type WeatherDaily = {
    /**
     * Sunrise
     */
    sunrise?: Array<string>;
    /**
     * Sunset
     */
    sunset?: Array<string>;
    /**
     * Time
     */
    time?: Array<string>;
};

/**
 * WeatherDailyUnits
 */
export type WeatherDailyUnits = {
    /**
     * Sunrise
     */
    sunrise?: string | null;
    /**
     * Sunset
     */
    sunset?: string | null;
    /**
     * Time
     */
    time?: string | null;
};

/**
 * WeatherHourly
 */
export type WeatherHourly = {
    /**
     * Temperature 2M
     */
    temperature_2m?: Array<number>;
    /**
     * Time
     */
    time?: Array<string>;
};

/**
 * WeatherHourlyUnits
 */
export type WeatherHourlyUnits = {
    /**
     * Temperature 2M
     */
    temperature_2m?: string | null;
    /**
     * Time
     */
    time?: string | null;
};

export type ProvideFeedbackForBadPracticeData = {
    body: BadPracticeFeedback;
    path: {
        badPracticeId: number;
    };
    query?: never;
    url: '/activity/badpractice/{badPracticeId}/feedback';
};

export type ProvideFeedbackForBadPracticeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type ResolveBadPracticeData = {
    body?: never;
    path: {
        badPracticeId: number;
    };
    query: {
        state: 'GOOD_PRACTICE' | 'FIXED' | 'CRITICAL_ISSUE' | 'NORMAL_ISSUE' | 'MINOR_ISSUE' | 'WONT_FIX' | 'WRONG';
    };
    url: '/activity/badpractice/{badPracticeId}/resolve';
};

export type ResolveBadPracticeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DetectBadPracticesForPullRequestData = {
    body?: never;
    path: {
        pullRequestId: number;
    };
    query?: never;
    url: '/activity/pullrequest/{pullRequestId}/badpractices';
};

export type DetectBadPracticesForPullRequestResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DetectBadPracticesByUserData = {
    body?: never;
    path: {
        login: string;
    };
    query?: never;
    url: '/activity/user/{login}/badpractices';
};

export type DetectBadPracticesByUserResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetActivityByUserData = {
    body?: never;
    path: {
        login: string;
    };
    query?: never;
    url: '/activity/{login}';
};

export type GetActivityByUserResponses = {
    /**
     * OK
     */
    200: Activity;
};

export type GetActivityByUserResponse = GetActivityByUserResponses[keyof GetActivityByUserResponses];

export type VoteMessageData = {
    body: VoteMessageRequest;
    path: {
        /**
         * Message ID to vote on
         */
        messageId: string;
    };
    query?: never;
    url: '/api/chat/messages/{messageId}/vote';
};

export type VoteMessageErrors = {
    /**
     * Invalid vote type or message not found
     */
    400: ChatMessageVote;
    /**
     * Message not found
     */
    404: ChatMessageVote;
};

export type VoteMessageError = VoteMessageErrors[keyof VoteMessageErrors];

export type VoteMessageResponses = {
    /**
     * Vote successfully recorded
     */
    200: ChatMessageVote;
};

export type VoteMessageResponse = VoteMessageResponses[keyof VoteMessageResponses];

export type GetUserDocumentsData = {
    body?: never;
    path?: never;
    query?: {
        page?: number;
        size?: number;
        sortBy?: string;
        sortDir?: string;
    };
    url: '/api/documents';
};

export type GetUserDocumentsResponses = {
    /**
     * Documents retrieved successfully
     */
    200: PageDocumentSummary;
};

export type GetUserDocumentsResponse = GetUserDocumentsResponses[keyof GetUserDocumentsResponses];

export type CreateDocumentData = {
    body: CreateDocumentRequest;
    path?: never;
    query?: never;
    url: '/api/documents';
};

export type CreateDocumentErrors = {
    /**
     * Invalid request data
     */
    400: Document;
};

export type CreateDocumentError = CreateDocumentErrors[keyof CreateDocumentErrors];

export type CreateDocumentResponses = {
    /**
     * Document created successfully
     */
    201: Document;
};

export type CreateDocumentResponse = CreateDocumentResponses[keyof CreateDocumentResponses];

export type DeleteDocumentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/documents/{id}';
};

export type DeleteDocumentErrors = {
    /**
     * Document not found
     */
    404: unknown;
};

export type DeleteDocumentResponses = {
    /**
     * Document deleted successfully
     */
    204: void;
};

export type DeleteDocumentResponse = DeleteDocumentResponses[keyof DeleteDocumentResponses];

export type GetDocumentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/documents/{id}';
};

export type GetDocumentErrors = {
    /**
     * Document not found
     */
    404: Document;
};

export type GetDocumentError = GetDocumentErrors[keyof GetDocumentErrors];

export type GetDocumentResponses = {
    /**
     * Document retrieved successfully
     */
    200: Document;
};

export type GetDocumentResponse = GetDocumentResponses[keyof GetDocumentResponses];

export type UpdateDocumentData = {
    body: UpdateDocumentRequest;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/documents/{id}';
};

export type UpdateDocumentErrors = {
    /**
     * Invalid request data
     */
    400: Document;
    /**
     * Document not found
     */
    404: Document;
};

export type UpdateDocumentError = UpdateDocumentErrors[keyof UpdateDocumentErrors];

export type UpdateDocumentResponses = {
    /**
     * Document updated successfully
     */
    200: Document;
};

export type UpdateDocumentResponse = UpdateDocumentResponses[keyof UpdateDocumentResponses];

export type DeleteVersionsAfterTimestampData = {
    body?: never;
    path: {
        id: string;
    };
    query: {
        after: Date;
    };
    url: '/api/documents/{id}/versions';
};

export type DeleteVersionsAfterTimestampErrors = {
    /**
     * Invalid timestamp parameter
     */
    400: Array<Document>;
    /**
     * Document not found
     */
    404: Array<Document>;
};

export type DeleteVersionsAfterTimestampError = DeleteVersionsAfterTimestampErrors[keyof DeleteVersionsAfterTimestampErrors];

export type DeleteVersionsAfterTimestampResponses = {
    /**
     * Document versions deleted successfully
     */
    200: Array<Document>;
};

export type DeleteVersionsAfterTimestampResponse = DeleteVersionsAfterTimestampResponses[keyof DeleteVersionsAfterTimestampResponses];

export type GetDocumentVersionsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: {
        page?: number;
        size?: number;
    };
    url: '/api/documents/{id}/versions';
};

export type GetDocumentVersionsErrors = {
    /**
     * Document not found
     */
    404: PageDocument;
};

export type GetDocumentVersionsError = GetDocumentVersionsErrors[keyof GetDocumentVersionsErrors];

export type GetDocumentVersionsResponses = {
    /**
     * Document versions retrieved successfully
     */
    200: PageDocument;
};

export type GetDocumentVersionsResponse = GetDocumentVersionsResponses[keyof GetDocumentVersionsResponses];

export type GetDocumentVersionData = {
    body?: never;
    path: {
        id: string;
        versionNumber: number;
    };
    query?: never;
    url: '/api/documents/{id}/versions/{versionNumber}';
};

export type GetDocumentVersionErrors = {
    /**
     * Document version not found
     */
    404: Document;
};

export type GetDocumentVersionError = GetDocumentVersionErrors[keyof GetDocumentVersionErrors];

export type GetDocumentVersionResponses = {
    /**
     * Document version retrieved successfully
     */
    200: Document;
};

export type GetDocumentVersionResponse = GetDocumentVersionResponses[keyof GetDocumentVersionResponses];

export type GetLeaderboardData = {
    body?: never;
    path?: never;
    query: {
        after: Date;
        before: Date;
        team?: string;
        sort?: 'SCORE' | 'LEAGUE_POINTS';
        mode?: 'INDIVIDUAL' | 'TEAM';
    };
    url: '/leaderboard';
};

export type GetLeaderboardResponses = {
    /**
     * OK
     */
    200: Array<LeaderboardEntry>;
};

export type GetLeaderboardResponse = GetLeaderboardResponses[keyof GetLeaderboardResponses];

export type GetUserLeagueStatsData = {
    body: LeaderboardEntry;
    path?: never;
    query: {
        login: string;
    };
    url: '/leaderboard';
};

export type GetUserLeagueStatsResponses = {
    /**
     * OK
     */
    200: LeagueChange;
};

export type GetUserLeagueStatsResponse = GetUserLeagueStatsResponses[keyof GetUserLeagueStatsResponses];

export type GetThreadData = {
    body?: never;
    path: {
        /**
         * Thread ID
         */
        threadId: string;
    };
    query?: never;
    url: '/mentor/thread/{threadId}';
};

export type GetThreadErrors = {
    /**
     * User not authenticated
     */
    401: ChatThreadDetail;
    /**
     * Thread not found or not owned by user
     */
    404: ChatThreadDetail;
};

export type GetThreadError = GetThreadErrors[keyof GetThreadErrors];

export type GetThreadResponses = {
    /**
     * Successfully retrieved thread
     */
    200: ChatThreadDetail;
};

export type GetThreadResponse = GetThreadResponses[keyof GetThreadResponses];

export type GetThreadsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mentor/threads';
};

export type GetThreadsErrors = {
    /**
     * User not authenticated
     */
    401: Array<ChatThreadSummary>;
};

export type GetThreadsError = GetThreadsErrors[keyof GetThreadsErrors];

export type GetThreadsResponses = {
    /**
     * Successfully retrieved threads
     */
    200: Array<ChatThreadSummary>;
};

export type GetThreadsResponse = GetThreadsResponses[keyof GetThreadsResponses];

export type GetGroupedThreadsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/mentor/threads/grouped';
};

export type GetGroupedThreadsErrors = {
    /**
     * User not authenticated
     */
    401: Array<ChatThreadGroup>;
};

export type GetGroupedThreadsError = GetGroupedThreadsErrors[keyof GetGroupedThreadsErrors];

export type GetGroupedThreadsResponses = {
    /**
     * Successfully retrieved grouped threads
     */
    200: Array<ChatThreadGroup>;
};

export type GetGroupedThreadsResponse = GetGroupedThreadsResponses[keyof GetGroupedThreadsResponses];

export type GetMetaDataData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/meta';
};

export type GetMetaDataResponses = {
    /**
     * OK
     */
    200: MetaData;
};

export type GetMetaDataResponse = GetMetaDataResponses[keyof GetMetaDataResponses];

export type GetContributorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/meta/contributors';
};

export type GetContributorsResponses = {
    /**
     * OK
     */
    200: Array<Contributor>;
};

export type GetContributorsResponse = GetContributorsResponses[keyof GetContributorsResponses];

export type GetAllTeamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/team';
};

export type GetAllTeamsResponses = {
    /**
     * OK
     */
    200: Array<TeamInfo>;
};

export type GetAllTeamsResponse = GetAllTeamsResponses[keyof GetAllTeamsResponses];

export type UpdateTeamVisibilityData = {
    body?: boolean;
    path: {
        id: number;
    };
    query?: {
        hidden?: boolean;
    };
    url: '/team/{id}/visibility';
};

export type UpdateTeamVisibilityResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeleteUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type DeleteUserResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetUserSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type GetUserSettingsResponses = {
    /**
     * OK
     */
    200: UserSettings;
};

export type GetUserSettingsResponse = GetUserSettingsResponses[keyof GetUserSettingsResponses];

export type UpdateUserSettingsData = {
    body: UserSettings;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type UpdateUserSettingsResponses = {
    /**
     * OK
     */
    200: UserSettings;
};

export type UpdateUserSettingsResponse = UpdateUserSettingsResponses[keyof UpdateUserSettingsResponses];

export type GetUserProfileData = {
    body?: never;
    path: {
        login: string;
    };
    query?: never;
    url: '/user/{login}/profile';
};

export type GetUserProfileResponses = {
    /**
     * OK
     */
    200: UserProfile;
};

export type GetUserProfileResponse = GetUserProfileResponses[keyof GetUserProfileResponses];

export type ResetAndRecalculateLeaguesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspace/league/reset';
};

export type ResetAndRecalculateLeaguesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetRepositoriesToMonitorData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspace/repositories';
};

export type GetRepositoriesToMonitorResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetRepositoriesToMonitorResponse = GetRepositoriesToMonitorResponses[keyof GetRepositoriesToMonitorResponses];

export type RemoveRepositoryToMonitorData = {
    body?: never;
    path: {
        owner: string;
        name: string;
    };
    query?: never;
    url: '/workspace/repositories/{owner}/{name}';
};

export type RemoveRepositoryToMonitorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddRepositoryToMonitorData = {
    body?: never;
    path: {
        owner: string;
        name: string;
    };
    query?: never;
    url: '/workspace/repositories/{owner}/{name}';
};

export type AddRepositoryToMonitorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveLabelFromTeamData = {
    body?: never;
    path: {
        teamId: number;
        labelId: number;
    };
    query?: never;
    url: '/workspace/team/{teamId}/label/{labelId}';
};

export type RemoveLabelFromTeamResponses = {
    /**
     * OK
     */
    200: TeamInfo;
};

export type RemoveLabelFromTeamResponse = RemoveLabelFromTeamResponses[keyof RemoveLabelFromTeamResponses];

export type AddLabelToTeamData = {
    body?: never;
    path: {
        teamId: number;
        repositoryId: number;
        label: string;
    };
    query?: never;
    url: '/workspace/team/{teamId}/label/{repositoryId}/{label}';
};

export type AddLabelToTeamResponses = {
    /**
     * OK
     */
    200: TeamInfo;
};

export type AddLabelToTeamResponse = AddLabelToTeamResponses[keyof AddLabelToTeamResponses];

export type GetUsersWithTeamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspace/users';
};

export type GetUsersWithTeamsResponses = {
    /**
     * OK
     */
    200: Array<UserTeams>;
};

export type GetUsersWithTeamsResponse = GetUsersWithTeamsResponses[keyof GetUsersWithTeamsResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};