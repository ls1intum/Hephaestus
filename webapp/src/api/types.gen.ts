// This file is auto-generated by @hey-api/openapi-ts

/**
 * Request to assign or update a user's role in a workspace
 */
export type AssignRoleRequest = {
    /**
     * New role to assign (OWNER, ADMIN, MEMBER)
     */
    role: 'OWNER' | 'ADMIN' | 'MEMBER';
    /**
     * User ID of the member to update
     */
    userId: number;
};

/**
 * User feedback on a detected bad practice
 */
export type BadPracticeFeedback = {
    /**
     * User's explanation for the feedback
     */
    explanation: string;
    /**
     * Type of feedback (e.g., 'false_positive', 'not_applicable')
     */
    type: string;
};

export type ChatMessageVote = {
    createdAt: Date;
    isUpvoted: boolean;
    messageId: string;
    updatedAt: Date;
};

export type ChatThreadGroup = {
    groupName: string;
    threads: Array<ChatThreadSummary>;
};

export type ChatThreadSummary = {
    createdAt?: Date;
    id: string;
    title: string;
};

/**
 * Information about a contributor to the Hephaestus project
 */
export type Contributor = {
    /**
     * URL to the contributor's avatar image
     */
    avatarUrl: string;
    /**
     * Number of contributions to the project
     */
    contributions?: number;
    /**
     * URL to the contributor's GitHub profile
     */
    htmlUrl: string;
    /**
     * GitHub user ID
     */
    id: number;
    /**
     * GitHub username
     */
    login: string;
    /**
     * Display name of the contributor
     */
    name: string;
};

export type CreateDocumentRequest = {
    content: string;
    kind: DocumentKind;
    title: string;
};

/**
 * Request to create a new workspace
 */
export type CreateWorkspaceRequest = {
    /**
     * GitHub account login to associate with this workspace
     */
    accountLogin: string;
    /**
     * Type of GitHub account (USER or ORGANIZATION)
     */
    accountType: 'ORG' | 'USER';
    /**
     * Human-readable name of the workspace
     */
    displayName: string;
    /**
     * User ID of the workspace owner
     */
    ownerUserId: number;
    /**
     * URL-friendly identifier for the workspace
     */
    workspaceSlug: string;
};

/**
 * Response for detection operations
 */
export type DetectionResult = {
    result?: 'BAD_PRACTICES_DETECTED' | 'NO_BAD_PRACTICES_DETECTED' | 'ERROR_NO_UPDATE_ON_PULLREQUEST';
};

export type Document = {
    content: string;
    createdAt: Date;
    id: string;
    kind: DocumentKind;
    title: string;
    userId: number;
    versionNumber: number;
};

export type DocumentKind = 'text';

export type DocumentSummary = {
    createdAt: Date;
    id: string;
    kind: DocumentKind;
    title: string;
    userId: number;
};

export type ErrorResponse = {
    /**
     * Human-readable error message
     */
    error: string;
};

/**
 * Information about a label from a repository
 */
export type LabelInfo = {
    /**
     * Hex color code of the label (without #)
     */
    color: string;
    /**
     * Unique identifier of the label
     */
    id: number;
    /**
     * Name of the label
     */
    name: string;
    /**
     * Repository the label belongs to
     */
    repository?: RepositoryInfo;
};

/**
 * A ranked entry in the leaderboard (individual or team)
 */
export type LeaderboardEntry = {
    /**
     * Count of review approvals
     */
    numberOfApprovals: number;
    /**
     * Count of change requests submitted
     */
    numberOfChangeRequests: number;
    /**
     * Count of inline code review comments
     */
    numberOfCodeComments: number;
    /**
     * Count of review and issue comments
     */
    numberOfComments: number;
    /**
     * Count of distinct PRs reviewed
     */
    numberOfReviewedPRs: number;
    /**
     * Count of reviews with unknown/unrecognized state
     */
    numberOfUnknowns: number;
    /**
     * Position in the leaderboard (1-based)
     */
    rank: number;
    /**
     * Sample of reviewed PRs for display
     */
    reviewedPullRequests: Array<PullRequestInfo>;
    /**
     * Total XP score for the timeframe
     */
    score: number;
    /**
     * Team info (populated in TEAM mode, null in INDIVIDUAL mode)
     */
    team?: TeamInfo;
    /**
     * User info (populated in INDIVIDUAL mode, null in TEAM mode)
     */
    user?: UserInfo;
};

export type LeagueChange = {
    leaguePointsChange: number;
    login: string;
};

/**
 * Complete user profile including contribution history and activity
 */
export type Profile = {
    /**
     * Aggregated activity stats consistent with leaderboard calculations
     */
    activityStats?: ProfileActivityStats;
    /**
     * Repositories the user has contributed to
     */
    contributedRepositories: Array<RepositoryInfo>;
    /**
     * Timestamp of the user's first contribution
     */
    firstContribution?: Date;
    /**
     * Currently open pull requests authored by the user
     */
    openPullRequests?: Array<PullRequestInfo>;
    /**
     * Recent review activity with XP scores
     */
    reviewActivity?: Array<ProfileReviewActivity>;
    /**
     * Distinct pull requests reviewed by this user
     */
    reviewedPullRequests?: Array<PullRequestInfo>;
    /**
     * Basic information about the user
     */
    userInfo: UserInfo;
    /**
     * XP progress information for the users' profile
     */
    xpRecord: ProfileXpRecord;
};

/**
 * Aggregated activity statistics with XP scores for a user profile
 */
export type ProfileActivityStats = {
    /**
     * Number of approvals given
     */
    numberOfApprovals?: number;
    /**
     * Number of change requests submitted
     */
    numberOfChangeRequests?: number;
    /**
     * Number of inline code review comments
     */
    numberOfCodeComments?: number;
    /**
     * Number of review comments (COMMENTED state)
     */
    numberOfComments?: number;
    /**
     * Number of issue comments on pull requests
     */
    numberOfIssueComments?: number;
    /**
     * Number of distinct pull requests reviewed
     */
    numberOfReviewedPRs?: number;
    /**
     * Number of reviews with unknown state
     */
    numberOfUnknowns?: number;
    /**
     * Total XP score
     */
    score?: number;
};

/**
 * A review activity entry with XP score for profile display
 */
export type ProfileReviewActivity = {
    /**
     * Author of the review
     */
    author?: UserInfo;
    /**
     * Number of inline code comments in the review
     */
    codeComments: number;
    /**
     * URL to the review on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the review
     */
    id: number;
    /**
     * Whether the review was dismissed
     */
    isDismissed: boolean;
    /**
     * Pull request that was reviewed
     */
    pullRequest?: PullRequestBaseInfo;
    /**
     * XP score earned for this review
     */
    score?: number;
    /**
     * State of the review (APPROVED, CHANGES_REQUESTED, COMMENTED, etc.)
     */
    state: 'COMMENTED' | 'APPROVED' | 'CHANGES_REQUESTED' | 'PENDING' | 'DISMISSED' | 'UNKNOWN';
    /**
     * Timestamp when the review was submitted
     */
    submittedAt?: Date;
};

/**
 * User's XP and Level progress details
 */
export type ProfileXpRecord = {
    /**
     * Current calculated level
     */
    currentLevel: number;
    /**
     * XP accumulated in the current level
     */
    currentLevelXP: number;
    /**
     * Overall total XP accumulated
     */
    totalXP: number;
    /**
     * XP needed to reach the next level
     */
    xpNeeded: number;
};

/**
 * A detected bad practice in a pull request
 */
export type PullRequestBadPractice = {
    /**
     * Detailed explanation and remediation guidance
     */
    description: string;
    /**
     * Unique identifier of the bad practice
     */
    id: number;
    /**
     * Current state of the bad practice (DETECTED, RESOLVED, DISMISSED, etc.)
     */
    state: 'GOOD_PRACTICE' | 'MINOR_ISSUE' | 'NORMAL_ISSUE' | 'CRITICAL_ISSUE' | 'FIXED' | 'WONT_FIX' | 'WRONG';
    /**
     * Short description of the bad practice
     */
    title: string;
};

/**
 * Basic information about a pull request
 */
export type PullRequestBaseInfo = {
    /**
     * URL to the pull request on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the pull request
     */
    id: number;
    /**
     * Whether the pull request is in draft mode
     */
    isDraft: boolean;
    /**
     * Whether the pull request has been merged
     */
    isMerged: boolean;
    /**
     * Pull request number within the repository
     */
    number: number;
    /**
     * Repository the pull request belongs to
     */
    repository?: RepositoryInfo;
    /**
     * Current state of the pull request (OPEN, CLOSED, MERGED)
     */
    state: 'OPEN' | 'CLOSED' | 'MERGED';
    /**
     * Title of the pull request
     */
    title: string;
};

/**
 * Detailed information about a pull request
 */
export type PullRequestInfo = {
    /**
     * Number of lines added
     */
    additions: number;
    /**
     * Users assigned to the pull request
     */
    assignees?: Array<UserInfo>;
    /**
     * Author of the pull request
     */
    author?: UserInfo;
    /**
     * Timestamp when the pull request was closed
     */
    closedAt?: Date;
    /**
     * Number of comments on the pull request
     */
    commentsCount: number;
    /**
     * Timestamp when the pull request was created
     */
    createdAt?: Date;
    /**
     * Number of lines deleted
     */
    deletions: number;
    /**
     * URL to the pull request on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the pull request
     */
    id: number;
    /**
     * Whether the pull request is in draft mode
     */
    isDraft: boolean;
    /**
     * Whether the pull request has been merged
     */
    isMerged: boolean;
    /**
     * Labels applied to the pull request
     */
    labels?: Array<LabelInfo>;
    /**
     * Timestamp when the pull request was merged
     */
    mergedAt?: Date;
    /**
     * Pull request number within the repository
     */
    number: number;
    /**
     * Repository the pull request belongs to
     */
    repository?: RepositoryInfo;
    /**
     * Current state of the pull request (OPEN, CLOSED, MERGED)
     */
    state: 'OPEN' | 'CLOSED' | 'MERGED';
    /**
     * Title of the pull request
     */
    title: string;
    /**
     * Timestamp when the pull request was last updated
     */
    updatedAt?: Date;
};

/**
 * Pull request with associated bad practice detection results
 */
export type PullRequestWithBadPractices = {
    /**
     * Number of lines added
     */
    additions: number;
    /**
     * AI-generated summary of detected bad practices
     */
    badPracticeSummary: string;
    /**
     * Currently active bad practices
     */
    badPractices: Array<PullRequestBadPractice>;
    /**
     * Timestamp when the pull request was created
     */
    createdAt: Date;
    /**
     * Number of lines deleted
     */
    deletions: number;
    /**
     * URL to the pull request on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the pull request
     */
    id: number;
    /**
     * Whether the pull request is in draft mode
     */
    isDraft: boolean;
    /**
     * Whether the pull request has been merged
     */
    isMerged: boolean;
    /**
     * Labels applied to the pull request
     */
    labels: Array<LabelInfo>;
    /**
     * Pull request number within the repository
     */
    number: number;
    /**
     * Previously resolved or dismissed bad practices
     */
    oldBadPractices: Array<PullRequestBadPractice>;
    /**
     * Repository the pull request belongs to
     */
    repository: RepositoryInfo;
    /**
     * Current state of the pull request (OPEN, CLOSED)
     */
    state: 'OPEN' | 'CLOSED' | 'MERGED';
    /**
     * Title of the pull request
     */
    title: string;
    /**
     * Timestamp when the pull request was last updated
     */
    updatedAt: Date;
};

/**
 * Request to rename a workspace's URL slug
 */
export type RenameWorkspaceSlugRequest = {
    /**
     * New URL-friendly identifier for the workspace
     */
    newSlug: string;
};

/**
 * Information about a git repository
 */
export type RepositoryInfo = {
    /**
     * Description of the repository
     */
    description?: string;
    /**
     * Whether contributions from this repository are hidden from leaderboard calculations
     */
    hiddenFromContributions: boolean;
    /**
     * URL to the repository on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the repository
     */
    id: number;
    /**
     * Labels defined in the repository
     */
    labels?: Array<LabelInfo>;
    /**
     * Name of the repository
     */
    name: string;
    /**
     * Full name including owner (e.g., 'owner/repo')
     */
    nameWithOwner: string;
};

export type StreamPart = {
    type: string;
    [key: string]: unknown | string;
};

/**
 * Detailed information about a team including members, repositories, and labels
 */
export type TeamInfo = {
    /**
     * Description of the team
     */
    description?: string;
    /**
     * Whether the team is hidden from leaderboard display
     */
    hidden: boolean;
    /**
     * URL to the team's page on the git provider
     */
    htmlUrl?: string;
    /**
     * Unique identifier of the team
     */
    id: number;
    /**
     * Labels configured as filters for this team
     */
    labels: Array<LabelInfo>;
    /**
     * Members of the team (excluding bots)
     */
    members: Array<UserInfo>;
    /**
     * Total count of team memberships
     */
    membershipCount: number;
    /**
     * Name of the team
     */
    name: string;
    /**
     * Organization the team belongs to
     */
    organization?: string;
    /**
     * ID of the parent team, if this is a sub-team
     */
    parentId?: number;
    /**
     * Privacy level of the team (SECRET or VISIBLE)
     */
    privacy?: 'SECRET' | 'VISIBLE';
    /**
     * Count of repository permissions
     */
    repoPermissionCount: number;
    /**
     * Repositories the team has access to
     */
    repositories: Array<RepositoryInfo>;
};

/**
 * Lightweight summary of a team without member/repository details
 */
export type TeamSummary = {
    /**
     * Description of the team
     */
    description?: string;
    /**
     * Whether the team is hidden from leaderboard display
     */
    hidden: boolean;
    /**
     * URL to the team's page on the git provider
     */
    htmlUrl?: string;
    /**
     * Unique identifier of the team
     */
    id: number;
    /**
     * Name of the team
     */
    name: string;
    /**
     * Organization the team belongs to
     */
    organization?: string;
    /**
     * ID of the parent team, if this is a sub-team
     */
    parentId?: number;
    /**
     * Privacy level of the team (SECRET or VISIBLE)
     */
    privacy?: 'SECRET' | 'VISIBLE';
};

export type ThreadDetail = {
    id: string;
    messages: Array<{
        createdAt?: Date;
        id: string;
        parentMessageId?: string | null;
        parts: Array<{
            type: string;
            [key: string]: unknown | string;
        }>;
        role: 'system' | 'user' | 'assistant';
    }>;
    selectedLeafMessageId?: string | null;
    title?: string | null;
};

/**
 * Request to update repository contribution visibility settings in a workspace
 */
export type UpdateRepositorySettingsRequest = {
    /**
     * Whether contributions from this repository should be hidden from leaderboard calculations
     */
    hiddenFromContributions: boolean;
};

/**
 * Request to update team visibility settings in a workspace
 */
export type UpdateTeamSettingsRequest = {
    /**
     * Whether the team should be hidden from the leaderboard
     */
    hidden: boolean;
};

/**
 * Request to update leaderboard notification settings
 */
export type UpdateWorkspaceNotificationsRequest = {
    /**
     * Slack channel ID for notifications
     */
    channelId?: string;
    /**
     * Whether leaderboard notifications are enabled
     */
    enabled?: boolean;
    /**
     * Team name for filtering leaderboard notifications
     */
    team?: string;
};

/**
 * Request to update workspace public visibility setting
 */
export type UpdateWorkspacePublicVisibilityRequest = {
    /**
     * Whether the workspace should be publicly viewable without authentication
     */
    isPubliclyViewable: boolean;
};

/**
 * Request to update the leaderboard notification schedule
 */
export type UpdateWorkspaceScheduleRequest = {
    /**
     * Day of week (1=Monday, 7=Sunday)
     */
    day: number;
    /**
     * Time in 24-hour format (HH:mm)
     */
    time: string;
};

/**
 * Request to update Slack integration credentials
 */
export type UpdateWorkspaceSlackCredentialsRequest = {
    /**
     * Slack Signing Secret for webhook verification
     */
    slackSigningSecret: string;
    /**
     * Slack Bot User OAuth Token for API access
     */
    slackToken: string;
};

/**
 * Request to update the workspace lifecycle status
 */
export type UpdateWorkspaceStatusRequest = {
    /**
     * New lifecycle status (PENDING, ACTIVE, ARCHIVED)
     */
    status: 'ACTIVE' | 'SUSPENDED' | 'PURGED';
};

/**
 * Request to update the workspace's GitHub Personal Access Token
 */
export type UpdateWorkspaceTokenRequest = {
    /**
     * GitHub Personal Access Token for API access
     */
    personalAccessToken: string;
};

/**
 * Information about a user from the git provider
 */
export type UserInfo = {
    /**
     * URL to the user's avatar image
     */
    avatarUrl: string;
    /**
     * Email address of the user, if public
     */
    email?: string;
    /**
     * URL to the user's profile on the git provider
     */
    htmlUrl: string;
    /**
     * Unique identifier of the user
     */
    id: number;
    /**
     * League points earned by the user in the current scope
     */
    leaguePoints?: number;
    /**
     * Login/username of the user
     */
    login: string;
    /**
     * Display name of the user
     */
    name: string;
};

/**
 * Response for user bad practices listing
 */
export type UserPractices = {
    login?: string;
    pullRequests?: Array<PullRequestWithBadPractices>;
};

/**
 * User preferences and settings
 */
export type UserSettings = {
    /**
     * Whether the user consents to participate in research studies
     */
    participateInResearch: boolean;
    /**
     * Whether the user wants to receive notifications
     */
    receiveNotifications: boolean;
};

export type UserTeams = {
    email?: string;
    id: number;
    login: string;
    name: string;
    teams: Array<TeamSummary>;
    url: string;
};

export type VoteMessageRequest = {
    isUpvoted: boolean;
};

/**
 * Complete workspace information including configuration and settings
 */
export type Workspace = {
    /**
     * GitHub account login associated with this workspace
     */
    accountLogin: string;
    /**
     * Timestamp when the workspace was created
     */
    createdAt: Date;
    /**
     * Human-readable name of the workspace
     */
    displayName: string;
    /**
     * Git provider mode (INSTALLATION or PAT)
     */
    gitProviderMode?: string;
    /**
     * Whether Slack signing secret is configured
     */
    hasSlackSigningSecret: boolean;
    /**
     * Whether Slack token is configured
     */
    hasSlackToken: boolean;
    /**
     * Unique identifier of the workspace
     */
    id: number;
    /**
     * GitHub App installation ID, if linked
     */
    installationId?: number;
    /**
     * Timestamp when the GitHub App installation was linked
     */
    installationLinkedAt?: Date;
    /**
     * Whether the workspace is publicly viewable without authentication
     */
    isPubliclyViewable: boolean;
    /**
     * Slack channel ID for leaderboard notifications
     */
    leaderboardNotificationChannelId?: string;
    /**
     * Whether leaderboard notifications are enabled
     */
    leaderboardNotificationEnabled?: boolean;
    /**
     * Team name for leaderboard notifications
     */
    leaderboardNotificationTeam?: string;
    /**
     * Day of week for leaderboard notifications (1=Monday, 7=Sunday)
     */
    leaderboardScheduleDay?: number;
    /**
     * Time for leaderboard notifications in HH:mm format
     */
    leaderboardScheduleTime?: string;
    /**
     * Current lifecycle status of the workspace (PENDING, ACTIVE, ARCHIVED)
     */
    status: string;
    /**
     * Timestamp when the workspace was last updated
     */
    updatedAt: Date;
    /**
     * URL-friendly identifier for the workspace
     */
    workspaceSlug: string;
};

/**
 * Summary information about a workspace for list views
 */
export type WorkspaceListItem = {
    /**
     * GitHub account login associated with this workspace
     */
    accountLogin: string;
    /**
     * Timestamp when the workspace was created
     */
    createdAt: Date;
    /**
     * Human-readable name of the workspace
     */
    displayName: string;
    /**
     * Unique identifier of the workspace
     */
    id: number;
    /**
     * Current lifecycle status of the workspace (PENDING, ACTIVE, ARCHIVED)
     */
    status: string;
    /**
     * URL-friendly identifier for the workspace
     */
    workspaceSlug: string;
};

/**
 * A user's membership in a workspace
 */
export type WorkspaceMembership = {
    /**
     * Timestamp when the membership was created
     */
    createdAt?: Date;
    /**
     * League points earned by the user in this workspace
     */
    leaguePoints?: number;
    /**
     * Role of the user in this workspace (OWNER, ADMIN, MEMBER)
     */
    role?: 'OWNER' | 'ADMIN' | 'MEMBER';
    /**
     * Unique identifier of the user
     */
    userId?: number;
    /**
     * Login/username of the user
     */
    userLogin?: string;
    /**
     * Display name of the user
     */
    userName?: string;
};

/**
 * Repository contribution visibility settings for a specific team within a workspace
 */
export type WorkspaceTeamRepositorySettings = {
    /**
     * Whether contributions from this repository are hidden from leaderboard calculations
     */
    hiddenFromContributions: boolean;
    /**
     * The repository ID these settings apply to
     */
    repositoryId: number;
    /**
     * The team ID these settings apply to
     */
    teamId: number;
    /**
     * The workspace ID these settings belong to
     */
    workspaceId: number;
};

/**
 * Team visibility settings for a specific workspace
 */
export type WorkspaceTeamSettings = {
    /**
     * Whether the team is hidden in the leaderboard for this workspace
     */
    hidden: boolean;
    /**
     * The team ID these settings apply to
     */
    teamId: number;
    /**
     * The workspace ID these settings belong to
     */
    workspaceId: number;
};

export type ListGlobalContributorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/contributors';
};

export type ListGlobalContributorsResponses = {
    /**
     * list of contributors sorted by contribution count
     */
    200: Array<Contributor>;
};

export type ListGlobalContributorsResponse = ListGlobalContributorsResponses[keyof ListGlobalContributorsResponses];

export type DeleteUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type DeleteUserResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetUserSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type GetUserSettingsResponses = {
    /**
     * OK
     */
    200: UserSettings;
};

export type GetUserSettingsResponse = GetUserSettingsResponses[keyof GetUserSettingsResponses];

export type UpdateUserSettingsData = {
    body: UserSettings;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type UpdateUserSettingsResponses = {
    /**
     * OK
     */
    200: UserSettings;
};

export type UpdateUserSettingsResponse = UpdateUserSettingsResponses[keyof UpdateUserSettingsResponses];

export type ListWorkspacesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type ListWorkspacesResponses = {
    /**
     * Workspace list
     */
    200: Array<WorkspaceListItem>;
};

export type ListWorkspacesResponse = ListWorkspacesResponses[keyof ListWorkspacesResponses];

export type CreateWorkspaceData = {
    body: CreateWorkspaceRequest;
    path?: never;
    query?: never;
    url: '/workspaces';
};

export type CreateWorkspaceResponses = {
    /**
     * Workspace created
     */
    201: Workspace;
};

export type CreateWorkspaceResponse = CreateWorkspaceResponses[keyof CreateWorkspaceResponses];

export type PurgeWorkspaceData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}';
};

export type PurgeWorkspaceResponses = {
    /**
     * Workspace purged
     */
    204: void;
};

export type PurgeWorkspaceResponse = PurgeWorkspaceResponses[keyof PurgeWorkspaceResponses];

export type GetWorkspaceData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}';
};

export type GetWorkspaceResponses = {
    /**
     * Workspace returned
     */
    200: Workspace;
};

export type GetWorkspaceResponse = GetWorkspaceResponses[keyof GetWorkspaceResponses];

export type GetLeaderboardData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query: {
        /**
         * start of the time range (inclusive)
         */
        after: Date;
        /**
         * end of the time range (exclusive)
         */
        before: Date;
        /**
         * Team filter to apply in INDIVIDUAL mode; ignored when mode is TEAM.
         */
        team: string;
        /**
         * Determines the ranking metric. In TEAM mode SCORE uses summed contribution scores; LEAGUE_POINTS uses total league points.
         */
        sort: 'SCORE' | 'LEAGUE_POINTS';
        /**
         * aggregation mode (INDIVIDUAL or TEAM)
         */
        mode: 'INDIVIDUAL' | 'TEAM';
    };
    url: '/workspaces/{workspaceSlug}/leaderboard';
};

export type GetLeaderboardResponses = {
    /**
     * ranked list of leaderboard entries
     */
    200: Array<LeaderboardEntry>;
};

export type GetLeaderboardResponse = GetLeaderboardResponses[keyof GetLeaderboardResponses];

export type GetUserLeagueStatsData = {
    /**
     * the user's current leaderboard entry for comparison
     */
    body: LeaderboardEntry;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the user's GitHub login
         */
        login: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/leaderboard/users/{login}/league-stats';
};

export type GetUserLeagueStatsResponses = {
    /**
     * league change statistics including projected point delta
     */
    200: LeagueChange;
};

export type GetUserLeagueStatsResponse = GetUserLeagueStatsResponses[keyof GetUserLeagueStatsResponses];

export type ResetAndRecalculateLeaguesData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/league/reset';
};

export type ResetAndRecalculateLeaguesResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type ListMembersData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: {
        /**
         * Page number (0-indexed)
         */
        page?: number;
        /**
         * Page size (default 50, max 100)
         */
        size?: number;
    };
    url: '/workspaces/{workspaceSlug}/members';
};

export type ListMembersResponses = {
    /**
     * List of workspace memberships
     */
    200: Array<WorkspaceMembership>;
};

export type ListMembersResponse = ListMembersResponses[keyof ListMembersResponses];

export type AssignRoleData = {
    /**
     * Role assignment request
     */
    body: AssignRoleRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/members/assign';
};

export type AssignRoleResponses = {
    /**
     * Updated membership
     */
    200: WorkspaceMembership;
};

export type AssignRoleResponse = AssignRoleResponses[keyof AssignRoleResponses];

export type GetCurrentUserMembershipData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/members/me';
};

export type GetCurrentUserMembershipResponses = {
    /**
     * the current user's membership details
     */
    200: WorkspaceMembership;
};

export type GetCurrentUserMembershipResponse = GetCurrentUserMembershipResponses[keyof GetCurrentUserMembershipResponses];

export type RemoveMemberData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * User ID to remove
         */
        userId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/members/{userId}';
};

export type RemoveMemberResponses = {
    /**
     * 204 No Content on success
     */
    200: unknown;
};

export type GetMemberData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * User ID
         */
        userId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/members/{userId}';
};

export type GetMemberResponses = {
    /**
     * Workspace membership details
     */
    200: WorkspaceMembership;
};

export type GetMemberResponse = GetMemberResponses[keyof GetMemberResponses];

export type MentorChatData = {
    /**
     * Chat request body
     */
    body: {
        /**
         * If true, generate a greeting without user message
         */
        greeting?: boolean;
        id: string;
        message?: {
            id: string;
            parts: Array<{
                text: string;
                type: 'text';
            } | {
                mediaType: 'image/jpeg' | 'image/png';
                name: string;
                type: 'file';
                url: string;
            }>;
            role: 'user';
        };
        previousMessageId?: string;
    };
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/chat';
};

export type MentorChatResponses = {
    /**
     * Event stream of chat updates.
     */
    200: StreamPart;
};

export type MentorChatResponse = MentorChatResponses[keyof MentorChatResponses];

export type ListDocumentsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: {
        page?: number | null;
        size?: number;
    };
    url: '/workspaces/{workspaceSlug}/mentor/documents';
};

export type ListDocumentsErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type ListDocumentsError = ListDocumentsErrors[keyof ListDocumentsErrors];

export type ListDocumentsResponses = {
    /**
     * Document summaries
     */
    200: Array<DocumentSummary>;
};

export type ListDocumentsResponse = ListDocumentsResponses[keyof ListDocumentsResponses];

export type CreateDocumentData = {
    /**
     * Create document
     */
    body: CreateDocumentRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/documents';
};

export type CreateDocumentErrors = {
    /**
     * Missing required context
     */
    400: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type CreateDocumentError = CreateDocumentErrors[keyof CreateDocumentErrors];

export type CreateDocumentResponses = {
    /**
     * Created document
     */
    201: Document;
};

export type CreateDocumentResponse = CreateDocumentResponses[keyof CreateDocumentResponses];

export type DeleteDocumentData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}';
};

export type DeleteDocumentErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type DeleteDocumentError = DeleteDocumentErrors[keyof DeleteDocumentErrors];

export type DeleteDocumentResponses = {
    /**
     * Deleted
     */
    204: void;
};

export type DeleteDocumentResponse = DeleteDocumentResponses[keyof DeleteDocumentResponses];

export type GetDocumentData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}';
};

export type GetDocumentErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetDocumentError = GetDocumentErrors[keyof GetDocumentErrors];

export type GetDocumentResponses = {
    /**
     * Document
     */
    200: Document;
};

export type GetDocumentResponse = GetDocumentResponses[keyof GetDocumentResponses];

export type UpdateDocumentData = {
    /**
     * Update document
     */
    body: CreateDocumentRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}';
};

export type UpdateDocumentErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type UpdateDocumentError = UpdateDocumentErrors[keyof UpdateDocumentErrors];

export type UpdateDocumentResponses = {
    /**
     * Updated document
     */
    200: Document;
};

export type UpdateDocumentResponse = UpdateDocumentResponses[keyof UpdateDocumentResponses];

export type DeleteDocumentVersionsAfterData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
    };
    query: {
        after: Date;
    };
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}/versions';
};

export type DeleteDocumentVersionsAfterErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type DeleteDocumentVersionsAfterError = DeleteDocumentVersionsAfterErrors[keyof DeleteDocumentVersionsAfterErrors];

export type DeleteDocumentVersionsAfterResponses = {
    /**
     * Deleted versions
     */
    200: Array<Document>;
};

export type DeleteDocumentVersionsAfterResponse = DeleteDocumentVersionsAfterResponses[keyof DeleteDocumentVersionsAfterResponses];

export type ListVersionsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
    };
    query?: {
        page?: number | null;
        size?: number;
    };
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}/versions';
};

export type ListVersionsErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type ListVersionsError = ListVersionsErrors[keyof ListVersionsErrors];

export type ListVersionsResponses = {
    /**
     * Document versions
     */
    200: Array<Document>;
};

export type ListVersionsResponse = ListVersionsResponses[keyof ListVersionsResponses];

export type GetVersionData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: string;
        versionNumber: number | null;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/documents/{id}/versions/{versionNumber}';
};

export type GetVersionErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetVersionError = GetVersionErrors[keyof GetVersionErrors];

export type GetVersionResponses = {
    /**
     * Document
     */
    200: Document;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type VoteMessageData = {
    /**
     * Vote request body
     */
    body: VoteMessageRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        messageId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/messages/{messageId}/vote';
};

export type VoteMessageErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Message not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type VoteMessageError = VoteMessageErrors[keyof VoteMessageErrors];

export type VoteMessageResponses = {
    /**
     * Vote recorded
     */
    200: ChatMessageVote;
};

export type VoteMessageResponse = VoteMessageResponses[keyof VoteMessageResponses];

export type GetGroupedThreadsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/threads/grouped';
};

export type GetGroupedThreadsErrors = {
    /**
     * Missing context
     */
    400: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
};

export type GetGroupedThreadsError = GetGroupedThreadsErrors[keyof GetGroupedThreadsErrors];

export type GetGroupedThreadsResponses = {
    /**
     * Grouped chat threads
     */
    200: Array<ChatThreadGroup>;
};

export type GetGroupedThreadsResponse = GetGroupedThreadsResponses[keyof GetGroupedThreadsResponses];

export type GetThreadData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        threadId: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/mentor/threads/{threadId}';
};

export type GetThreadErrors = {
    /**
     * Missing required context
     */
    400: ErrorResponse;
    /**
     * Thread not found
     */
    404: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
    /**
     * Service temporarily unavailable
     */
    503: ErrorResponse;
};

export type GetThreadError = GetThreadErrors[keyof GetThreadErrors];

export type GetThreadResponses = {
    /**
     * Thread detail with messages
     */
    200: ThreadDetail;
};

export type GetThreadResponse = GetThreadResponses[keyof GetThreadResponses];

export type UpdateNotificationsData = {
    body: UpdateWorkspaceNotificationsRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/notifications';
};

export type UpdateNotificationsResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdateNotificationsResponse = UpdateNotificationsResponses[keyof UpdateNotificationsResponses];

export type GetBadPracticeData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/badpractice/{id}';
};

export type GetBadPracticeResponses = {
    /**
     * Bad practice returned
     */
    200: PullRequestBadPractice;
};

export type GetBadPracticeResponse = GetBadPracticeResponses[keyof GetBadPracticeResponses];

export type ProvideFeedbackData = {
    body: BadPracticeFeedback;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/badpractice/{id}/feedback';
};

export type ProvideFeedbackErrors = {
    /**
     * User is not an assignee of the pull request
     */
    403: unknown;
};

export type ProvideFeedbackResponses = {
    /**
     * Feedback submitted successfully
     */
    200: unknown;
};

export type ResolveData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        id: number;
    };
    query: {
        state: 'GOOD_PRACTICE' | 'MINOR_ISSUE' | 'NORMAL_ISSUE' | 'CRITICAL_ISSUE' | 'FIXED' | 'WONT_FIX' | 'WRONG';
    };
    url: '/workspaces/{workspaceSlug}/practices/badpractice/{id}/resolve';
};

export type ResolveResponses = {
    /**
     * Bad practice resolved successfully
     */
    200: unknown;
};

export type GetBadPracticesForPullRequestData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        pullRequestId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/pullrequest/{pullRequestId}';
};

export type GetBadPracticesForPullRequestResponses = {
    /**
     * Bad practices returned
     */
    200: PullRequestWithBadPractices;
};

export type GetBadPracticesForPullRequestResponse = GetBadPracticesForPullRequestResponses[keyof GetBadPracticesForPullRequestResponses];

export type DetectForPullRequestData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        pullRequestId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/pullrequest/{pullRequestId}/detect';
};

export type DetectForPullRequestErrors = {
    /**
     * Detection failed due to no updates on pull request
     */
    400: DetectionResult;
};

export type DetectForPullRequestError = DetectForPullRequestErrors[keyof DetectForPullRequestErrors];

export type DetectForPullRequestResponses = {
    /**
     * Detection completed successfully
     */
    200: DetectionResult;
};

export type DetectForPullRequestResponse = DetectForPullRequestResponses[keyof DetectForPullRequestResponses];

export type GetBadPracticesForUserData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        login: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/user/{login}';
};

export type GetBadPracticesForUserResponses = {
    /**
     * Bad practices returned
     */
    200: UserPractices;
};

export type GetBadPracticesForUserResponse = GetBadPracticesForUserResponses[keyof GetBadPracticesForUserResponses];

export type DetectForUserData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        login: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/practices/user/{login}/detect';
};

export type DetectForUserErrors = {
    /**
     * Detection failed due to no updates on pull requests
     */
    400: DetectionResult;
};

export type DetectForUserError = DetectForUserErrors[keyof DetectForUserErrors];

export type DetectForUserResponses = {
    /**
     * Detection completed successfully
     */
    200: DetectionResult;
};

export type DetectForUserResponse = DetectForUserResponses[keyof DetectForUserResponses];

export type GetUserProfileData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the user's GitHub login
         */
        login: string;
    };
    query?: {
        after?: Date;
        before?: Date;
    };
    url: '/workspaces/{workspaceSlug}/profile/{login}';
};

export type GetUserProfileResponses = {
    /**
     * user profile with open PRs, review activity, league points, etc.
     */
    200: Profile;
};

export type GetUserProfileResponse = GetUserProfileResponses[keyof GetUserProfileResponses];

export type UpdatePublicVisibilityData = {
    body: UpdateWorkspacePublicVisibilityRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/public-visibility';
};

export type UpdatePublicVisibilityResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdatePublicVisibilityResponse = UpdatePublicVisibilityResponses[keyof UpdatePublicVisibilityResponses];

export type GetRepositoriesToMonitorData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/repositories';
};

export type GetRepositoriesToMonitorResponses = {
    /**
     * Repository list
     */
    200: Array<string>;
};

export type GetRepositoriesToMonitorResponse = GetRepositoriesToMonitorResponses[keyof GetRepositoriesToMonitorResponses];

export type RemoveRepositoryToMonitorData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        owner: string;
        name: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/repositories/{owner}/{name}';
};

export type RemoveRepositoryToMonitorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type AddRepositoryToMonitorData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        owner: string;
        name: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/repositories/{owner}/{name}';
};

export type AddRepositoryToMonitorResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UpdateScheduleData = {
    body: UpdateWorkspaceScheduleRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/schedule';
};

export type UpdateScheduleResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdateScheduleResponse = UpdateScheduleResponses[keyof UpdateScheduleResponses];

export type UpdateSlackCredentialsData = {
    body: UpdateWorkspaceSlackCredentialsRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/slack-credentials';
};

export type UpdateSlackCredentialsResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdateSlackCredentialsResponse = UpdateSlackCredentialsResponses[keyof UpdateSlackCredentialsResponses];

export type RenameSlugData = {
    body: RenameWorkspaceSlugRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/slug';
};

export type RenameSlugResponses = {
    /**
     * Workspace renamed
     */
    200: Workspace;
};

export type RenameSlugResponse = RenameSlugResponses[keyof RenameSlugResponses];

export type UpdateStatusData = {
    body: UpdateWorkspaceStatusRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/status';
};

export type UpdateStatusResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdateStatusResponse = UpdateStatusResponses[keyof UpdateStatusResponses];

export type GetAllTeamsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/team';
};

export type GetAllTeamsResponses = {
    /**
     * list of teams with their members and permissions
     */
    200: Array<TeamInfo>;
};

export type GetAllTeamsResponse = GetAllTeamsResponses[keyof GetAllTeamsResponses];

export type UpdateTeamVisibilityData = {
    /**
     * whether to hide the team (body parameter, preferred)
     */
    body?: boolean;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        id: number;
    };
    query?: {
        /**
         * whether to hide the team (query parameter, fallback)
         */
        hidden?: boolean;
    };
    url: '/workspaces/{workspaceSlug}/team/{id}/visibility';
};

export type UpdateTeamVisibilityResponses = {
    /**
     * 200 OK on success, 404 if team not found
     */
    200: unknown;
};

export type UpdateRepositoryVisibilityData = {
    body?: boolean;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        teamId: number;
        repositoryId: number;
    };
    query?: {
        hiddenFromContributions?: boolean;
    };
    url: '/workspaces/{workspaceSlug}/team/{teamId}/repositories/{repositoryId}/visibility';
};

export type UpdateRepositoryVisibilityResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type RemoveLabelFromTeamData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        teamId: number;
        labelId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/labels/{labelId}';
};

export type RemoveLabelFromTeamResponses = {
    /**
     * OK
     */
    200: TeamInfo;
};

export type RemoveLabelFromTeamResponse = RemoveLabelFromTeamResponses[keyof RemoveLabelFromTeamResponses];

export type AddLabelToTeamData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        teamId: number;
        repositoryId: number;
        label: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/labels/{repositoryId}/{label}';
};

export type AddLabelToTeamResponses = {
    /**
     * OK
     */
    200: TeamInfo;
};

export type AddLabelToTeamResponse = AddLabelToTeamResponses[keyof AddLabelToTeamResponses];

export type GetTeamSettingsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings';
};

export type GetTeamSettingsResponses = {
    /**
     * Team settings returned
     */
    200: WorkspaceTeamSettings;
};

export type GetTeamSettingsResponse = GetTeamSettingsResponses[keyof GetTeamSettingsResponses];

export type UpdateTeamSettingsData = {
    /**
     * the update request containing the hidden flag
     */
    body: UpdateTeamSettingsRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings';
};

export type UpdateTeamSettingsErrors = {
    /**
     * Team not found in workspace
     */
    404: WorkspaceTeamSettings;
};

export type UpdateTeamSettingsError = UpdateTeamSettingsErrors[keyof UpdateTeamSettingsErrors];

export type UpdateTeamSettingsResponses = {
    /**
     * Team settings updated
     */
    200: WorkspaceTeamSettings;
};

export type UpdateTeamSettingsResponse = UpdateTeamSettingsResponses[keyof UpdateTeamSettingsResponses];

export type GetLabelFiltersData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings/label-filters';
};

export type GetLabelFiltersResponses = {
    /**
     * Label filters returned
     */
    200: Array<LabelInfo>;
};

export type GetLabelFiltersResponse = GetLabelFiltersResponses[keyof GetLabelFiltersResponses];

export type RemoveLabelFilterData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
        /**
         * the label ID to remove as filter
         */
        labelId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings/label-filters/{labelId}';
};

export type RemoveLabelFilterErrors = {
    /**
     * Label filter not found
     */
    404: unknown;
};

export type RemoveLabelFilterResponses = {
    /**
     * Label filter removed
     */
    204: void;
};

export type RemoveLabelFilterResponse = RemoveLabelFilterResponses[keyof RemoveLabelFilterResponses];

export type AddLabelFilterData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
        /**
         * the label ID to add as filter
         */
        labelId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings/label-filters/{labelId}';
};

export type AddLabelFilterErrors = {
    /**
     * Team or label not found
     */
    404: unknown;
};

export type AddLabelFilterResponses = {
    /**
     * Label filter added
     */
    201: unknown;
};

export type GetRepositorySettingsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
        /**
         * the repository ID
         */
        repositoryId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings/repositories/{repositoryId}';
};

export type GetRepositorySettingsResponses = {
    /**
     * Repository settings returned
     */
    200: WorkspaceTeamRepositorySettings;
};

export type GetRepositorySettingsResponse = GetRepositorySettingsResponses[keyof GetRepositorySettingsResponses];

export type UpdateRepositorySettingsData = {
    /**
     * the update request containing the hiddenFromContributions flag
     */
    body: UpdateRepositorySettingsRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
        /**
         * the team ID
         */
        teamId: number;
        /**
         * the repository ID
         */
        repositoryId: number;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/teams/{teamId}/settings/repositories/{repositoryId}';
};

export type UpdateRepositorySettingsErrors = {
    /**
     * Team or repository not found
     */
    404: WorkspaceTeamRepositorySettings;
};

export type UpdateRepositorySettingsError = UpdateRepositorySettingsErrors[keyof UpdateRepositorySettingsErrors];

export type UpdateRepositorySettingsResponses = {
    /**
     * Repository settings updated
     */
    200: WorkspaceTeamRepositorySettings;
};

export type UpdateRepositorySettingsResponse = UpdateRepositorySettingsResponses[keyof UpdateRepositorySettingsResponses];

export type UpdateTokenData = {
    body: UpdateWorkspaceTokenRequest;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/token';
};

export type UpdateTokenResponses = {
    /**
     * Workspace updated
     */
    200: Workspace;
};

export type UpdateTokenResponse = UpdateTokenResponses[keyof UpdateTokenResponses];

export type GetUsersWithTeamsData = {
    body?: never;
    path: {
        /**
         * Workspace slug
         */
        workspaceSlug: string;
    };
    query?: never;
    url: '/workspaces/{workspaceSlug}/users';
};

export type GetUsersWithTeamsResponses = {
    /**
     * OK
     */
    200: Array<UserTeams>;
};

export type GetUsersWithTeamsResponse = GetUsersWithTeamsResponses[keyof GetUsersWithTeamsResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};