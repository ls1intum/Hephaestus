// This file is auto-generated by @hey-api/openapi-ts

import { type Options, provideFeedbackForBadPractice, resolveBadPractice, detectBadPracticesForPullRequest, detectBadPracticesByUser, getActivityByUser, voteMessage, getUserDocuments, createDocument, deleteDocument, getDocument, updateDocument, deleteVersionsAfterTimestamp, getDocumentVersions, getDocumentVersion, getAll, getById, getLeaderboard, getUserLeagueStats, getThread, getThreads, getGroupedThreads, getMetaData, getContributors, getTeams, hideTeam, deleteUser, getUserSettings, updateUserSettings, getUserProfile, resetAndRecalculateLeagues, getRepositoriesToMonitor, removeRepositoryToMonitor, addRepositoryToMonitor, deleteTeam, removeLabelFromTeam, addLabelToTeam, removeRepositoryFromTeam, addRepositoryToTeam, createTeam, automaticallyAssignTeams, removeUserFromTeam, addTeamToUser, getUsersWithTeams } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { ProvideFeedbackForBadPracticeData, ResolveBadPracticeData, DetectBadPracticesForPullRequestData, DetectBadPracticesByUserData, GetActivityByUserData, VoteMessageData, VoteMessageError, VoteMessageResponse, GetUserDocumentsData, GetUserDocumentsResponse, CreateDocumentData, CreateDocumentError, CreateDocumentResponse, DeleteDocumentData, DeleteDocumentResponse, GetDocumentData, UpdateDocumentData, UpdateDocumentError, UpdateDocumentResponse, DeleteVersionsAfterTimestampData, DeleteVersionsAfterTimestampError, DeleteVersionsAfterTimestampResponse, GetDocumentVersionsData, GetDocumentVersionsError, GetDocumentVersionsResponse, GetDocumentVersionData, GetAllData, GetByIdData, GetLeaderboardData, GetLeaderboardResponse, GetUserLeagueStatsData, GetUserLeagueStatsResponse, GetThreadData, GetThreadsData, GetGroupedThreadsData, GetMetaDataData, GetContributorsData, GetTeamsData, HideTeamData, HideTeamResponse, DeleteUserData, GetUserSettingsData, UpdateUserSettingsData, UpdateUserSettingsResponse, GetUserProfileData, ResetAndRecalculateLeaguesData, GetRepositoriesToMonitorData, RemoveRepositoryToMonitorData, AddRepositoryToMonitorData, DeleteTeamData, DeleteTeamResponse, RemoveLabelFromTeamData, RemoveLabelFromTeamResponse, AddLabelToTeamData, AddLabelToTeamResponse, RemoveRepositoryFromTeamData, RemoveRepositoryFromTeamResponse, AddRepositoryToTeamData, AddRepositoryToTeamResponse, CreateTeamData, CreateTeamResponse, AutomaticallyAssignTeamsData, RemoveUserFromTeamData, RemoveUserFromTeamResponse, AddTeamToUserData, AddTeamToUserResponse, GetUsersWithTeamsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const provideFeedbackForBadPracticeQueryKey = (options: Options<ProvideFeedbackForBadPracticeData>) => createQueryKey('provideFeedbackForBadPractice', options);

export const provideFeedbackForBadPracticeOptions = (options: Options<ProvideFeedbackForBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: provideFeedbackForBadPracticeQueryKey(options)
    });
};

export const provideFeedbackForBadPracticeMutation = (options?: Partial<Options<ProvideFeedbackForBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ProvideFeedbackForBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await provideFeedbackForBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const resolveBadPracticeQueryKey = (options: Options<ResolveBadPracticeData>) => createQueryKey('resolveBadPractice', options);

export const resolveBadPracticeOptions = (options: Options<ResolveBadPracticeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: resolveBadPracticeQueryKey(options)
    });
};

export const resolveBadPracticeMutation = (options?: Partial<Options<ResolveBadPracticeData>>): UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResolveBadPracticeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resolveBadPractice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesForPullRequestQueryKey = (options: Options<DetectBadPracticesForPullRequestData>) => createQueryKey('detectBadPracticesForPullRequest', options);

export const detectBadPracticesForPullRequestOptions = (options: Options<DetectBadPracticesForPullRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesForPullRequestQueryKey(options)
    });
};

export const detectBadPracticesForPullRequestMutation = (options?: Partial<Options<DetectBadPracticesForPullRequestData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesForPullRequestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesForPullRequest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const detectBadPracticesByUserQueryKey = (options: Options<DetectBadPracticesByUserData>) => createQueryKey('detectBadPracticesByUser', options);

export const detectBadPracticesByUserOptions = (options: Options<DetectBadPracticesByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: detectBadPracticesByUserQueryKey(options)
    });
};

export const detectBadPracticesByUserMutation = (options?: Partial<Options<DetectBadPracticesByUserData>>): UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DetectBadPracticesByUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await detectBadPracticesByUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActivityByUserQueryKey = (options: Options<GetActivityByUserData>) => createQueryKey('getActivityByUser', options);

export const getActivityByUserOptions = (options: Options<GetActivityByUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActivityByUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActivityByUserQueryKey(options)
    });
};

export const voteMessageQueryKey = (options: Options<VoteMessageData>) => createQueryKey('voteMessage', options);

/**
 * Vote on a message
 * Cast an upvote or downvote on a chat message
 */
export const voteMessageOptions = (options: Options<VoteMessageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await voteMessage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: voteMessageQueryKey(options)
    });
};

/**
 * Vote on a message
 * Cast an upvote or downvote on a chat message
 */
export const voteMessageMutation = (options?: Partial<Options<VoteMessageData>>): UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> => {
    const mutationOptions: UseMutationOptions<VoteMessageResponse, VoteMessageError, Options<VoteMessageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await voteMessage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserDocumentsQueryKey = (options?: Options<GetUserDocumentsData>) => createQueryKey('getUserDocuments', options);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsOptions = (options?: Options<GetUserDocumentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserDocuments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getUserDocumentsInfiniteQueryKey = (options?: Options<GetUserDocumentsData>): QueryKey<Options<GetUserDocumentsData>> => createQueryKey('getUserDocuments', options, true);

/**
 * Get all user documents (latest versions only)
 */
export const getUserDocumentsInfiniteOptions = (options?: Options<GetUserDocumentsData>) => {
    return infiniteQueryOptions<GetUserDocumentsResponse, DefaultError, InfiniteData<GetUserDocumentsResponse>, QueryKey<Options<GetUserDocumentsData>>, number | Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetUserDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getUserDocuments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserDocumentsInfiniteQueryKey(options)
    });
};

export const createDocumentQueryKey = (options: Options<CreateDocumentData>) => createQueryKey('createDocument', options);

/**
 * Create a new document
 */
export const createDocumentOptions = (options: Options<CreateDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDocumentQueryKey(options)
    });
};

/**
 * Create a new document
 */
export const createDocumentMutation = (options?: Partial<Options<CreateDocumentData>>): UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> => {
    const mutationOptions: UseMutationOptions<CreateDocumentResponse, CreateDocumentError, Options<CreateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a document and all its versions
 */
export const deleteDocumentMutation = (options?: Partial<Options<DeleteDocumentData>>): UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> => {
    const mutationOptions: UseMutationOptions<DeleteDocumentResponse, DefaultError, Options<DeleteDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentQueryKey = (options: Options<GetDocumentData>) => createQueryKey('getDocument', options);

/**
 * Get latest version of a document
 */
export const getDocumentOptions = (options: Options<GetDocumentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocument({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentQueryKey(options)
    });
};

/**
 * Update a document (creates new version)
 */
export const updateDocumentMutation = (options?: Partial<Options<UpdateDocumentData>>): UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> => {
    const mutationOptions: UseMutationOptions<UpdateDocumentResponse, UpdateDocumentError, Options<UpdateDocumentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateDocument({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete document versions after specified timestamp
 */
export const deleteVersionsAfterTimestampMutation = (options?: Partial<Options<DeleteVersionsAfterTimestampData>>): UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> => {
    const mutationOptions: UseMutationOptions<DeleteVersionsAfterTimestampResponse, DeleteVersionsAfterTimestampError, Options<DeleteVersionsAfterTimestampData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteVersionsAfterTimestamp({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDocumentVersionsQueryKey = (options: Options<GetDocumentVersionsData>) => createQueryKey('getDocumentVersions', options);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsOptions = (options: Options<GetDocumentVersionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsQueryKey(options)
    });
};

export const getDocumentVersionsInfiniteQueryKey = (options: Options<GetDocumentVersionsData>): QueryKey<Options<GetDocumentVersionsData>> => createQueryKey('getDocumentVersions', options, true);

/**
 * Get all versions of a document
 */
export const getDocumentVersionsInfiniteOptions = (options: Options<GetDocumentVersionsData>) => {
    return infiniteQueryOptions<GetDocumentVersionsResponse, GetDocumentVersionsError, InfiniteData<GetDocumentVersionsResponse>, QueryKey<Options<GetDocumentVersionsData>>, number | Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetDocumentVersionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getDocumentVersions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionsInfiniteQueryKey(options)
    });
};

export const getDocumentVersionQueryKey = (options: Options<GetDocumentVersionData>) => createQueryKey('getDocumentVersion', options);

/**
 * Get specific version of a document by timestamp
 */
export const getDocumentVersionOptions = (options: Options<GetDocumentVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDocumentVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDocumentVersionQueryKey(options)
    });
};

export const getAllQueryKey = (options?: Options<GetAllData>) => createQueryKey('getAll', options);

export const getAllOptions = (options?: Options<GetAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllQueryKey(options)
    });
};

export const getByIdQueryKey = (options: Options<GetByIdData>) => createQueryKey('getById', options);

export const getByIdOptions = (options: Options<GetByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getByIdQueryKey(options)
    });
};

export const getLeaderboardQueryKey = (options: Options<GetLeaderboardData>) => createQueryKey('getLeaderboard', options);

export const getLeaderboardOptions = (options: Options<GetLeaderboardData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLeaderboard({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardQueryKey(options)
    });
};

export const getLeaderboardInfiniteQueryKey = (options: Options<GetLeaderboardData>): QueryKey<Options<GetLeaderboardData>> => createQueryKey('getLeaderboard', options, true);

export const getLeaderboardInfiniteOptions = (options: Options<GetLeaderboardData>) => {
    return infiniteQueryOptions<GetLeaderboardResponse, DefaultError, InfiniteData<GetLeaderboardResponse>, QueryKey<Options<GetLeaderboardData>>, Date | Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetLeaderboardData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    after: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getLeaderboard({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLeaderboardInfiniteQueryKey(options)
    });
};

export const getUserLeagueStatsQueryKey = (options: Options<GetUserLeagueStatsData>) => createQueryKey('getUserLeagueStats', options);

export const getUserLeagueStatsOptions = (options: Options<GetUserLeagueStatsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLeagueStatsQueryKey(options)
    });
};

export const getUserLeagueStatsMutation = (options?: Partial<Options<GetUserLeagueStatsData>>): UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> => {
    const mutationOptions: UseMutationOptions<GetUserLeagueStatsResponse, DefaultError, Options<GetUserLeagueStatsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getUserLeagueStats({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getThreadQueryKey = (options: Options<GetThreadData>) => createQueryKey('getThread', options);

/**
 * Get chat thread detail
 * Retrieve a specific chat thread with all messages
 */
export const getThreadOptions = (options: Options<GetThreadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThread({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadQueryKey(options)
    });
};

export const getThreadsQueryKey = (options?: Options<GetThreadsData>) => createQueryKey('getThreads', options);

/**
 * Get user's chat threads
 * Retrieve all chat threads for the authenticated user
 */
export const getThreadsOptions = (options?: Options<GetThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getThreadsQueryKey(options)
    });
};

export const getGroupedThreadsQueryKey = (options?: Options<GetGroupedThreadsData>) => createQueryKey('getGroupedThreads', options);

/**
 * Get user's grouped chat threads
 * Retrieve all chat threads for the authenticated user grouped by time periods
 */
export const getGroupedThreadsOptions = (options?: Options<GetGroupedThreadsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getGroupedThreads({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getGroupedThreadsQueryKey(options)
    });
};

export const getMetaDataQueryKey = (options?: Options<GetMetaDataData>) => createQueryKey('getMetaData', options);

export const getMetaDataOptions = (options?: Options<GetMetaDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetaData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetaDataQueryKey(options)
    });
};

export const getContributorsQueryKey = (options?: Options<GetContributorsData>) => createQueryKey('getContributors', options);

export const getContributorsOptions = (options?: Options<GetContributorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getContributors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getContributorsQueryKey(options)
    });
};

export const getTeamsQueryKey = (options?: Options<GetTeamsData>) => createQueryKey('getTeams', options);

export const getTeamsOptions = (options?: Options<GetTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTeamsQueryKey(options)
    });
};

export const hideTeamQueryKey = (options: Options<HideTeamData>) => createQueryKey('hideTeam', options);

export const hideTeamOptions = (options: Options<HideTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await hideTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: hideTeamQueryKey(options)
    });
};

export const hideTeamMutation = (options?: Partial<Options<HideTeamData>>): UseMutationOptions<HideTeamResponse, DefaultError, Options<HideTeamData>> => {
    const mutationOptions: UseMutationOptions<HideTeamResponse, DefaultError, Options<HideTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await hideTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserSettingsQueryKey = (options?: Options<GetUserSettingsData>) => createQueryKey('getUserSettings', options);

export const getUserSettingsOptions = (options?: Options<GetUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsQueryKey = (options: Options<UpdateUserSettingsData>) => createQueryKey('updateUserSettings', options);

export const updateUserSettingsOptions = (options: Options<UpdateUserSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await updateUserSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: updateUserSettingsQueryKey(options)
    });
};

export const updateUserSettingsMutation = (options?: Partial<Options<UpdateUserSettingsData>>): UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserSettingsResponse, DefaultError, Options<UpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserProfileQueryKey = (options: Options<GetUserProfileData>) => createQueryKey('getUserProfile', options);

export const getUserProfileOptions = (options: Options<GetUserProfileData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserProfile({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserProfileQueryKey(options)
    });
};

export const resetAndRecalculateLeaguesMutation = (options?: Partial<Options<ResetAndRecalculateLeaguesData>>): UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<ResetAndRecalculateLeaguesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await resetAndRecalculateLeagues({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRepositoriesToMonitorQueryKey = (options?: Options<GetRepositoriesToMonitorData>) => createQueryKey('getRepositoriesToMonitor', options);

export const getRepositoriesToMonitorOptions = (options?: Options<GetRepositoriesToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRepositoriesToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRepositoriesToMonitorQueryKey(options)
    });
};

export const removeRepositoryToMonitorMutation = (options?: Partial<Options<RemoveRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<RemoveRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToMonitorQueryKey = (options: Options<AddRepositoryToMonitorData>) => createQueryKey('addRepositoryToMonitor', options);

export const addRepositoryToMonitorOptions = (options: Options<AddRepositoryToMonitorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToMonitorQueryKey(options)
    });
};

export const addRepositoryToMonitorMutation = (options?: Partial<Options<AddRepositoryToMonitorData>>): UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AddRepositoryToMonitorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToMonitor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteTeamMutation = (options?: Partial<Options<DeleteTeamData>>): UseMutationOptions<DeleteTeamResponse, DefaultError, Options<DeleteTeamData>> => {
    const mutationOptions: UseMutationOptions<DeleteTeamResponse, DefaultError, Options<DeleteTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeLabelFromTeamMutation = (options?: Partial<Options<RemoveLabelFromTeamData>>): UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveLabelFromTeamResponse, DefaultError, Options<RemoveLabelFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeLabelFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addLabelToTeamQueryKey = (options: Options<AddLabelToTeamData>) => createQueryKey('addLabelToTeam', options);

export const addLabelToTeamOptions = (options: Options<AddLabelToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addLabelToTeamQueryKey(options)
    });
};

export const addLabelToTeamMutation = (options?: Partial<Options<AddLabelToTeamData>>): UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddLabelToTeamResponse, DefaultError, Options<AddLabelToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addLabelToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeRepositoryFromTeamMutation = (options?: Partial<Options<RemoveRepositoryFromTeamData>>): UseMutationOptions<RemoveRepositoryFromTeamResponse, DefaultError, Options<RemoveRepositoryFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveRepositoryFromTeamResponse, DefaultError, Options<RemoveRepositoryFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeRepositoryFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addRepositoryToTeamQueryKey = (options: Options<AddRepositoryToTeamData>) => createQueryKey('addRepositoryToTeam', options);

export const addRepositoryToTeamOptions = (options: Options<AddRepositoryToTeamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addRepositoryToTeam({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addRepositoryToTeamQueryKey(options)
    });
};

export const addRepositoryToTeamMutation = (options?: Partial<Options<AddRepositoryToTeamData>>): UseMutationOptions<AddRepositoryToTeamResponse, DefaultError, Options<AddRepositoryToTeamData>> => {
    const mutationOptions: UseMutationOptions<AddRepositoryToTeamResponse, DefaultError, Options<AddRepositoryToTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addRepositoryToTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createTeamMutation = (options?: Partial<Options<CreateTeamData>>): UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> => {
    const mutationOptions: UseMutationOptions<CreateTeamResponse, DefaultError, Options<CreateTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const automaticallyAssignTeamsMutation = (options?: Partial<Options<AutomaticallyAssignTeamsData>>): UseMutationOptions<unknown, DefaultError, Options<AutomaticallyAssignTeamsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AutomaticallyAssignTeamsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await automaticallyAssignTeams({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeUserFromTeamMutation = (options?: Partial<Options<RemoveUserFromTeamData>>): UseMutationOptions<RemoveUserFromTeamResponse, DefaultError, Options<RemoveUserFromTeamData>> => {
    const mutationOptions: UseMutationOptions<RemoveUserFromTeamResponse, DefaultError, Options<RemoveUserFromTeamData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeUserFromTeam({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTeamToUserMutation = (options?: Partial<Options<AddTeamToUserData>>): UseMutationOptions<AddTeamToUserResponse, DefaultError, Options<AddTeamToUserData>> => {
    const mutationOptions: UseMutationOptions<AddTeamToUserResponse, DefaultError, Options<AddTeamToUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTeamToUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersWithTeamsQueryKey = (options?: Options<GetUsersWithTeamsData>) => createQueryKey('getUsersWithTeams', options);

export const getUsersWithTeamsOptions = (options?: Options<GetUsersWithTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersWithTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersWithTeamsQueryKey(options)
    });
};