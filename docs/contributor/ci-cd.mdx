---
id: ci-cd
sidebar_position: 4
title: CI/CD Architecture
description: High-performance trunk-based CI/CD with automatic staging and gated production.
---

# CI/CD Architecture

Hephaestus uses trunk-based continuous deployment powered by GitHub Actions. Every merge to `main` triggers automatic staging deployment, with production requiring manual approval.

## üèóÔ∏è Architecture Overview

```mermaid
graph TD
    PR[Pull Request] --> Review{Code Review}
    Review -->|Approved| Merge[Merge to main]
    Merge --> CI[CI/CD Pipeline]

    subgraph CI/CD
    CI --> Q[Quality Gates]
    CI --> T[Tests]
    CI --> D[Docker Build]
    end

    Q --> Pass{All Pass?}
    T --> Pass
    D --> Pass

    Pass -->|Yes| SR[semantic-release]
    SR --> Tag[Create Tag v1.2.3]

    Tag --> Staging[Deploy Staging]
    Staging --> Verify{Verify OK?}
    Verify -->|Approve| Prod[Deploy Production]
```

## ‚ö° Pipeline Timeline

| Stage                 | Duration                   | Notes                   |
| --------------------- | -------------------------- | ----------------------- |
| Quality gates         | ~3 min                     | Parallel with tests     |
| Tests                 | ~3 min                     | Parallel with gates     |
| Docker builds         | ~7 min                     | Uses layer caching      |
| semantic-release      | ~1 min                     | Creates tag + changelog |
| Staging deploy        | ~2 min                     | Automatic               |
| **Your verification** | You decide                 | Check staging           |
| Production deploy     | ~2 min                     | After approval          |
| **Total**             | **~15 min + verification** |                         |

## üöÄ Release Flow

### Continuous Deployment

Every merge to `main` with releasable changes (`feat:`, `fix:`, `perf:`, `revert:`, breaking):

1. **CI runs** ‚Äî tests, quality gates, Docker builds
2. **semantic-release** ‚Äî analyzes commits, creates version tag
3. **Staging deploys** ‚Äî automatic, no approval needed
4. **You verify** ‚Äî check staging.hephaestus.cit.tum.de
5. **Approve production** ‚Äî click in GitHub Actions
6. **Production deploys** ‚Äî live!

## üõ°Ô∏è Quality Gates

Before any release, code must pass:

| Gate            | Tool        | Purpose               |
| --------------- | ----------- | --------------------- |
| Database drift  | Liquibase   | JPA ‚Üî Schema sync    |
| OpenAPI sync    | Diff check  | Client ‚Üî Server sync |
| Java formatting | Spotless    | Code style            |
| TypeScript      | Biome + tsc | Lint + typecheck      |

## üîí Security

- **Trivy** ‚Äî Scans Docker images for CVEs
- **Renovate** ‚Äî Monitors dependencies for vulnerabilities
- **Environment protection** ‚Äî Production requires approval

## üì¶ Environments

| Environment       | Protection        | Deploys On     |
| ----------------- | ----------------- | -------------- |
| Preview (Coolify) | None              | Every PR       |
| Staging           | None              | Every tag      |
| Production        | Approval required | Tag + approval |

### GitHub Environment Setup

1. **Settings ‚Üí Environments ‚Üí New environment**
2. Create `staging` (no rules)
3. Create `production` with **Required reviewers**

## üîÑ Preview Deployments

Coolify handles PR previews:

- Built directly on server (fast!)
- URL: `pr-{number}.preview.hephaestus.cit.tum.de`
- Auto-cleanup on PR close

## ‚öôÔ∏è Key Workflows

| Workflow             | Trigger               | Purpose                                        |
| -------------------- | --------------------- | ---------------------------------------------- |
| `cicd.yml`           | Push to main, PRs     | Tests, builds, quality gates                   |
| `release.yml`        | On CI/CD Success      | Creates tag, deploys staging, gates production |
| `deploy-staging.yml` | Called by release.yml | Deploys to staging                             |
| `deploy-prod.yml`    | workflow_dispatch     | Deploys to production (manual trigger)         |

## üéØ Performance Optimizations

### Path-Based Filtering

CI only runs jobs for components that actually changed:

| Component            | Triggers On                                                   |
| -------------------- | ------------------------------------------------------------- |
| Webapp               | `webapp/**`, `package.json`, `package-lock.json`              |
| Application Server   | `server/application-server/**`, `scripts/db-utils.sh`         |
| Intelligence Service | `server/intelligence-service/**`, scripts, root package files |
| Webhook Ingest       | `server/webhook-ingest/**`, root package files                |
| CI Config            | `.github/workflows/**`, `.github/actions/**` ‚Üí runs all jobs  |

**Benefits:**

- Webapp-only changes skip Java tests (~3 min saved)
- Docs-only changes skip all CI jobs (~7 min saved)
- CI config changes run everything (safety net)

### Docker Layer Caching

- All images built every run
- Aggressive caching makes unchanged builds instant
- Ensures every commit is deployable

### Parallel Execution

- 9 test types run in parallel
- 8 quality gate checks run in parallel
- 4 Docker builds √ó 2 architectures (amd64 + arm64)
- `fail-fast: false` ensures all jobs complete for full feedback

### Concurrency Control

- Outdated PR runs cancelled automatically
- Release runs never cancelled

## üõ†Ô∏è Running CI Locally

Before pushing, run the same checks that CI runs:

### Quick Check (Recommended)

```bash
# Format and check all services
npm run format && npm run check
```

### Per-Service Commands

```bash
# Webapp
npm run check:webapp          # Full check (format + lint + typecheck)
npm run test:webapp           # Unit tests

# Application Server (Java)
npm run format:java:check     # Check formatting
cd server/application-server && ./mvnw test -Dgroups="unit"  # Unit tests

# Intelligence Service
npm run check:intelligence-service
cd server/intelligence-service && npm run test:unit

# Webhook Ingest
npm run check:webhook-ingest
cd server/webhook-ingest && npm run test
```

### Common Issues

| Issue                 | Solution                                      |
| --------------------- | --------------------------------------------- |
| Formatting errors     | Run `npm run format`                          |
| TypeScript errors     | Run `npm run typecheck:webapp` to see details |
| Test failures         | Check the specific test output for details    |
| OpenAPI out of sync   | Run `npm run generate:api`                    |
| Database schema drift | Run `npm run db:draft-changelog`              |

## üìä CI Features

### Test Results

All test suites generate JUnit XML reports that are displayed in the **Test Results** tab of each workflow run:

- **Application Server**: Unit, integration, and architecture tests
- **Webapp**: Unit tests and Storybook interaction tests
- **Intelligence Service**: Unit and integration tests (with Testcontainers)
- **Webhook Ingest**: Unit tests

### Job Summary

Each CI run generates a rich **Job Summary** in the Actions UI with:

- Overall status with emoji indicators
- Results table for each workflow (quality gates, tests, security, Docker)
- Components changed table (from path filtering)
- Failure-specific troubleshooting guides with fix commands
- Performance metrics showing skipped workflows

### Workflow Timeline

The CI Status Gate job generates a visual **Mermaid timeline** showing:

- Job execution order and duration
- Parallel job execution
- Runner wait times
- Critical path identification

This helps identify bottlenecks and optimization opportunities.
