---
id: testing
sidebar_position: 4
title: Testing Guide
description: Choose the right test type and integrate with the Maven-powered pipeline.
---

Testing keeps regression risk low across services. The application server uses Maven with dedicated base classes for unit and integration tests.

## Quick start

1. Decide whether you need a fast unit test or a Spring-backed integration test.
2. Run the appropriate command:

   ```bash
   # Unit tests only (fast)
   ./mvnw test

   # Full suite including integration tests
   ./mvnw verify
   ```

3. Extend the correct base class:

   ```java
   // Unit test
   class UserServiceTest extends BaseUnitTest { }

   // Integration test
   class UserServiceIntegrationTest extends BaseIntegrationTest { }
   ```

:::warning Naming matters
Use `*Test.java` for unit tests and `*IntegrationTest.java` for integration tests. Maven's surefire and failsafe plugins use these patterns.
:::

## Why testing?

Tests catch regressions before they hit production, document expected behaviour, and unlock safe refactors. Our setup keeps the feedback loop fast—unit tests finish in under a second, while the shared Testcontainers environment limits the cost of integration suites.

## Unit tests

- Extend `BaseUnitTest` for isolated component tests.
- Use Mockito (`@Mock`, `@InjectMocks`) for dependencies.
- Expect sub-second runtime—no Spring context is loaded.

```java
class UserServiceTest extends BaseUnitTest {
    @Mock private UserRepository repository;
    @InjectMocks private UserService service;

    @Test
    @DisplayName("Should validate email format")
    void shouldValidateEmailFormat() {
        // Fast isolated test
    }
}
```

## Integration tests

- Extend `BaseIntegrationTest` for cross-component behaviour.
- Relies on a shared PostgreSQL Testcontainers instance (significantly faster than per-test containers).
- Provides annotations such as `@GitHubPayload("label.created")` to inject recorded webhook payloads.

Example:

```java
class GitHubLabelMessageHandlerIntegrationTest extends BaseIntegrationTest {
    @Test
    @DisplayName("Should persist label from webhook")
    void shouldPersistLabel(GHEventPayload.Label payload) {
        // Test with real webhook data
    }
}
```

## Webhook fixtures and tooling

Reusable webhook JSON lives in `src/test/resources/github`. Use `@GitHubPayload("event.name")` to inject them, or extract new samples with:

```bash
python3 scripts/nats_extract_examples.py
```

Available examples include `label.created`, `repository.created`, `create`, `push`, and more—consult the folder before recording new payloads.

## Maven recipes

```bash
./mvnw test                                   # Unit tests
./mvnw verify                                 # Full suite + packaging
./mvnw test -Dtest=UserServiceTest            # Single test class
./mvnw test -Dtest=UserServiceTest#methodName # Single test method
```

Use the optional `-Dgroups=unit` or `-Dgroups=integration` flags once category support lands.

## GitHub live sync integration tests

Some regression scenarios can only be validated against GitHub itself. We ship a focused suite that exercises the live GitHub App installation and verifies end-to-end sync behaviour (repository metadata, labels, milestones, and teams).

### Prerequisites

1. **Sandbox installation** – the `Hephaestus IntegrationTests` GitHub App must be installed in a sandbox organisation you control. The tests create and delete repositories, milestones, labels, and teams on each run.
2. **Credentials** – provide both a GitHub App private key and a Personal Access Token with the following scopes:
    - `repo` (full)
    - `admin:org`
    - `read:packages`
3. **Local config file** – copy the template that lives alongside the tests:

    ```bash
    cd server/application-server/src/test/resources
    cp application-github-integration-local.example.yml application-github-integration-local.yml
    ```

    Fill in the placeholders with the sandbox organisation slug, the installation id, and either an inline PEM key (`github.app.privateKey`) or a readable `privateKeyLocation`. Keep this file out of version control—it is already listed in `.gitignore`.

    Alternatively, export the matching environment variables:

    ```bash
    export GH_IT_APP_ID=2250297
    export GH_IT_APP_PAT=ghp_xxx...      # PAT with the scopes above
    export GH_IT_INSTALLATION_ID=93512943
    export GH_IT_ORGANIZATION=HephaestusTest
    export GH_IT_APP_PRIVATE_KEY_PATH=/absolute/path/to/private-key.pem
    ```

    Use either the file _or_ the environment variables; the suite checks both and aborts if key material is missing.

### Running the suite

From `server/application-server/` run:

```bash
./mvnw test -Dgroups=github-integration
```

The run takes roughly two minutes and prints the GitHub artefacts it provisions. Clean-up is handled automatically, but if a failure interrupts execution you can safely delete any `hephaestus-it-*` repositories, milestones, or teams that remain in the sandbox.

### Troubleshooting

- **Skipping because of missing credentials** – check the console output; the base test class verifies that the App id, private key, PAT, and installation id are all present before executing.
- **Hub4j rate-limit failures** – the suite creates several entities per run. Prefer a dedicated sandbox organisation so you do not clash with production automation limits.
- **Longer runtimes** – each suite bootstraps a Testcontainers PostgreSQL instance and provisions GitHub resources. Expect higher runtimes than the pure Testcontainers integration tests; avoid running them on every PR and instead use them before releases or when touching the GitHub sync layer.

