name: Quality Gates

on:
  workflow_call:
    inputs:
      should_skip:
        description: "Whether to skip the workflow"
        required: false
        type: string
        default: "false"

env:
  # Global pipeline configuration
  MAVEN_OPTS: -Xmx2048m -XX:+UseParallelGC
  NODE_VERSION: 22
  PYTHON_VERSION: 3.13
  JAVA_VERSION: 21

jobs:
  # Enterprise-grade quality gates with intelligent caching and error handling
  quality-gates:
    name: ${{ matrix.check }}
    runs-on: ubuntu-latest
    if: inputs.should_skip != 'true'
    timeout-minutes: ${{ contains(fromJSON('["database-schema-validation", "database-documentation-validation"]'), matrix.check) && 20 || 15 }}
    strategy:
      fail-fast: false
      matrix:
        check:
          [
            java-format,
            webapp-quality,
            python-quality,
            openapi-validation,
            database-schema-validation,
            database-documentation-validation,
          ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Advanced cache setup with fallback
      - name: Setup shared caches
        uses: ./.github/actions/setup-caches
        with:
          cache-type: ${{ matrix.check }}
          os: ${{ runner.os }}

      # Additional cache for webapp build artifacts
      - name: Cache webapp build artifacts
        if: matrix.check == 'webapp-quality'
        uses: actions/cache@v4
        with:
          path: |
            webapp-react/dist
            webapp-react/.vite
            webapp-react/node_modules/.vite
            webapp-react/node_modules/.cache
          key: ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp-react/package-lock.json', 'webapp-react/biome.json', 'webapp-react/tsconfig.json', 'webapp-react/vite.config.js', 'webapp-react/components.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp-react/package-lock.json', 'webapp-react/biome.json', 'webapp-react/tsconfig.json', 'webapp-react/vite.config.js', 'webapp-react/components.json') }}-
            ${{ runner.os }}-webapp-build-

      # Java code quality and formatting
      - name: Java formatting & static analysis
        if: matrix.check == 'java-format'
        run: |
          echo "üîç Checking Java code formatting and style..."

          # Install dependencies if not cached
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit
          fi

          # Run Java formatting check and capture output
          echo "üé® Running Prettier formatting check..."
          npm run format:java:check 2>&1 | tee java-format-results.txt
          FORMAT_EXIT_CODE=${PIPESTATUS[0]}

          # Exit with error if formatting failed
          if [ $FORMAT_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Application Server formatting check failed"
            # Extract specific files that need formatting
            JAVA_BAD_FILES=$(grep -o '[^ ]*\.java' java-format-results.txt | head -10 || echo "")
            JAVA_FILE_COUNT=$(echo "$JAVA_BAD_FILES" | wc -l | tr -d ' ')
            echo "APPLICATION_SERVER_STATUS=failed" >> $GITHUB_ENV
            echo "APPLICATION_SERVER_VIOLATIONS=$JAVA_FILE_COUNT" >> $GITHUB_ENV
            echo "APPLICATION_SERVER_BAD_FILES<<EOF" >> $GITHUB_ENV
            echo "$JAVA_BAD_FILES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            exit 1
          fi

          echo "‚úÖ Application Server formatting checks passed"
          echo "APPLICATION_SERVER_STATUS=passed" >> $GITHUB_ENV

      # Webapp quality checks with comprehensive validation
      - name: Webapp quality & type checking
        if: matrix.check == 'webapp-quality'
        working-directory: ./webapp-react
        run: |
          echo "üîç Running webapp-react quality checks..."

          # Install dependencies if not cached
          if [ ! -d "node_modules" ]; then
            echo "üì¶ Installing dependencies..."
            npm ci --prefer-offline --no-audit --progress=false
          else
            echo "üì¶ Dependencies restored from cache"
          fi

          # Run Biome check (linting + formatting + imports)
          echo "üé® Running Biome code quality checks..."
          npm run check 2>&1 | tee biome-results.txt
          BIOME_EXIT_CODE=${PIPESTATUS[0]}

          # TypeScript compilation check
          echo "üìä Running TypeScript compilation check..."
          npx tsc --noEmit --pretty 2>&1 | tee typescript-results.txt
          TSC_EXIT_CODE=${PIPESTATUS[0]}

          # Build check to ensure everything compiles
          echo "üèóÔ∏è Running build verification..."
          npm run build 2>&1 | tee build-results.txt
          BUILD_EXIT_CODE=${PIPESTATUS[0]}

          # Package audit for security vulnerabilities
          echo "üîí Running security audit..."
          npm audit --audit-level=high --progress=false 2>&1 | tee audit-results.txt || true

          # Exit with error if any critical checks failed
          if [ $BIOME_EXIT_CODE -ne 0 ] || [ $TSC_EXIT_CODE -ne 0 ] || [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Webapp-react quality checks failed"
            
            # Extract specific TypeScript errors
            if [ $TSC_EXIT_CODE -ne 0 ]; then
              TS_ERRORS=$(grep -E "error TS[0-9]+" typescript-results.txt | head -10 || echo "")
              echo "WEBAPP_REACT_TS_ERRORS<<EOF" >> $GITHUB_ENV
              echo "$TS_ERRORS" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            fi
            
            # Extract specific Biome errors
            if [ $BIOME_EXIT_CODE -ne 0 ]; then
              BIOME_ERRORS=$(grep -E "‚úñ|√ó" biome-results.txt | head -10 || echo "")
              echo "WEBAPP_REACT_BIOME_ERRORS<<EOF" >> $GITHUB_ENV
              echo "$BIOME_ERRORS" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            fi
            
            echo "WEBAPP_REACT_STATUS=failed" >> $GITHUB_ENV
            exit 1
          fi

          echo "‚úÖ All webapp-react quality checks passed"
          echo "WEBAPP_REACT_STATUS=passed" >> $GITHUB_ENV

      # Python quality checks with comprehensive validation
      - name: Python quality & security analysis
        if: matrix.check == 'python-quality'
        run: |
          set -o pipefail  # Make pipelines fail if any command fails
          echo "üîç Running comprehensive Python quality checks..."

          # Track issues found
          ISSUES_FOUND=()
          OVERALL_SUCCESS=true

          # Intelligence Service checks
          echo "üìù Checking Intelligence Service..."
          cd server/intelligence-service

          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi

          # Code formatting with specific file tracking
          echo "üé® Checking code formatting..."
          poetry run black --check --diff . 2>&1 | tee black-results.txt
          INTELLIGENCE_BLACK_EXIT_CODE=${PIPESTATUS[0]}
          if [ $INTELLIGENCE_BLACK_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Intelligence Service: Black formatting check failed"
            # Extract specific files that need formatting
            INTELLIGENCE_BAD_FILES=$(grep "would reformat" black-results.txt | sed 's/would reformat //' || echo "")
            INTELLIGENCE_FILE_COUNT=$(echo "$INTELLIGENCE_BAD_FILES" | wc -l | tr -d ' ')
            ISSUES_FOUND+=("Intelligence Service: $INTELLIGENCE_FILE_COUNT files need formatting")
            echo "INTELLIGENCE_SERVICE_BAD_FILES<<EOF" >> $GITHUB_ENV
            echo "$INTELLIGENCE_BAD_FILES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            OVERALL_SUCCESS=false
          else
            echo "‚úÖ Intelligence Service: Black formatting check passed"
          fi

          # Linting with specific error tracking
          echo "üîç Running flake8 linting..."
          poetry run flake8 . --statistics --count 2>&1 | tee flake8-results.txt
          INTELLIGENCE_FLAKE8_EXIT_CODE=${PIPESTATUS[0]}
          if [ $INTELLIGENCE_FLAKE8_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Intelligence Service: Flake8 linting failed"
            # Extract specific files and line numbers with errors
            INTELLIGENCE_LINT_ERRORS=$(grep ":[0-9]*:[0-9]*:" flake8-results.txt | head -10 || echo "")
            INTELLIGENCE_ERROR_COUNT=$(echo "$INTELLIGENCE_LINT_ERRORS" | wc -l | tr -d ' ')
            ISSUES_FOUND+=("Intelligence Service: $INTELLIGENCE_ERROR_COUNT linting errors")
            echo "INTELLIGENCE_SERVICE_LINT_ERRORS<<EOF" >> $GITHUB_ENV
            echo "$INTELLIGENCE_LINT_ERRORS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            OVERALL_SUCCESS=false
          else
            echo "‚úÖ Intelligence Service: Flake8 linting passed"
          fi

          cd ../..

          # Webhook Ingest checks
          echo "üìù Checking Webhook Ingest..."
          cd server/webhook-ingest

          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi

          # Code formatting with specific file tracking
          echo "üé® Checking code formatting..."
          poetry run black --check --diff . 2>&1 | tee webhook-black-results.txt
          WEBHOOK_BLACK_EXIT_CODE=${PIPESTATUS[0]}
          if [ $WEBHOOK_BLACK_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Webhook Ingest: Black formatting check failed"
            # Extract specific files that need formatting
            WEBHOOK_BAD_FILES=$(grep "would reformat" webhook-black-results.txt | sed 's/would reformat //' || echo "")
            WEBHOOK_FILE_COUNT=$(echo "$WEBHOOK_BAD_FILES" | wc -l | tr -d ' ')
            ISSUES_FOUND+=("Webhook Ingest: $WEBHOOK_FILE_COUNT files need formatting")
            echo "WEBHOOK_INGEST_BAD_FILES<<EOF" >> $GITHUB_ENV
            echo "$WEBHOOK_BAD_FILES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            OVERALL_SUCCESS=false
          else
            echo "‚úÖ Webhook Ingest: Black formatting check passed"
          fi

          # Linting with specific error tracking
          echo "üîç Running flake8 linting..."
          poetry run flake8 . --statistics --count 2>&1 | tee webhook-flake8-results.txt
          WEBHOOK_FLAKE8_EXIT_CODE=${PIPESTATUS[0]}
          if [ $WEBHOOK_FLAKE8_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Webhook Ingest: Flake8 linting failed"
            # Extract specific files and line numbers with errors
            WEBHOOK_LINT_ERRORS=$(grep ":[0-9]*:[0-9]*:" webhook-flake8-results.txt | head -10 || echo "")
            WEBHOOK_ERROR_COUNT=$(echo "$WEBHOOK_LINT_ERRORS" | wc -l | tr -d ' ')
            ISSUES_FOUND+=("Webhook Ingest: $WEBHOOK_ERROR_COUNT linting errors")
            echo "WEBHOOK_INGEST_LINT_ERRORS<<EOF" >> $GITHUB_ENV
            echo "$WEBHOOK_LINT_ERRORS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            OVERALL_SUCCESS=false
          else
            echo "‚úÖ Webhook Ingest: Flake8 linting passed"
          fi

          cd ../..

          # Export service status for summary
          if [ ${#ISSUES_FOUND[@]} -eq 0 ]; then
            echo "‚úÖ All Python services quality checks passed!"
            echo "INTELLIGENCE_SERVICE_STATUS=passed" >> $GITHUB_ENV
            echo "WEBHOOK_INGEST_STATUS=passed" >> $GITHUB_ENV
          else
            echo "‚ùå Found ${#ISSUES_FOUND[@]} issue(s) across Python services:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            
            # Determine which services failed
            INTELLIGENCE_FAILED=false
            WEBHOOK_FAILED=false
            
            for issue in "${ISSUES_FOUND[@]}"; do
              if [[ "$issue" == *"Intelligence Service"* ]]; then
                INTELLIGENCE_FAILED=true
              fi
              if [[ "$issue" == *"Webhook Ingest"* ]]; then
                WEBHOOK_FAILED=true
              fi
            done
            
            echo "INTELLIGENCE_SERVICE_STATUS=$([[ $INTELLIGENCE_FAILED == true ]] && echo 'failed' || echo 'passed')" >> $GITHUB_ENV
            echo "WEBHOOK_INGEST_STATUS=$([[ $WEBHOOK_FAILED == true ]] && echo 'failed' || echo 'passed')" >> $GITHUB_ENV
            
            # Calculate issue counts for each service
            INTELLIGENCE_ISSUES=0
            WEBHOOK_ISSUES=0
            for issue in "${ISSUES_FOUND[@]}"; do
              if [[ "$issue" == *"Intelligence Service"* ]]; then
                ((INTELLIGENCE_ISSUES++))
              fi
              if [[ "$issue" == *"Webhook Ingest"* ]]; then
                ((WEBHOOK_ISSUES++))
              fi
            done
            
            echo "INTELLIGENCE_SERVICE_ISSUES=$INTELLIGENCE_ISSUES" >> $GITHUB_ENV
            echo "WEBHOOK_INGEST_ISSUES=$WEBHOOK_ISSUES" >> $GITHUB_ENV
          fi

          # Exit with appropriate code
          if [ "$OVERALL_SUCCESS" = false ]; then
            echo ""
            echo "‚ùå Python services quality checks failed - please fix the issues above"
            exit 1
          fi

          echo "‚úÖ All Python services quality checks passed successfully"

      # OpenAPI validation with intelligent auto-commit
      - name: OpenAPI validation & synchronization
        if: matrix.check == 'openapi-validation'
        run: |
          echo "üîç Validating OpenAPI specifications and clients..."

          # Install all dependencies
          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit
          fi

          # Setup Python environments
          cd server/intelligence-service
          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi
          cd ../..

          # Setup Java environment
          cd server/application-server
          if [ ! -d "target" ]; then
            mvn compile -DskipTests --quiet
          fi
          cd ../..

          echo "üîÑ Generating OpenAPI specifications and clients..."

          # Generate all OpenAPI specs and clients
          npm run generate:api

          # Check for any changes
          git add .

          if ! git diff --cached --quiet; then
            echo "üìù OpenAPI changes detected..."
            
            # Count changed files for metrics
            CHANGED_FILES=$(git diff --cached --name-only | wc -l | tr -d ' ')
            
            # Check if auto-commit is enabled
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'autocommit-openapi') }}" == "true" ]]; then
              echo "‚úÖ Auto-commit enabled, committing changes..."
              
              # Configure git
              git config --local user.name "github-actions[bot]"
              git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
              
              # Create detailed commit message
              COMMIT_MSG="chore: update OpenAPI specs and clients [skip ci]"
              COMMIT_BODY=""
              
              # Check which components changed
              if git diff --cached --quiet server/intelligence-service/openapi.yaml; then
                :
              else
                COMMIT_BODY="$COMMIT_BODY\n- Update Intelligence Service OpenAPI spec"
              fi
              
              if git diff --cached --quiet server/application-server/openapi.yaml; then
                :
              else
                COMMIT_BODY="$COMMIT_BODY\n- Update Application Server OpenAPI spec"
              fi
              
              if git diff --cached --quiet server/application-server/src/main/java/de/tum/in/www1/hephaestus/intelligenceservice/; then
                :
              else
                COMMIT_BODY="$COMMIT_BODY\n- Update Intelligence Service Java client"
              fi
              
              if git diff --cached --quiet webapp-react/src/api/; then
                :
              else
                COMMIT_BODY="$COMMIT_BODY\n- Update Application Server TypeScript client"
              fi
              
              # Commit with detailed message
              if [ -n "$COMMIT_BODY" ]; then
                git commit -m "$COMMIT_MSG$COMMIT_BODY"
              else
                git commit -m "$COMMIT_MSG"
              fi
              
              # Push changes
              git push
              
              echo "‚úÖ OpenAPI changes successfully committed and pushed"
              echo "OPENAPI_STATUS=auto-committed" >> $GITHUB_ENV
              echo "OPENAPI_CHANGES_COUNT=$CHANGED_FILES" >> $GITHUB_ENV
            else
              echo "‚ùå OpenAPI validation failed - changes detected but auto-commit not enabled"
              echo "Add the 'autocommit-openapi' label to this PR or run 'npm run generate:api' locally"
              echo "OPENAPI_STATUS=failed" >> $GITHUB_ENV
              echo "OPENAPI_CHANGES_COUNT=$CHANGED_FILES" >> $GITHUB_ENV
              exit 1
            fi
          else
            echo "‚úÖ OpenAPI validation passed - all specs and clients are up to date"
            echo "OPENAPI_STATUS=passed" >> $GITHUB_ENV
            echo "OPENAPI_CHANGES_COUNT=0" >> $GITHUB_ENV
          fi
              
              echo "‚ùå OpenAPI validation failed - changes detected but auto-commit not enabled"
              echo "Add the 'autocommit-openapi' label to this PR or run 'npm run generate:api' locally"
              exit 1
            fi
          else
            echo "‚úÖ OpenAPI validation passed - all specs and clients are up to date"
          fi

      # Database schema validation - JPA entities vs committed migrations
      - name: Database schema validation
        if: matrix.check == 'database-schema-validation'
        run: |
          echo "üîç Validating JPA entities match committed migrations..."

          # Start PostgreSQL service for schema operations
          echo "üêò Starting PostgreSQL service for schema validation..."
          docker run -d \
            --name postgres-schema \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL to be ready..."
          until docker exec postgres-schema pg_isready -U root -d hephaestus; do
            echo "PostgreSQL is not ready yet, waiting..."
            sleep 2
          done
          echo "‚úÖ PostgreSQL is ready for schema validation"

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build Application Server for schema operations
          echo "üèóÔ∏è Building Application Server for schema validation..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build Application Server for schema validation"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi
          cd ../..

          # Check for schema drift between JPA entities and committed migrations
          echo "üìä Checking for schema drift between JPA entities and committed migrations..."
          if ! scripts/db-utils.sh draft-changelog; then
            echo "‚ùå Failed to generate draft changelog for schema validation"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi

          # Clean up PostgreSQL container
          echo "üßπ Cleaning up PostgreSQL container..."
          docker stop postgres-schema && docker rm postgres-schema

          # Check results and generate summary
          if [ -f "server/application-server/src/main/resources/db/changelog_new.xml" ]; then
            echo "‚ùå Schema validation failed - JPA entities have uncommitted changes"
            echo "Run 'npm run db:draft-changelog' to create migration, then move to changelog/"
            echo "DB_SCHEMA_STATUS=failed" >> $GITHUB_ENV
            echo "DB_SCHEMA_DRIFT=true" >> $GITHUB_ENV
            exit 1
          else
            echo "‚úÖ Schema validation passed - JPA entities match committed migrations"
            echo "DB_SCHEMA_STATUS=passed" >> $GITHUB_ENV
            echo "DB_SCHEMA_DRIFT=false" >> $GITHUB_ENV
          fi

      # Database documentation validation - ERD matches migration-based schema
      - name: Database documentation validation
        if: matrix.check == 'database-documentation-validation'
        run: |
          echo "üìä Validating ERD documentation matches migration-based schema..."

          # Start PostgreSQL service for ERD generation
          echo "üêò Starting PostgreSQL service for ERD documentation validation..."
          docker run -d \
            --name postgres-erd \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL to be ready..."
          until docker exec postgres-erd pg_isready -U root -d hephaestus; do
            echo "PostgreSQL is not ready yet, waiting..."
            sleep 2
          done
          echo "‚úÖ PostgreSQL is ready for ERD generation"

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build Application Server for ERD operations
          echo "üèóÔ∏è Building Application Server for ERD documentation validation..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build Application Server for ERD documentation validation"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi
          cd ../..

          # Generate ERD documentation from committed migration-based schema
          echo "üìà Generating ERD from committed migration-based schema..."
          echo "Note: ERD always reflects the current committed migration state, not entity code changes"
          if ! scripts/db-utils.sh generate-erd; then
            echo "‚ùå Failed to generate ERD documentation"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi

          # Clean up PostgreSQL container
          echo "üßπ Cleaning up PostgreSQL container..."
          docker stop postgres-erd && docker rm postgres-erd

          # Check if ERD documentation is up to date
          git add docs/dev/database/schema.mmd

          if ! git diff --cached --quiet docs/dev/database/schema.mmd; then
            echo "‚ùå ERD documentation validation failed - docs are out of sync"
            echo "Run 'npm run db:generate-erd-docs' and commit the updated docs"
            echo "DB_DOCS_STATUS=failed" >> $GITHUB_ENV
            echo "DB_DOCS_OUTDATED=true" >> $GITHUB_ENV
            exit 1
          else
            echo "‚úÖ ERD documentation validation passed - ERD matches migration-based schema"
            echo "DB_DOCS_STATUS=passed" >> $GITHUB_ENV
            echo "DB_DOCS_OUTDATED=false" >> $GITHUB_ENV
          fi

  # Simple, focused quality summary
  quality-summary:
    name: Quality Gates Summary
    runs-on: ubuntu-latest
    needs: [quality-gates]
    if: always() && inputs.should_skip != 'true'
    steps:
      - name: Generate quality summary
        run: |
          OVERALL_STATUS="${{ needs.quality-gates.result }}"

          if [[ "$OVERALL_STATUS" == "success" ]]; then
            echo "## ‚úÖ All quality checks passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Ready to merge." >> $GITHUB_STEP_SUMMARY
            
          else
            echo "## ‚ùå Quality checks failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Only show what actually failed with exact fix commands
            echo "**Fix these issues:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Application Server
            if [[ "${APPLICATION_SERVER_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Application Server**: ${APPLICATION_SERVER_VIOLATIONS:-0} Java files need formatting" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${APPLICATION_SERVER_BAD_FILES}" ]]; then
                echo "  <details><summary>üìÅ View files to fix</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                echo '  ```' >> $GITHUB_STEP_SUMMARY
                echo "  ${APPLICATION_SERVER_BAD_FILES}" | head -5 >> $GITHUB_STEP_SUMMARY
                echo '  ```' >> $GITHUB_STEP_SUMMARY
                echo "  </details>" >> $GITHUB_STEP_SUMMARY
              fi
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  npm run format:java:write" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Webapp React
            if [[ "${WEBAPP_REACT_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Webapp React**: Code quality issues" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${WEBAPP_REACT_TS_ERRORS}${WEBAPP_REACT_BIOME_ERRORS}" ]]; then
                echo "  <details><summary>üêõ View specific errors</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                if [[ -n "${WEBAPP_REACT_TS_ERRORS}" ]]; then
                  echo "  **TypeScript:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${WEBAPP_REACT_TS_ERRORS}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                if [[ -n "${WEBAPP_REACT_BIOME_ERRORS}" ]]; then
                  echo "  **Biome:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${WEBAPP_REACT_BIOME_ERRORS}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                echo "  </details>" >> $GITHUB_STEP_SUMMARY
              fi
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  cd webapp-react && npm run check -- --fix" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Intelligence Service
            if [[ "${INTELLIGENCE_SERVICE_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Intelligence Service**: ${INTELLIGENCE_SERVICE_ISSUES:-0} Python issues" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${INTELLIGENCE_SERVICE_BAD_FILES}${INTELLIGENCE_SERVICE_LINT_ERRORS}" ]]; then
                echo "  <details><summary>üêõ View specific errors</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                if [[ -n "${INTELLIGENCE_SERVICE_BAD_FILES}" ]]; then
                  echo "  **Files to format:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${INTELLIGENCE_SERVICE_BAD_FILES}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                if [[ -n "${INTELLIGENCE_SERVICE_LINT_ERRORS}" ]]; then
                  echo "  **Linting errors:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${INTELLIGENCE_SERVICE_LINT_ERRORS}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                echo "  </details>" >> $GITHUB_STEP_SUMMARY
              fi
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  cd server/intelligence-service && poetry run black . && poetry run flake8 ." >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Webhook Ingest
            if [[ "${WEBHOOK_INGEST_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Webhook Ingest**: ${WEBHOOK_INGEST_ISSUES:-0} Python issues" >> $GITHUB_STEP_SUMMARY
              if [[ -n "${WEBHOOK_INGEST_BAD_FILES}${WEBHOOK_INGEST_LINT_ERRORS}" ]]; then
                echo "  <details><summary>üêõ View specific errors</summary>" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
                if [[ -n "${WEBHOOK_INGEST_BAD_FILES}" ]]; then
                  echo "  **Files to format:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${WEBHOOK_INGEST_BAD_FILES}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                if [[ -n "${WEBHOOK_INGEST_LINT_ERRORS}" ]]; then
                  echo "  **Linting errors:**" >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                  echo "  ${WEBHOOK_INGEST_LINT_ERRORS}" | head -3 >> $GITHUB_STEP_SUMMARY
                  echo '  ```' >> $GITHUB_STEP_SUMMARY
                fi
                echo "  </details>" >> $GITHUB_STEP_SUMMARY
              fi
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  cd server/webhook-ingest && poetry run black . && poetry run flake8 ." >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # OpenAPI
            if [[ "${OPENAPI_STATUS:-unknown}" == "failed" ]]; then
              echo "- **OpenAPI**: Specs out of sync" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  npm run generate:api" >> $GITHUB_STEP_SUMMARY
              echo "  # OR add 'autocommit-openapi' label to this PR" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Database Schema  
            if [[ "${DB_SCHEMA_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Database Schema**: JPA entities changed" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  npm run db:draft-changelog" >> $GITHUB_STEP_SUMMARY
              echo "  # Then move the generated file to changelog/" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            # Database Docs
            if [[ "${DB_DOCS_STATUS:-unknown}" == "failed" ]]; then
              echo "- **Database Docs**: ERD outdated" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`bash" >> $GITHUB_STEP_SUMMARY
              echo "  npm run db:generate-erd-docs" >> $GITHUB_STEP_SUMMARY
              echo "  \`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run the commands above, commit, and push to retry." >> $GITHUB_STEP_SUMMARY
          fi
