name: Quality Gates

on:
  workflow_call:
    inputs:
      should_skip:
        description: "Whether to skip the workflow"
        required: false
        type: string
        default: "false"

jobs:
  # Quality gates with intelligent caching and error handling
  quality-gates:
    name: ${{ matrix.check }}
    runs-on: ubuntu-latest
    if: inputs.should_skip != 'true'
    timeout-minutes: ${{ contains(fromJSON('["database-schema-validation", "database-documentation-validation", "database-models-validation"]'), matrix.check) && 20 || 15 }}
    strategy:
      fail-fast: false
      matrix:
        check:
          [
            application-server-quality,
            webapp-quality,
            intelligence-service-quality,
            webhook-ingest-quality,
            openapi-validation,
            database-schema-validation,
            database-documentation-validation,
            database-models-validation,
          ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Advanced cache setup with fallback
      - name: Setup shared caches
        uses: ./.github/actions/setup-caches
        with:
          cache-type: ${{ matrix.check }}
          os: ${{ runner.os }}

      # Additional cache for webapp build artifacts
      - name: Cache webapp build artifacts
        if: matrix.check == 'webapp-quality'
        uses: actions/cache@v4
        with:
          path: |
            webapp/dist
            webapp/.vite
            webapp/node_modules/.vite
            webapp/node_modules/.cache
          key: ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp/package-lock.json', 'webapp/biome.json', 'webapp/tsconfig.json', 'webapp/vite.config.js', 'webapp/components.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp/package-lock.json', 'webapp/biome.json', 'webapp/tsconfig.json', 'webapp/vite.config.js', 'webapp/components.json') }}-
            ${{ runner.os }}-webapp-build-

      # application-server code quality and formatting
      - name: application-server formatting & static analysis
        if: matrix.check == 'application-server-quality'
        run: |
          echo "üîç Checking application-server code formatting..."

          # Always install to avoid half-restored caches
          npm ci --prefer-offline --no-audit

          if ! npm run format:java; then
            echo "‚ùå application-server formatting failed. Run: npm run format:java"
            exit 1
          fi

          echo "‚úÖ application-server formatting passed"

      # Webapp quality checks with comprehensive validation
      - name: Webapp quality & type checking
        if: matrix.check == 'webapp-quality'
        working-directory: ./webapp
        run: |
          echo "üîç Running webapp quality checks..."

          if [ ! -d "node_modules" ]; then
            npm ci --prefer-offline --no-audit --progress=false
          fi

          ISSUES_FOUND=()

          echo "üé® Running Biome checks..."
          if ! npm run check; then
            echo "‚ùå Biome checks failed"
            ISSUES_FOUND+=("Biome checks failed. Run: npm run check -- --write")
          else
            echo "‚úÖ Biome checks passed"
          fi

          echo "üìä Running TypeScript check..."
          if ! npx tsc --noEmit; then
            echo "‚ùå TypeScript check failed"
            ISSUES_FOUND+=("TypeScript compilation errors found")
          else
            echo "‚úÖ TypeScript check passed"
          fi

          echo "üèóÔ∏è Running build check..."
          if ! npm run build; then
            echo "‚ùå Build check failed"
            ISSUES_FOUND+=("Build failed")
          else
            echo "‚úÖ Build check passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Webapp quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ All webapp quality checks passed"

      # intelligence-service quality checks with comprehensive validation
      - name: intelligence-service quality & security analysis
        if: matrix.check == 'intelligence-service-quality'
        run: |
          echo "üîç Running intelligence-service quality checks..."
          cd server/intelligence-service

          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi

          ISSUES_FOUND=()

          echo "üé® Checking code formatting..."
          if ! poetry run black --check --diff .; then
            echo "‚ùå Black formatting failed"
            ISSUES_FOUND+=("Black formatting failed. Run: cd server/intelligence-service && poetry run black .")
          else
            echo "‚úÖ Black formatting passed"
          fi

          echo "üîç Running linting..."
          if ! poetry run flake8 . --statistics --count; then
            echo "‚ùå Flake8 linting failed Run: cd server/intelligence-service && poetry run flake8 ."
            ISSUES_FOUND+=("Flake8 linting failed")
          else
            echo "‚úÖ Flake8 linting passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå intelligence-service quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ intelligence-service quality checks passed"

      # webhook-ingest quality checks with comprehensive validation
      - name: webhook-ingest quality & security analysis
        if: matrix.check == 'webhook-ingest-quality'
        run: |
          echo "üîç Running webhook-ingest quality checks..."
          cd server/webhook-ingest

          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi

          ISSUES_FOUND=()

          echo "üé® Checking code formatting..."
          if ! poetry run black --check --diff .; then
            echo "‚ùå Black formatting failed"
            ISSUES_FOUND+=("Black formatting failed. Run: cd server/webhook-ingest && poetry run black .")
          else
            echo "‚úÖ Black formatting passed"
          fi

          echo "üîç Running linting..."
          if ! poetry run flake8 . --statistics --count; then
            echo "‚ùå Flake8 linting failed Run: cd server/webhook-ingest && poetry run flake8 ."
            ISSUES_FOUND+=("Flake8 linting failed")
          else
            echo "‚úÖ Flake8 linting passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå webhook-ingest quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ webhook-ingest quality checks passed"

      # OpenAPI validation with intelligent auto-commit
      - name: OpenAPI validation & synchronization
        if: matrix.check == 'openapi-validation'
        run: |
          echo "üîç Validating OpenAPI specifications and clients..."

          # Install all dependencies (always, to avoid cache drift)
          npm ci --prefer-offline --no-audit

          # Setup Python environments
          cd server/intelligence-service
          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi
          cd ../..

          # Setup application-server environment
          cd server/application-server
          if [ ! -d "target" ]; then
            mvn compile -DskipTests --quiet
          fi
          cd ../..

          echo "üîÑ Generating OpenAPI specifications and clients..."
          npm run generate:api

          # Check for any changes
          git add .

          if ! git diff --cached --quiet; then
            echo "‚ùå OpenAPI validation failed - changes detected"
            echo "Fix: Add the 'autocommit-openapi' label to this PR or run 'npm run generate:api' locally"
            exit 1
          else
            echo "‚úÖ OpenAPI validation passed - all specs are up to date"
          fi

      # Database schema validation - JPA entities vs committed migrations
      - name: Database schema validation
        if: matrix.check == 'database-schema-validation'
        run: |
          echo "üîç Validating JPA entities match committed migrations..."

          # Start PostgreSQL service for schema operations
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-schema \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-schema pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for schema operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi
          cd ../..

          # Check for schema drift between JPA entities and committed migrations
          echo "üìä Checking for schema drift..."
          if ! scripts/db-utils.sh draft-changelog; then
            echo "‚ùå Failed to generate draft changelog"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-schema && docker rm postgres-schema

          # Check results
          if [ -f "server/application-server/src/main/resources/db/changelog_new.xml" ]; then
            echo "‚ùå Schema drift detected. Run: npm run db:draft-changelog and follow the documentation"
            echo "Generated migration:"
            cat server/application-server/src/main/resources/db/changelog_new.xml
            exit 1
          else
            echo "‚úÖ Schema validation passed"
          fi

      # Database documentation validation - ERD matches migration-based schema
      - name: Database documentation validation
        if: matrix.check == 'database-documentation-validation'
        run: |
          echo "üìä Validating ERD documentation matches migration-based schema..."

          # Start PostgreSQL service for ERD generation
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-erd \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-erd pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for ERD operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi
          cd ../..

          # Generate ERD documentation from committed migration-based schema
          echo "üìà Generating ERD from committed migration-based schema..."
          if ! scripts/db-utils.sh generate-erd; then
            echo "‚ùå Failed to generate ERD documentation"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-erd && docker rm postgres-erd

          # Check if ERD documentation is up to date
          git add docs/dev/database/schema.mmd

          if ! git diff --cached --quiet docs/dev/database/schema.mmd; then
            echo "‚ùå ERD documentation validation failed - outdated ERD"
            echo "Fix: npm run db:generate-erd-docs"
            exit 1
          else
            echo "‚úÖ ERD documentation validation passed (up-to-date with committed migrations)"
          fi

      # Database models validation - SQLAlchemy models match committed migrations
      - name: Database models validation
        if: matrix.check == 'database-models-validation'
        run: |
          echo "üîç Validating SQLAlchemy models match committed migrations..."

          # Start PostgreSQL service for model operations
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-models \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-models pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for schema operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-models && docker rm postgres-models
            exit 1
          fi
          cd ../..

          # Generate SQLAlchemy models from committed migration-based schema
          echo "üìä Generating SQLAlchemy models from committed migration-based schema..."
          if ! scripts/db-utils.sh generate-models-intelligence-service; then
            echo "‚ùå Failed to generate SQLAlchemy models"
            docker stop postgres-models && docker rm postgres-models
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-models && docker rm postgres-models

          # Check if generated models match committed versions
          if ! git diff --quiet server/intelligence-service/app/db/models_gen.py; then
            echo "‚ùå SQLAlchemy models validation failed - models are out of sync"
            echo "Generated models differ from committed version:"
            git diff server/intelligence-service/app/db/models_gen.py
            echo ""
            echo "Fix: npm run db:generate-models:intelligence-service"
            exit 1
          else
            echo "‚úÖ SQLAlchemy models validation passed (models are up-to-date)"
          fi
