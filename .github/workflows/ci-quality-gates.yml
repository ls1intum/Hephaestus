name: Quality Gates

on:
  workflow_call:
    inputs:
      should_skip:
        description: "Whether to skip the workflow"
        required: false
        type: string
        default: "false"

jobs:
  # Quality gates with intelligent caching and error handling
  quality-gates:
    name: ${{ matrix.check }}
    runs-on: ubuntu-latest
    if: inputs.should_skip != 'true'
    timeout-minutes: ${{ contains(fromJSON('["database-schema-validation", "database-documentation-validation", "database-models-validation"]'), matrix.check) && 20 || 15 }}
    strategy:
      fail-fast: false
      matrix:
        check:
          [
            application-server-quality,
            webapp-quality,
            intelligence-service-quality,
            webhook-ingest-quality,
            openapi-validation,
            database-schema-validation,
            database-documentation-validation,
            database-models-validation,
          ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Ensure a stable Node/npm toolchain and proper npm caching
      - name: Setup Node.js (LTS) and npm cache
        uses: actions/setup-node@v4
        with:
          node-version-file: '.node-version'
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            webapp/package-lock.json
            server/intelligence-service/package-lock.json


      # Advanced cache setup with fallback
      - name: Setup shared caches
        uses: ./.github/actions/setup-caches
        with:
          cache-type: ${{ matrix.check }}
          os: ${{ runner.os }}

      # Additional cache for webapp build artifacts
      - name: Cache webapp build artifacts
        if: matrix.check == 'webapp-quality'
        uses: actions/cache@v4
        with:
          path: |
            webapp/dist
            webapp/.vite
            webapp/node_modules/.vite
            webapp/node_modules/.cache
          key: ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp/package-lock.json', 'webapp/biome.json', 'webapp/tsconfig.json', 'webapp/vite.config.js', 'webapp/components.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-webapp-build-${{ hashFiles('package-lock.json', 'webapp/package-lock.json', 'webapp/biome.json', 'webapp/tsconfig.json', 'webapp/vite.config.js', 'webapp/components.json') }}-
            ${{ runner.os }}-webapp-build-

      # application-server code quality and formatting
      - name: application-server formatting & static analysis
        if: matrix.check == 'application-server-quality'
        run: |
          echo "üîç Checking application-server code formatting..."

          # Always install to avoid half-restored caches
          npm ci --prefer-offline --no-audit

          if ! npm run format:java; then
            echo "‚ùå application-server formatting failed. Run: npm run format:java"
            exit 1
          fi

          echo "‚úÖ application-server formatting passed"

      # Webapp quality checks with comprehensive validation
      - name: Webapp quality & type checking
        if: matrix.check == 'webapp-quality'
        working-directory: ./webapp
        run: |
          echo "üîç Running webapp quality checks..."

          # Always install at repo root to ensure hoisted deps (incl. platform optionals) are present
          cd ..
          rm -rf node_modules
          npm ci --workspaces --include=dev --include=optional --no-audit --progress=false
          # Optional: report native package presence (warnings only) at the hoist root
          npm ls @rollup/rollup-linux-x64-gnu || echo "‚ö†Ô∏è rollup native not installed yet"
          npm ls @biomejs/cli-linux-x64 || echo "‚ö†Ô∏è biome binary not installed yet (will try npx fallback)"
          # Force-install platform binaries deterministically
          node scripts/install-platform-binaries.mjs
          cd webapp

          ISSUES_FOUND=()

          echo "üé® Running Biome checks..."
          if ! npm run check; then
            echo "‚ùå Biome checks failed (attempting npx fallback to platform-specific CLI)..."
            BIOME_VER=$(node -p "require('./package.json').devDependencies['@biomejs/biome'] || ''")
            if ! npx -y @biomejs/cli-linux-x64@${BIOME_VER:-latest} check; then
              ISSUES_FOUND+=("Biome checks failed. Run: npm run check -- --write")
            else
              echo "‚úÖ Biome checks passed via pinned platform CLI fallback (${BIOME_VER:-latest})"
            fi
          else
            echo "‚úÖ Biome checks passed"
          fi

          echo "üìä Running TypeScript check..."
          if ! npx tsc --noEmit; then
            echo "‚ùå TypeScript check failed"
            ISSUES_FOUND+=("TypeScript compilation errors found")
          else
            echo "‚úÖ TypeScript check passed"
          fi

          echo "üèóÔ∏è Running build check..."
          if ! npm run build; then
            echo "‚ùå Build failed (retrying after clean reinstall at root to pull any missed optionals)..."
            cd ..
            rm -rf node_modules
            npm ci --workspaces --include=dev --include=optional --no-audit --progress=false
            cd webapp
            if ! npm run build; then
              ISSUES_FOUND+=("Build failed")
            else
              echo "‚úÖ Build passed after reinstall"
            fi
          else
            echo "‚úÖ Build check passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Webapp quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ All webapp quality checks passed"

      - name: Docs quality gate
        if: matrix.check == 'docs-quality'
        working-directory: ./docs
        run: |
          echo "üìö Running docs quality checks..."

          npm ci --no-audit --progress=false

          ISSUES_FOUND=()

          echo "üìù TypeScript check..."
          if ! npm run typecheck; then
            ISSUES_FOUND+=("TypeScript errors in docs config")
          else
            echo "‚úÖ TypeScript check passed"
          fi

          echo "üìã Markdown style check..."
          if ! npm run lint:md; then
            ISSUES_FOUND+=("Markdown style issues - run: npm run docs:lint:md")
          else
            echo "‚úÖ Markdown style check passed"
          fi

          echo "üèóÔ∏è Building documentation (strict mode: broken links will fail)..."
          if ! npm run build; then
            ISSUES_FOUND+=("Docs build failed - check for broken links or markdown errors")
          else
            echo "‚úÖ Docs build passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Docs quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ All docs quality checks passed"

      # intelligence-service quality checks with comprehensive validation
      - name: intelligence-service quality & type checking
        if: matrix.check == 'intelligence-service-quality'
        working-directory: ./server/intelligence-service
        run: |
          echo "üîç Running intelligence-service quality checks..."
          npm ci --no-audit --progress=false

          ISSUES_FOUND=()

          echo "üé® Linting (Biome)..."
          if ! npm run check; then
            echo "‚ùå Biome check failed"
            ISSUES_FOUND+=("Biome check failed. Run: cd server/intelligence-service && npm run check -- --fix")
          else
            echo "‚úÖ Biome linting passed"
          fi

          echo "üìä TypeScript typecheck..."
          if ! npm run typecheck; then
            echo "‚ùå TypeScript typecheck failed"
            ISSUES_FOUND+=("TypeScript typecheck failed. Run: cd server/intelligence-service && npm run typecheck")
          else
            echo "‚úÖ TypeScript typecheck passed"
          fi

          echo "üß™ Build check..."
          if ! npm run build; then
            echo "‚ùå Build failed"
            ISSUES_FOUND+=("Build failed. Run: cd server/intelligence-service && npm run build")
          else
            echo "‚úÖ Build passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå intelligence-service quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ intelligence-service quality checks passed"

      # webhook-ingest quality checks with comprehensive validation
      - name: webhook-ingest quality & security analysis
        if: matrix.check == 'webhook-ingest-quality'
        run: |
          echo "üîç Running webhook-ingest quality checks..."
          cd server/webhook-ingest

          if [ ! -d ".venv" ]; then
            poetry install --no-interaction --no-root
          fi

          ISSUES_FOUND=()

          echo "üé® Checking code formatting..."
          if ! poetry run black --check --diff .; then
            echo "‚ùå Black formatting failed"
            ISSUES_FOUND+=("Black formatting failed. Run: cd server/webhook-ingest && poetry run black .")
          else
            echo "‚úÖ Black formatting passed"
          fi

          echo "üîç Running linting..."
          if ! poetry run flake8 . --statistics --count; then
            echo "‚ùå Flake8 linting failed Run: cd server/webhook-ingest && poetry run flake8 ."
            ISSUES_FOUND+=("Flake8 linting failed")
          else
            echo "‚úÖ Flake8 linting passed"
          fi

          if [ ${#ISSUES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå webhook-ingest quality issues found:"
            for issue in "${ISSUES_FOUND[@]}"; do
              echo "  ‚Ä¢ $issue"
            done
            exit 1
          fi

          echo "‚úÖ webhook-ingest quality checks passed"

      # OpenAPI validation with intelligent auto-commit
      - name: OpenAPI validation & synchronization
        if: matrix.check == 'openapi-validation'
        env:
          # Required for intelligence-service OpenAPI export (uses fake provider, no actual API calls)
          DATABASE_URL: postgresql://fake:fake@localhost:5432/fake
          MODEL_NAME: fake:model
          DETECTION_MODEL_NAME: fake:model
        run: |
          echo "üîç Validating OpenAPI specifications and clients..."

          # Install all dependencies including workspaces (always, to avoid cache drift)
          # The root npm ci handles all workspaces including intelligence-service
          npm ci --prefer-offline --no-audit

          # Setup application-server environment
          cd server/application-server
          if [ ! -d "target" ]; then
            mvn compile -DskipTests --quiet
          fi
          cd ../..

          echo "üîÑ Generating OpenAPI specifications and clients..."
          npm run generate:api

          # Check for any changes
          git add .

          if ! git diff --cached --quiet; then
            echo "‚ùå OpenAPI validation failed - changes detected"
            echo "Fix: Add the 'autocommit-openapi' label to this PR or run 'npm run generate:api' locally"
            exit 1
          else
            echo "‚úÖ OpenAPI validation passed - all specs are up to date"
          fi

      # Database schema validation - JPA entities vs committed migrations
      - name: Database schema validation
        if: matrix.check == 'database-schema-validation'
        run: |
          echo "üîç Validating JPA entities match committed migrations..."

          # Start PostgreSQL service for schema operations
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-schema \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-schema pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for schema operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi
          cd ../..

          # Check for schema drift between JPA entities and committed migrations
          echo "üìä Checking for schema drift..."
          if ! scripts/db-utils.sh draft-changelog; then
            echo "‚ùå Failed to generate draft changelog"
            docker stop postgres-schema && docker rm postgres-schema
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-schema && docker rm postgres-schema

          # Check results
          if [ -f "server/application-server/src/main/resources/db/changelog_new.xml" ]; then
            echo "‚ùå Schema drift detected. Run: npm run db:draft-changelog and follow the documentation"
            echo "Generated migration:"
            cat server/application-server/src/main/resources/db/changelog_new.xml
            exit 1
          else
            echo "‚úÖ Schema validation passed"
          fi

      # Database documentation validation - ERD matches migration-based schema
      - name: Database documentation validation
        if: matrix.check == 'database-documentation-validation'
        run: |
          echo "üìä Validating ERD documentation matches migration-based schema..."

          # Start PostgreSQL service for ERD generation
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-erd \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-erd pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for ERD operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi
          cd ../..

          # Generate ERD documentation from committed migration-based schema
          echo "üìà Generating ERD from committed migration-based schema..."
          if ! scripts/db-utils.sh generate-erd; then
            echo "‚ùå Failed to generate ERD documentation"
            docker stop postgres-erd && docker rm postgres-erd
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-erd && docker rm postgres-erd

          # Check if ERD documentation is up to date
          git add docs/contributor/erd/schema.mmd

          if ! git diff --cached --quiet docs/contributor/erd/schema.mmd; then
            echo "‚ùå ERD documentation validation failed - outdated ERD"
            echo "Fix: npm run db:generate-erd-docs"
            exit 1
          else
            echo "‚úÖ ERD documentation validation passed (up-to-date with committed migrations)"
          fi

      # Database models validation - Drizzle ORM models match committed migrations
      - name: Database models validation
        if: matrix.check == 'database-models-validation'
        run: |
          echo "üîç Validating intelligence-service DB models match committed migrations..."

          # Install all dependencies including workspaces for intelligence-service tooling
          npm ci --prefer-offline --no-audit

          # Start PostgreSQL service for model operations
          echo "üêò Starting PostgreSQL service..."
          docker run -d \
            --name postgres-models \
            -e POSTGRES_DB=hephaestus \
            -e POSTGRES_PASSWORD=root \
            -e POSTGRES_USER=root \
            -p 5432:5432 \
            --health-cmd="pg_isready" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:16

          # Wait for PostgreSQL to be ready
          echo "‚è≥ Waiting for PostgreSQL..."
          until docker exec postgres-models pg_isready -U root -d hephaestus; do
            sleep 2
          done

          # Set environment variables for database connection
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/hephaestus"
          export SPRING_DATASOURCE_USERNAME="root"
          export SPRING_DATASOURCE_PASSWORD="root"

          # Build application-server for schema operations
          echo "üèóÔ∏è Building application-server..."
          cd server/application-server
          if ! mvn compile -DskipTests --quiet; then
            echo "‚ùå Failed to build application-server"
            docker stop postgres-models && docker rm postgres-models
            exit 1
          fi
          cd ../..

          # Generate intelligence-service DB models from committed migration-based schema
          echo "üìä Generating intelligence-service DB models from committed migration-based schema..."
          if ! scripts/db-utils.sh generate-models-intelligence-service; then
            echo "‚ùå Failed to generate intelligence-service DB models"
            docker stop postgres-models && docker rm postgres-models
            exit 1
          fi

          # Clean up PostgreSQL container
          docker stop postgres-models && docker rm postgres-models

          # Check if generated models match committed versions
          git add server/intelligence-service/src/shared/db/schema.ts server/intelligence-service/src/shared/db/relations.ts

          if ! git diff --cached --quiet server/intelligence-service/src/shared/db/schema.ts server/intelligence-service/src/shared/db/relations.ts; then
            echo "‚ùå Intelligence-service DB models validation failed - models are out of sync"
            echo "Generated models differ from committed version:"
            git diff --cached server/intelligence-service/src/shared/db/schema.ts server/intelligence-service/src/shared/db/relations.ts
            echo ""
            echo "Fix: npm run db:generate-models:intelligence-service"
            exit 1
          else
            echo "‚úÖ Intelligence-service DB models validation passed (models are up-to-date)"
          fi
