# Reusable Docker build workflow with registry-based caching
# This is a local version of ls1intum/.github's workflow with caching support
# to significantly speed up CI builds.
#
# Cache strategy: Registry cache (ghcr.io)
# - Stores cache layers in a separate cache image tag (e.g., image:cache)
# - Works across branches (PRs can use main's cache)
# - No size limits (unlike GitHub Actions cache which is 10GB per repo)
# - Persists indefinitely (not evicted like GHA cache)
#
# Performance optimizations:
# - No QEMU: Builds run natively (amd64 on amd64 runner, arm64 on arm64 runner)
# - Docker Hub login: Avoids rate limits on base image metadata resolution
#   (unauthenticated requests can add 2+ minutes of delay per build)
# - Registry cache: Layers are cached in ghcr.io, avoiding rebuild of unchanged layers

name: Docker Build (Cached)

on:
  workflow_call:
    inputs:
      image-name:
        type: string
        required: true
        description: "Full image name (e.g., ls1intum/hephaestus/webapp)"
      docker-file:
        type: string
        required: true
        description: "Path to Dockerfile"
      docker-context:
        type: string
        default: "."
        description: "Docker build context"
      registry:
        type: string
        default: "ghcr.io"
        description: "Container registry"
      tags:
        type: string
        required: false
        description: "Additional tags (one per line)"
      labels:
        type: string
        required: false
        description: "OCI labels"
      build-args:
        type: string
        required: false
        description: "Build arguments"
      # Docker Hub credentials for avoiding rate limits
      # These must be passed from the caller since vars aren't inherited
      dockerhub-username:
        type: string
        required: false
        description: "Docker Hub username for authentication"
    secrets:
      dockerhub-token:
        required: false
        description: "Docker Hub access token"

jobs:
  build:
    name: Build ${{ matrix.platform }} Docker Image
    strategy:
      fail-fast: true
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-24.04
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 1

      # Note: QEMU is NOT needed because we build natively:
      # - linux/amd64 builds on ubuntu-24.04 (x86_64)
      # - linux/arm64 builds on ubuntu-24.04-arm (aarch64)
      # Removing QEMU saves ~0.5s per build and reduces complexity.

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3
        with:
          buildkitd-config-inline: |
            [registry."docker.io"]
              mirrors = ["https://docker-mirror.ase.in.tum.de:8765"]

      # Login to Docker Hub to avoid rate limits on base image metadata resolution.
      # Without authentication, Docker Hub throttles metadata requests, adding 2+ minutes
      # of delay per build. With authentication, requests are prioritized.
      # This step is optional - if credentials aren't provided, builds still work (just slower).
      - name: Log in to Docker Hub
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        if: ${{ inputs.dockerhub-username != '' }}
        with:
          username: ${{ inputs.dockerhub-username }}
          password: ${{ secrets.dockerhub-token }}

      # Pre-pull base images BEFORE buildx starts its container.
      # The docker-container driver creates a separate BuildKit container that doesn't
      # inherit Docker Hub credentials, causing 2+ minute metadata resolution delays.
      # By pulling on the host first, the images and metadata are cached in the Docker daemon,
      # and buildx can access them through the Docker socket mount.
      - name: Pre-pull base images for cache
        if: ${{ inputs.dockerhub-username != '' }}
        run: |
          # Extract base images from Dockerfile and pull them
          # This populates the local Docker cache with metadata, avoiding rate limits in buildx
          grep -E '^FROM ' ${{ inputs.docker-file }} | sed 's/FROM //' | sed 's/ AS .*//' | while read -r image; do
            echo "Pre-pulling: $image"
            docker pull "$image" --quiet || echo "Warning: Could not pre-pull $image (may be build stage)"
          done

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
        with:
          images: ${{ inputs.registry }}/${{ inputs.image-name }}

      - name: Prepare platform pair
        id: prep
        run: |
          platform=${{ matrix.platform }}
          echo "platform_pair=${platform//\//-}" >> $GITHUB_OUTPUT
          image="${{ inputs.image-name }}"
          echo "image_name=${image//\//-}" >> $GITHUB_OUTPUT

      # Build with registry cache
      # - cache-from: Pull cache from registry (main branch cache + current branch)
      # - cache-to: Push cache to registry (only for non-PR builds to avoid cache pollution)
      - name: Build and push
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6
        with:
          context: ${{ inputs.docker-context }}
          file: ${{ inputs.docker-file }}
          platforms: ${{ matrix.platform }}
          build-args: ${{ inputs.build-args }}
          labels: ${{ steps.meta.outputs.labels }}
          outputs: type=image,"name=${{ inputs.registry }}/${{ inputs.image-name }}",push-by-digest=true,name-canonical=true,push=true
          # Registry cache: stores cache in ghcr.io alongside images
          # Use main branch cache as fallback, then current ref
          cache-from: |
            type=registry,ref=${{ inputs.registry }}/${{ inputs.image-name }}:cache-${{ steps.prep.outputs.platform_pair }}
            type=registry,ref=${{ inputs.registry }}/${{ inputs.image-name }}:cache-main-${{ steps.prep.outputs.platform_pair }}
          # Only write cache on main branch or when explicitly building (not PRs)
          # This prevents cache pollution from experimental PR changes
          cache-to: ${{ github.ref == 'refs/heads/main' && format('type=registry,ref={0}/{1}:cache-main-{2},mode=max', inputs.registry, inputs.image-name, steps.prep.outputs.platform_pair) || format('type=registry,ref={0}/{1}:cache-{2},mode=max', inputs.registry, inputs.image-name, steps.prep.outputs.platform_pair) }}

      - name: Export digest
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: digests-${{ steps.prep.outputs.image_name }}-${{ steps.prep.outputs.platform_pair }}
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    name: Create manifest
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Prepare
        id: prep
        run: |
          image="${{ inputs.image-name }}"
          echo "image_name=${image//\//-}" >> $GITHUB_OUTPUT

      - name: Download digests
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: digests-${{ steps.prep.outputs.image_name }}-*
          merge-multiple: true

      - name: Log in to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Prepare tag configuration
        id: tags
        run: |
          {
            echo "tags<<EOF"
            # Default tags
            echo "type=raw,value=latest,enable={{is_default_branch}}"
            echo "type=ref,event=branch"
            echo "type=ref,event=pr"
            echo "type=sha,prefix="
            # Custom tags from input
            if [ -n "${{ inputs.tags }}" ]; then
              echo "${{ inputs.tags }}" | while IFS= read -r line || [[ -n "$line" ]]; do
                line=$(echo "$line" | xargs)
                if [ -n "$line" ]; then
                  if [[ "$line" == *"type="* ]]; then
                    echo "$line"
                  else
                    IFS=',' read -ra TAG_ARRAY <<< "$line"
                    for tag in "${TAG_ARRAY[@]}"; do
                      tag=$(echo "$tag" | xargs)
                      if [ -n "$tag" ]; then
                        echo "type=raw,value=${tag}"
                      fi
                    done
                  fi
                fi
              done
            fi
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5
        with:
          images: ${{ inputs.registry }}/${{ inputs.image-name }}
          tags: ${{ steps.tags.outputs.tags }}
          labels: ${{ inputs.labels }}

      - name: Create manifest and push
        working-directory: ${{ runner.temp }}/digests
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
            $(printf '${{ inputs.registry }}/${{ inputs.image-name }}@sha256:%s ' *)

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.version }}
