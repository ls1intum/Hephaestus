#!/usr/bin/env -S node --no-warnings
/**
 * Post-introspection patcher for generated schema.ts
 * - Adds a ts-nocheck pragma to silence circular/self-reference type errors.
 * - Cleans unused imports from drizzle-orm/pg-core; sorts remaining names.
 * - Drops identity minValue/maxValue metadata to avoid precision-loss noise.
 * - Removes unused `sql` import from drizzle-orm if not referenced.
 */
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const schemaPath = path.resolve(__dirname, "../drizzle/schema.ts");

if (!fs.existsSync(schemaPath)) {
	console.error(`[post-introspect] schema.ts not found at ${schemaPath}`);
	process.exit(0);
}

let content = fs.readFileSync(schemaPath, "utf8");

// Prepend pragmas if not already present
const headerBanner = `// @ts-nocheck\n// generated by drizzle-kit; ts diagnostics suppressed for generated types\n`;
if (!content.startsWith("// @ts-nocheck")) {
	content = headerBanner + content;
}

// Trim unused items in the import from drizzle-orm/pg-core if they aren't referenced
const importRegex = /import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/;
const match = content.match(importRegex);
if (match) {
	const imported = match[1]
		.split(",")
		.map((s) => s.trim())
		.filter(Boolean);
	const used = new Set<string>();
	for (const name of imported) {
		const bare = name.replace(/^type\s+/, "");
		const re = new RegExp(`\\b${bare}\\b`, "m");
		if (re.test(content)) used.add(name);
	}
	const cleaned = imported
		.filter((n) => used.has(n))
		.sort((a, b) => a.localeCompare(b));
	if (cleaned.length && cleaned.length !== imported.length) {
		content = content.replace(
			importRegex,
			`import { ${cleaned.join(", ")} } from "drizzle-orm/pg-core"`,
		);
	}
}

// Remove gigantic numeric literals in identity metadata to avoid precision-loss warnings
content = content
	.replace(/,\s*minValue:\s*[^,}\n]+/g, "")
	.replace(/,\s*maxValue:\s*[^,}\n]+/g, "")
	.replace(/minValue:\s*[^,}\n]+,\s*/g, "")
	.replace(/maxValue:\s*[^,}\n]+,\s*/g, "");

// Always remove `import { sql } from "drizzle-orm"` in generated schema; drizzle rarely uses it and it trips linters
content = content.replace(
	/\n?import\s*\{\s*sql\s*\}\s*from\s*"drizzle-orm"\s*;?\s*\n?/g,
	"\n",
);
content = content.replace(
	/\n?import\s*\{\s*sql\s*\}\s*from\s*'drizzle-orm'\s*;?\s*\n?/g,
	"\n",
);
content = content.replace(
	/^\s*import\s*\{\s*sql\s*\}\s*from\s*["']drizzle-orm["']\s*;?\s*$(?:\r?\n)?/gm,
	"",
);

// Also ensure AnyPgColumn is not left in imports if unused
content = content.replace(
	/import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/,
	(_full, inner: string) => {
		const parts = inner
			.split(",")
			.map((s) => s.trim())
			.filter(Boolean);
		const filtered = parts.filter((p) => !/^type\s+AnyPgColumn$/.test(p));
		return `import { ${filtered.join(", ")} } from "drizzle-orm/pg-core"`;
	},
);

// Remove Liquibase tables `databasechangelog` and `databasechangeloglock`
// This removes the entire pgTable block including its body and any builder callback.
// Strategy: match `export const <name> = pgTable("<name>", { ... })` optionally followed by `, (table) => [...]` and trailing semicolon.
const removePgTableBlock = (name: string) => {
	// A reasonably safe regex using non-greedy matching and balanced braces heuristics per block lines.
	const tableRegex = new RegExp(
		// export const name = pgTable("name",
		String.raw`\nexport\s+const\s+${name}\s*=\s*pgTable\(\s*(["'])${name}\1\s*,\s*\{[\s\S]*?\}\s*\)` +
			// optional table callback e.g., , (table) => [ ... ]
			String.raw`(?:\s*,\s*\([^)]*\)\s*=>\s*\[[\s\S]*?\]\s*)?` +
			// optional trailing semicolon and newlines
			String.raw`\s*;?\n`,
		"g",
	);
	content = content.replace(tableRegex, "\n");
};

removePgTableBlock("databasechangelog");
removePgTableBlock("databasechangeloglock");

fs.writeFileSync(schemaPath, content, "utf8");

// Move ./drizzle/relations.ts to ./src/db/relations.ts (overwrite if exists)
const relationsSrc = path.resolve(__dirname, "../drizzle/relations.ts");
const relationsDst = path.resolve(__dirname, "../src/db/relations.ts");
if (fs.existsSync(relationsSrc)) {
	fs.copyFileSync(relationsSrc, relationsDst);
	fs.unlinkSync(relationsSrc);
	// Also remove the ./drizzle directory if it exists (remove recursively to handle .DS_Store or leftover files)
	const drizzleDir = path.resolve(__dirname, "../drizzle");
	if (fs.existsSync(drizzleDir)) {
		try {
			fs.rmSync(drizzleDir, { recursive: true, force: true });
		} catch (e) {
			console.warn(`[post-introspect] Failed to remove ${drizzleDir}:`, e);
		}
	}
}

// Move ./drizzle/schema.ts to ./src/db/schema.ts (overwrite if exists)
const schemaSrc = path.resolve(__dirname, "../drizzle/schema.ts");
const schemaDst = path.resolve(__dirname, "../src/db/schema.ts");
if (fs.existsSync(schemaSrc)) {
	fs.copyFileSync(schemaSrc, schemaDst);
	fs.unlinkSync(schemaSrc);
	// Also remove the ./drizzle directory if it exists (remove recursively to handle .DS_Store or leftover files)
	const drizzleDir = path.resolve(__dirname, "../drizzle");
	if (fs.existsSync(drizzleDir)) {
		try {
			fs.rmSync(drizzleDir, { recursive: true, force: true });
		} catch (e) {
			console.warn(`[post-introspect] Failed to remove ${drizzleDir}:`, e);
		}
	}
}

// Ensure ../drizzle directory is removed even if residual files (e.g., .DS_Store) exist
const drizzleDir = path.resolve(__dirname, "../drizzle");
if (fs.existsSync(drizzleDir)) {
	try {
		fs.rmSync(drizzleDir, { recursive: true, force: true });
	} catch (e) {
		console.warn(`[post-introspect] Final remove failed for ${drizzleDir}:`, e);
	}
}

console.log("[post-introspect] Patched schema.ts with ts-nocheck and cleanup");
