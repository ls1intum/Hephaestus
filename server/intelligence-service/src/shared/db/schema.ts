// @ts-nocheck
// generated by drizzle-kit; ts diagnostics suppressed for generated types

import { sql } from "drizzle-orm";
import {
	bigint,
	boolean,
	check,
	date,
	doublePrecision,
	foreignKey,
	index,
	integer,
	jsonb,
	pgTable,
	primaryKey,
	text,
	timestamp,
	unique,
	uniqueIndex,
	uuid,
	varchar,
} from "drizzle-orm/pg-core";

export const activityEvent = pgTable(
	"activity_event",
	{
		id: uuid().primaryKey().notNull(),
		eventKey: varchar("event_key", { length: 255 }).notNull(),
		eventType: varchar("event_type", { length: 64 }).notNull(),
		occurredAt: timestamp("occurred_at", { withTimezone: true, mode: "string" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		actorId: bigint("actor_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		targetType: varchar("target_type", { length: 32 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		targetId: bigint("target_id", { mode: "number" }),
		xp: doublePrecision().default(0).notNull(),
		ingestedAt: timestamp("ingested_at", { withTimezone: true, mode: "string" })
			.defaultNow()
			.notNull(),
	},
	(table) => [
		index("idx_activity_event_actor_occurred").using(
			"btree",
			table.actorId.asc().nullsLast(),
			table.occurredAt.desc().nullsFirst(),
		),
		index("idx_activity_event_actor_time").using(
			"btree",
			table.actorId.asc().nullsLast(),
			table.occurredAt.asc().nullsLast(),
		),
		index("idx_activity_event_leaderboard").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.actorId.asc().nullsLast(),
			table.occurredAt.asc().nullsLast(),
		),
		index("idx_activity_event_leaderboard_covering").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.occurredAt.desc().nullsFirst(),
			table.actorId.asc().nullsLast(),
			table.xp.asc().nullsLast(),
		),
		index("idx_activity_event_target").using(
			"btree",
			table.targetId.asc().nullsLast(),
			table.targetType.asc().nullsLast(),
		),
		index("idx_activity_event_type_time").using(
			"btree",
			table.eventType.asc().nullsLast(),
			table.occurredAt.asc().nullsLast(),
		),
		index("idx_activity_event_workspace_actor_occurred").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.actorId.asc().nullsLast(),
			table.occurredAt.desc().nullsFirst(),
		),
		index("idx_activity_event_workspace_occurred").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.occurredAt.desc().nullsFirst(),
		),
		index("idx_activity_event_workspace_time").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.occurredAt.asc().nullsLast(),
		),
		index("idx_activity_event_xp_lookup").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
			table.targetType.asc().nullsLast(),
			table.targetId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_activity_event_workspace",
		}),
		foreignKey({
			columns: [table.actorId],
			foreignColumns: [user.id],
			name: "fk_activity_event_actor",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_activity_event_repository",
		}).onDelete("set null"),
		unique("uk_activity_event_workspace_key").on(table.eventKey, table.workspaceId),
		check("chk_activity_event_xp_non_negative", sql`xp >= (0)::double precision`),
	],
);

export const badPracticeDetection = pgTable(
	"bad_practice_detection",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "bad_practice_detection_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		detectedAt: timestamp("detected_at", { precision: 6, withTimezone: true, mode: "string" }),
		traceId: varchar("trace_id", { length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullrequestId: bigint("pullrequest_id", { mode: "number" }),
		summary: text(),
	},
	(table) => [
		foreignKey({
			columns: [table.pullrequestId],
			foreignColumns: [issue.id],
			name: "FKhk2vrsr2rdq2gb3cjnvieh3nw",
		}),
	],
);

export const badPracticeFeedback = pgTable(
	"bad_practice_feedback",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "bad_practice_feedback_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		type: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestBadPracticeId: bigint("pull_request_bad_practice_id", { mode: "number" }),
		createdAt: timestamp("created_at", { precision: 6, withTimezone: true, mode: "string" }),
		explanation: text(),
	},
	(table) => [
		foreignKey({
			columns: [table.pullRequestBadPracticeId],
			foreignColumns: [pullRequestBadPractice.id],
			name: "FK34k5tg4qb6gy4g7tn9q8uhogl",
		}),
	],
);

export const chatMessage = pgTable(
	"chat_message",
	{
		id: uuid().primaryKey().notNull(),
		createdAt: timestamp("created_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}).notNull(),
		metadata: jsonb(),
		role: varchar({ length: 16 }).notNull(),
		parentMessageId: uuid("parent_message_id"),
		threadId: uuid("thread_id").notNull(),
	},
	(table) => [
		index("idx_chat_message_thread_created").using(
			"btree",
			table.threadId.asc().nullsLast(),
			table.createdAt.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.threadId],
			foreignColumns: [chatThread.id],
			name: "FK8s34d909gxc4xrlvml8gag9kh",
		}),
		foreignKey({
			columns: [table.parentMessageId],
			foreignColumns: [table.id],
			name: "FKd0fewjs0l68rq2bww9h8o4cmb",
		}),
	],
);

export const chatMessagePart = pgTable(
	"chat_message_part",
	{
		messageId: uuid("message_id").notNull(),
		orderIndex: integer("order_index").notNull(),
		content: jsonb(),
		originalType: varchar("original_type", { length: 128 }),
		type: varchar({ length: 32 }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.messageId],
			foreignColumns: [chatMessage.id],
			name: "FKkfle3niou3f9r63mc3u8vi1na",
		}),
		primaryKey({ columns: [table.messageId, table.orderIndex], name: "chat_message_partPK" }),
	],
);

export const chatMessageVote = pgTable("chat_message_vote", {
	messageId: uuid("message_id").primaryKey().notNull(),
	createdAt: timestamp("created_at", {
		precision: 6,
		withTimezone: true,
		mode: "string",
	}).notNull(),
	isUpvoted: boolean("is_upvoted").notNull(),
	updatedAt: timestamp("updated_at", {
		precision: 6,
		withTimezone: true,
		mode: "string",
	}).notNull(),
});

export const chatThread = pgTable(
	"chat_thread",
	{
		id: uuid().primaryKey().notNull(),
		createdAt: timestamp("created_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}).notNull(),
		title: text(),
		selectedLeafMessageId: uuid("selected_leaf_message_id"),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_chat_thread_workspace_id").using("btree", table.workspaceId.asc().nullsLast()),
		foreignKey({
			columns: [table.selectedLeafMessageId],
			foreignColumns: [chatMessage.id],
			name: "FK34beodgwi0g7kn66svlk4hlfr",
		}),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "FKikdxlx9viomcwrgxj7fbyfsew",
		}),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_chat_thread_workspace",
		}).onDelete("cascade"),
		unique("uc_chat_threadselected_leaf_message_id_col").on(table.selectedLeafMessageId),
	],
);

export const commitContributor = pgTable(
	"commit_contributor",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "commit_contributor_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		commitId: bigint("commit_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }),
		role: varchar({ length: 32 }).notNull(),
		name: varchar({ length: 255 }),
		email: varchar({ length: 255 }).notNull(),
		ordinal: integer().default(0).notNull(),
	},
	(table) => [
		index("idx_commit_contributor_commit_id").using("btree", table.commitId.asc().nullsLast()),
		index("idx_commit_contributor_user_id").using("btree", table.userId.asc().nullsLast()),
		foreignKey({
			columns: [table.commitId],
			foreignColumns: [gitCommit.id],
			name: "fk_commit_contributor_commit",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fk_commit_contributor_user",
		}).onDelete("set null"),
		unique("uq_commit_contributor_commit_email_role").on(table.commitId, table.role, table.email),
	],
);

export const commitFileChange = pgTable(
	"commit_file_change",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "commit_file_change_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		filename: varchar({ length: 1024 }).notNull(),
		changeType: varchar("change_type", { length: 32 }).notNull(),
		additions: integer().default(0).notNull(),
		deletions: integer().default(0).notNull(),
		changes: integer().default(0).notNull(),
		previousFilename: varchar("previous_filename", { length: 1024 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		commitId: bigint("commit_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_commit_file_change_commit_id").using("btree", table.commitId.asc().nullsLast()),
		index("idx_commit_file_change_filename").using("btree", table.filename.asc().nullsLast()),
		foreignKey({
			columns: [table.commitId],
			foreignColumns: [gitCommit.id],
			name: "fk_commit_file_change_commit",
		}).onDelete("cascade"),
	],
);

export const commitPullRequest = pgTable(
	"commit_pull_request",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		commitId: bigint("commit_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestId: bigint("pull_request_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_commit_pull_request_pr_id").using("btree", table.pullRequestId.asc().nullsLast()),
		foreignKey({
			columns: [table.commitId],
			foreignColumns: [gitCommit.id],
			name: "fk_commit_pr_commit",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.pullRequestId],
			foreignColumns: [issue.id],
			name: "fk_commit_pr_pull_request",
		}).onDelete("cascade"),
		primaryKey({ columns: [table.commitId, table.pullRequestId], name: "pk_commit_pull_request" }),
	],
);

export const discussion = pgTable(
	"discussion",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		number: integer().notNull(),
		title: varchar({ length: 1024 }).notNull(),
		body: text(),
		htmlUrl: varchar("html_url", { length: 512 }).notNull(),
		state: varchar({ length: 16 }).notNull(),
		stateReason: varchar("state_reason", { length: 32 }),
		isLocked: boolean("is_locked").default(false).notNull(),
		activeLockReason: varchar("active_lock_reason", { length: 32 }),
		closedAt: timestamp("closed_at", { withTimezone: true, mode: "string" }),
		answerChosenAt: timestamp("answer_chosen_at", { withTimezone: true, mode: "string" }),
		commentCount: integer("comment_count").default(0).notNull(),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		categoryId: varchar("category_id", { length: 128 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		answerChosenById: bigint("answer_chosen_by_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		answerCommentId: bigint("answer_comment_id", { mode: "number" }),
	},
	(table) => [
		index("idx_discussion_author").using("btree", table.authorId.asc().nullsLast()),
		index("idx_discussion_category").using("btree", table.categoryId.asc().nullsLast()),
		index("idx_discussion_created_at").using("btree", table.createdAt.asc().nullsLast()),
		index("idx_discussion_repository").using("btree", table.repositoryId.asc().nullsLast()),
		index("idx_discussion_state").using("btree", table.state.asc().nullsLast()),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_discussion_repository",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fk_discussion_author",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.categoryId],
			foreignColumns: [discussionCategory.id],
			name: "fk_discussion_category",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.answerChosenById],
			foreignColumns: [user.id],
			name: "fk_discussion_answer_chosen_by",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.answerCommentId],
			foreignColumns: [discussionComment.id],
			name: "fk_discussion_answer_comment",
		}).onDelete("set null"),
		unique("uq_discussion_repo_number").on(table.number, table.repositoryId),
		unique("uk_discussion_answer_comment_id").on(table.answerCommentId),
	],
);

export const discussionCategory = pgTable(
	"discussion_category",
	{
		id: varchar({ length: 128 }).primaryKey().notNull(),
		name: varchar({ length: 255 }).notNull(),
		slug: varchar({ length: 128 }).notNull(),
		emoji: varchar({ length: 32 }),
		description: text(),
		isAnswerable: boolean("is_answerable").default(false).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_discussion_category_repository").using(
			"btree",
			table.repositoryId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_discussion_category_repository",
		}).onDelete("cascade"),
		unique("uq_discussion_category_repo_slug").on(table.slug, table.repositoryId),
	],
);

export const discussionComment = pgTable(
	"discussion_comment",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		body: text(),
		htmlUrl: varchar("html_url", { length: 512 }).notNull(),
		isAnswer: boolean("is_answer").default(false).notNull(),
		isMinimized: boolean("is_minimized").default(false).notNull(),
		minimizedReason: varchar("minimized_reason", { length: 64 }),
		authorAssociation: varchar("author_association", { length: 32 }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		discussionId: bigint("discussion_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		parentCommentId: bigint("parent_comment_id", { mode: "number" }),
	},
	(table) => [
		index("idx_discussion_comment_author").using("btree", table.authorId.asc().nullsLast()),
		index("idx_discussion_comment_discussion").using("btree", table.discussionId.asc().nullsLast()),
		index("idx_discussion_comment_discussion_created").using(
			"btree",
			table.discussionId.asc().nullsLast(),
			table.createdAt.asc().nullsLast(),
		),
		index("idx_discussion_comment_is_answer").using("btree", table.isAnswer.asc().nullsLast()),
		index("idx_discussion_comment_parent").using("btree", table.parentCommentId.asc().nullsLast()),
		foreignKey({
			columns: [table.discussionId],
			foreignColumns: [discussion.id],
			name: "fk_discussion_comment_discussion",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fk_discussion_comment_author",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.parentCommentId],
			foreignColumns: [table.id],
			name: "fk_discussion_comment_parent",
		}).onDelete("set null"),
	],
);

export const discussionLabel = pgTable(
	"discussion_label",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		discussionId: bigint("discussion_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		labelId: bigint("label_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.discussionId],
			foreignColumns: [discussion.id],
			name: "fk_discussion_label_discussion",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.labelId],
			foreignColumns: [label.id],
			name: "fk_discussion_label_label",
		}).onDelete("cascade"),
		primaryKey({ columns: [table.discussionId, table.labelId], name: "discussion_label_pkey" }),
	],
);

export const document = pgTable(
	"document",
	{
		id: uuid().notNull(),
		versionNumber: integer("version_number").notNull(),
		content: text(),
		createdAt: timestamp("created_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}).notNull(),
		kind: varchar({ length: 255 }).notNull(),
		title: varchar({ length: 255 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_document_created_at").using("btree", table.createdAt.asc().nullsLast()),
		index("idx_document_id").using("btree", table.id.asc().nullsLast()),
		index("idx_document_user_id").using("btree", table.userId.asc().nullsLast()),
		index("idx_document_workspace_id").using("btree", table.workspaceId.asc().nullsLast()),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "FKjhdxdv9sijhujiynqbb5jc010",
		}),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_document_workspace",
		}).onDelete("cascade"),
		primaryKey({ columns: [table.id, table.versionNumber], name: "documentPK" }),
	],
);

export const gitCommit = pgTable(
	"git_commit",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "git_commit_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		sha: varchar({ length: 40 }).notNull(),
		message: varchar({ length: 1024 }).notNull(),
		messageBody: text("message_body"),
		htmlUrl: varchar("html_url", { length: 512 }),
		authoredAt: timestamp("authored_at", { withTimezone: true, mode: "string" }).notNull(),
		committedAt: timestamp("committed_at", { withTimezone: true, mode: "string" }).notNull(),
		additions: integer().default(0).notNull(),
		deletions: integer().default(0).notNull(),
		changedFiles: integer("changed_files").default(0).notNull(),
		authorEmail: varchar("author_email", { length: 255 }),
		committerEmail: varchar("committer_email", { length: 255 }),
		signatureValid: boolean("signature_valid"),
		authoredByCommitter: boolean("authored_by_committer"),
		committedViaWeb: boolean("committed_via_web"),
		parentCount: integer("parent_count"),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		committerId: bigint("committer_id", { mode: "number" }),
		signatureState: varchar("signature_state", { length: 32 }),
		signatureWasSignedByGithub: boolean("signature_was_signed_by_github"),
		signatureSignerLogin: varchar("signature_signer_login", { length: 255 }),
		parentShas: text("parent_shas"),
		statusCheckRollupState: varchar("status_check_rollup_state", { length: 32 }),
		onBehalfOfLogin: varchar("on_behalf_of_login", { length: 255 }),
	},
	(table) => [
		index("idx_git_commit_author_id").using("btree", table.authorId.asc().nullsLast()),
		index("idx_git_commit_authored_at").using("btree", table.authoredAt.asc().nullsLast()),
		index("idx_git_commit_committer_id").using("btree", table.committerId.asc().nullsLast()),
		index("idx_git_commit_repository_id").using("btree", table.repositoryId.asc().nullsLast()),
		index("idx_git_commit_unresolved_author_email")
			.using("btree", table.repositoryId.asc().nullsLast(), table.authorEmail.asc().nullsLast())
			.where(sql`((author_id IS NULL) AND (author_email IS NOT NULL))`),
		index("idx_git_commit_unresolved_committer_email")
			.using("btree", table.repositoryId.asc().nullsLast(), table.committerEmail.asc().nullsLast())
			.where(sql`((committer_id IS NULL) AND (committer_email IS NOT NULL))`),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_git_commit_repository",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fk_git_commit_author",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.committerId],
			foreignColumns: [user.id],
			name: "fk_git_commit_committer",
		}).onDelete("set null"),
		unique("uq_git_commit_sha_repository").on(table.sha, table.repositoryId),
	],
);

export const issue = pgTable(
	"issue",
	{
		issueType: varchar("issue_type", { length: 31 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		closedAt: timestamp("closed_at", { withTimezone: true, mode: "string" }),
		commentsCount: integer("comments_count").notNull(),
		htmlUrl: varchar("html_url", { length: 255 }),
		isLocked: boolean("is_locked").notNull(),
		number: integer().notNull(),
		state: varchar({ length: 255 }),
		title: varchar({ length: 1024 }),
		additions: integer(),
		changedFiles: integer("changed_files"),
		commits: integer(),
		deletions: integer(),
		isDraft: boolean("is_draft"),
		isMerged: boolean("is_merged"),
		mergedAt: timestamp("merged_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		milestoneId: bigint("milestone_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		mergedById: bigint("merged_by_id", { mode: "number" }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		stateReason: varchar("state_reason", { length: 32 }),
		body: text(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		parentIssueId: bigint("parent_issue_id", { mode: "number" }),
		subIssuesTotal: integer("sub_issues_total"),
		subIssuesCompleted: integer("sub_issues_completed"),
		subIssuesPercentCompleted: integer("sub_issues_percent_completed"),
		issueTypeId: varchar("issue_type_id", { length: 128 }),
		mergeStateStatus: varchar("merge_state_status", { length: 255 }),
		mergeable: boolean(),
		reviewDecision: varchar("review_decision", { length: 255 }),
		headRefName: varchar("head_ref_name", { length: 255 }),
		headRefOid: varchar("head_ref_oid", { length: 40 }),
		baseRefName: varchar("base_ref_name", { length: 255 }),
		baseRefOid: varchar("base_ref_oid", { length: 40 }),
	},
	(table) => [
		index("idx_issue_author_id").using("btree", table.authorId.asc().nullsLast()),
		index("idx_issue_issue_type_id").using("btree", table.issueTypeId.asc().nullsLast()),
		index("idx_issue_parent_issue_id").using("btree", table.parentIssueId.asc().nullsLast()),
		index("idx_issue_repository_id").using("btree", table.repositoryId.asc().nullsLast()),
		index("idx_issue_state").using("btree", table.state.asc().nullsLast()),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk76s4b6ncspm9bk35y49xh4s9t",
		}),
		foreignKey({
			columns: [table.milestoneId],
			foreignColumns: [milestone.id],
			name: "fk7t1o4tuel06m9bn4dppqmiod6",
		}),
		foreignKey({
			columns: [table.mergedById],
			foreignColumns: [user.id],
			name: "fkqvnu6vslj5txt8xencru8m6x4",
		}),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fkrwr6v8fiqetuiuvfjcvie8s85",
		}),
		foreignKey({
			columns: [table.parentIssueId],
			foreignColumns: [table.id],
			name: "fk_issue_parent_issue",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.issueTypeId],
			foreignColumns: [issueType.id],
			name: "fk_issue_issue_type",
		}).onDelete("set null"),
		unique("uk_issue_repository_number").on(table.number, table.repositoryId),
		check(
			"issue_merge_state_status_check",
			sql`(merge_state_status)::text = ANY (ARRAY['BEHIND'::text, 'BLOCKED'::text, 'CLEAN'::text, 'DIRTY'::text, 'HAS_HOOKS'::text, 'UNKNOWN'::text, 'UNSTABLE'::text])`,
		),
		check(
			"issue_review_decision_check",
			sql`(review_decision)::text = ANY (ARRAY['APPROVED'::text, 'CHANGES_REQUESTED'::text, 'REVIEW_REQUIRED'::text])`,
		),
	],
);

export const issueAssignee = pgTable(
	"issue_assignee",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		issueId: bigint("issue_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fk2cfu8w8wjb9vosy4hbrme0rqe",
		}),
		foreignKey({
			columns: [table.issueId],
			foreignColumns: [issue.id],
			name: "fkocgmsva4p5e8ic9k5dbjqa15u",
		}),
		primaryKey({ columns: [table.issueId, table.userId], name: "issue_assignee_pkey" }),
	],
);

export const issueBlocking = pgTable(
	"issue_blocking",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		blockedIssueId: bigint("blocked_issue_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		blockingIssueId: bigint("blocking_issue_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_issue_blocking_blocked_id").using("btree", table.blockedIssueId.asc().nullsLast()),
		index("idx_issue_blocking_blocking_id").using("btree", table.blockingIssueId.asc().nullsLast()),
		foreignKey({
			columns: [table.blockedIssueId],
			foreignColumns: [issue.id],
			name: "fk_issue_blocking_blocked",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.blockingIssueId],
			foreignColumns: [issue.id],
			name: "fk_issue_blocking_blocking",
		}).onDelete("cascade"),
		primaryKey({
			columns: [table.blockedIssueId, table.blockingIssueId],
			name: "pk_issue_blocking",
		}),
	],
);

export const issueComment = pgTable(
	"issue_comment",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		authorAssociation: varchar("author_association", { length: 255 }),
		htmlUrl: varchar("html_url", { length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		issueId: bigint("issue_id", { mode: "number" }),
		body: text(),
	},
	(table) => [
		index("idx_issue_comment_author_id").using("btree", table.authorId.asc().nullsLast()),
		index("idx_issue_comment_created_at").using("btree", table.createdAt.asc().nullsLast()),
		foreignKey({
			columns: [table.issueId],
			foreignColumns: [issue.id],
			name: "fk8wy5rxggrte2ntcq80g7o7210",
		}),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fkdy6oeojymud1wna20olqgyt31",
		}),
	],
);

export const issueLabel = pgTable(
	"issue_label",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		issueId: bigint("issue_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		labelId: bigint("label_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.issueId],
			foreignColumns: [issue.id],
			name: "fkit5n9c0frugu5m8xqsxtps63r",
		}),
		foreignKey({
			columns: [table.labelId],
			foreignColumns: [label.id],
			name: "fkxbk5rr30kkb6k4ech7x4vh9h",
		}),
		primaryKey({ columns: [table.issueId, table.labelId], name: "issue_label_pkey" }),
	],
);

export const issueType = pgTable(
	"issue_type",
	{
		id: varchar({ length: 128 }).primaryKey().notNull(),
		name: varchar({ length: 128 }).notNull(),
		description: text(),
		color: varchar({ length: 20 }).notNull(),
		isEnabled: boolean("is_enabled").default(true).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		organizationId: bigint("organization_id", { mode: "number" }).notNull(),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_issue_type_organization_id").using("btree", table.organizationId.asc().nullsLast()),
		foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organization.id],
			name: "fk_issue_type_organization",
		}).onDelete("cascade"),
	],
);

export const label = pgTable(
	"label",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		color: varchar({ length: 255 }),
		description: varchar({ length: 255 }),
		name: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk2951edbl9g9y8ee1q97e2ff75",
		}),
		unique("uq_label_repository_name").on(table.name, table.repositoryId),
	],
);

export const milestone = pgTable(
	"milestone",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		closedAt: timestamp("closed_at", { withTimezone: true, mode: "string" }),
		dueOn: timestamp("due_on", { withTimezone: true, mode: "string" }),
		htmlUrl: varchar("html_url", { length: 255 }),
		number: integer().notNull(),
		state: varchar({ length: 255 }),
		title: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		creatorId: bigint("creator_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }),
		description: text(),
		closedIssuesCount: integer("closed_issues_count").default(0).notNull(),
		openIssuesCount: integer("open_issues_count").default(0).notNull(),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fkbjhs37s6qmqtd330gu9mit6w0",
		}),
		foreignKey({
			columns: [table.creatorId],
			foreignColumns: [user.id],
			name: "fkg6ieho7gomiumy85puy6l13f1",
		}),
		unique("uk_milestone_number_repository").on(table.number, table.repositoryId),
	],
);

export const organization = pgTable(
	"organization",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { precision: 6, withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { precision: 6, withTimezone: true, mode: "string" }),
		avatarUrl: varchar("avatar_url", { length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		githubId: bigint("github_id", { mode: "number" }).notNull(),
		htmlUrl: varchar("html_url", { length: 255 }),
		login: varchar({ length: 255 }).notNull(),
		name: varchar({ length: 255 }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		unique("uq_organization_github_id").on(table.githubId),
		unique("uq_organization_login").on(table.login),
	],
);

export const organizationMembership = pgTable(
	"organization_membership",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		organizationId: bigint("organization_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		role: varchar({ length: 32 }),
	},
	(table) => [
		primaryKey({
			columns: [table.organizationId, table.userId],
			name: "organization_membershipPK",
		}),
	],
);

export const project = pgTable(
	"project",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		nodeId: varchar("node_id", { length: 64 }),
		ownerType: varchar("owner_type", { length: 32 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		ownerId: bigint("owner_id", { mode: "number" }).notNull(),
		number: integer().notNull(),
		title: varchar({ length: 256 }),
		shortDescription: text("short_description"),
		readme: text(),
		template: boolean().default(false).notNull(),
		url: varchar({ length: 512 }),
		closed: boolean().default(false).notNull(),
		closedAt: timestamp("closed_at", { withTimezone: true, mode: "string" }),
		isPublic: boolean("is_public").default(false).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		creatorId: bigint("creator_id", { mode: "number" }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		itemSyncCursor: varchar("item_sync_cursor", { length: 256 }),
		itemsSyncedAt: timestamp("items_synced_at", { withTimezone: true, mode: "string" }),
		fieldSyncCursor: varchar("field_sync_cursor", { length: 256 }),
		fieldsSyncedAt: timestamp("fields_synced_at", { withTimezone: true, mode: "string" }),
		statusUpdateSyncCursor: varchar("status_update_sync_cursor", { length: 256 }),
		statusUpdatesSyncedAt: timestamp("status_updates_synced_at", {
			withTimezone: true,
			mode: "string",
		}),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_project_creator_id").using("btree", table.creatorId.asc().nullsLast()),
		index("idx_project_owner").using(
			"btree",
			table.ownerType.asc().nullsLast(),
			table.ownerId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.creatorId],
			foreignColumns: [user.id],
			name: "fk_project_creator",
		}).onDelete("set null"),
		unique("uk_project_node_id").on(table.nodeId),
		unique("uk_project_owner_number").on(table.ownerType, table.ownerId, table.number),
	],
);

export const projectField = pgTable(
	"project_field",
	{
		id: varchar({ length: 64 }).primaryKey().notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		projectId: bigint("project_id", { mode: "number" }).notNull(),
		name: varchar({ length: 256 }).notNull(),
		dataType: varchar("data_type", { length: 32 }).notNull(),
		options: jsonb(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_project_field_project_id").using("btree", table.projectId.asc().nullsLast()),
		foreignKey({
			columns: [table.projectId],
			foreignColumns: [project.id],
			name: "fk_project_field_project",
		}).onDelete("cascade"),
		unique("uk_project_field_project_name").on(table.projectId, table.name),
	],
);

export const projectFieldValue = pgTable(
	"project_field_value",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "project_field_value_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		itemId: bigint("item_id", { mode: "number" }).notNull(),
		fieldId: varchar("field_id", { length: 64 }).notNull(),
		textValue: text("text_value"),
		numberValue: doublePrecision("number_value"),
		dateValue: date("date_value"),
		singleSelectOptionId: varchar("single_select_option_id", { length: 64 }),
		iterationId: varchar("iteration_id", { length: 64 }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_project_field_value_field_id").using("btree", table.fieldId.asc().nullsLast()),
		index("idx_project_field_value_item_id").using("btree", table.itemId.asc().nullsLast()),
		foreignKey({
			columns: [table.itemId],
			foreignColumns: [projectItem.id],
			name: "fk_project_field_value_item",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.fieldId],
			foreignColumns: [projectField.id],
			name: "fk_project_field_value_field",
		}).onDelete("cascade"),
		unique("uk_project_field_value_item_field").on(table.itemId, table.fieldId),
	],
);

export const projectItem = pgTable(
	"project_item",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		nodeId: varchar("node_id", { length: 64 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		projectId: bigint("project_id", { mode: "number" }).notNull(),
		contentType: varchar("content_type", { length: 32 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		issueId: bigint("issue_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		contentDatabaseId: bigint("content_database_id", { mode: "number" }),
		draftTitle: varchar("draft_title", { length: 1024 }),
		draftBody: text("draft_body"),
		archived: boolean().default(false).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		creatorId: bigint("creator_id", { mode: "number" }),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_project_item_content_type_archived").using(
			"btree",
			table.projectId.asc().nullsLast(),
			table.contentType.asc().nullsLast(),
			table.archived.asc().nullsLast(),
		),
		index("idx_project_item_creator_id").using("btree", table.creatorId.asc().nullsLast()),
		index("idx_project_item_issue_id").using("btree", table.issueId.asc().nullsLast()),
		index("idx_project_item_orphaned_relink")
			.using("btree", table.contentDatabaseId.asc().nullsLast())
			.where(
				sql`((issue_id IS NULL) AND (content_database_id IS NOT NULL) AND ((content_type)::text = ANY ((ARRAY['ISSUE'::character varying, 'PULL_REQUEST'::character varying])::text[])))`,
			),
		index("idx_project_item_project_archived").using(
			"btree",
			table.projectId.asc().nullsLast(),
			table.archived.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.projectId],
			foreignColumns: [project.id],
			name: "fk_project_item_project",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.issueId],
			foreignColumns: [issue.id],
			name: "fk_project_item_issue",
		}).onDelete("set null"),
		foreignKey({
			columns: [table.creatorId],
			foreignColumns: [user.id],
			name: "fk_project_item_creator",
		}).onDelete("set null"),
		unique("uk_project_item_project_nodeid").on(table.nodeId, table.projectId),
	],
);

export const projectStatusUpdate = pgTable(
	"project_status_update",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		nodeId: varchar("node_id", { length: 64 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		projectId: bigint("project_id", { mode: "number" }).notNull(),
		body: text(),
		bodyHtml: text("body_html"),
		startDate: date("start_date"),
		targetDate: date("target_date"),
		status: varchar({ length: 32 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		creatorId: bigint("creator_id", { mode: "number" }),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		index("idx_project_status_update_created_at").using(
			"btree",
			table.projectId.asc().nullsLast(),
			table.createdAt.desc().nullsFirst(),
		),
		index("idx_project_status_update_creator_id").using("btree", table.creatorId.asc().nullsLast()),
		foreignKey({
			columns: [table.projectId],
			foreignColumns: [project.id],
			name: "fk_project_status_update_project",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.creatorId],
			foreignColumns: [user.id],
			name: "fk_project_status_update_creator",
		}).onDelete("set null"),
		unique("uk_project_status_update_node_id").on(table.nodeId),
	],
);

export const pullRequestBadPractice = pgTable(
	"pull_request_bad_practice",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "pullrequestbadpractice_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		title: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullrequestId: bigint("pullrequest_id", { mode: "number" }),
		state: varchar({ length: 32 }).default(0),
		detectedAt: timestamp("detected_at", { precision: 6, withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { precision: 6, withTimezone: true, mode: "string" }),
		userState: varchar("user_state", { length: 32 }),
		detectionPullrequestLifecycleState: varchar("detection_pullrequest_lifecycle_state", {
			length: 32,
		}),
		detectionTraceId: varchar("detection_trace_id", { length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		badPracticeDetectionId: bigint("bad_practice_detection_id", { mode: "number" }),
		description: text(),
	},
	(table) => [
		foreignKey({
			columns: [table.pullrequestId],
			foreignColumns: [issue.id],
			name: "FK1m1jhw92ublt7ya0d557sg5j",
		}),
		foreignKey({
			columns: [table.badPracticeDetectionId],
			foreignColumns: [badPracticeDetection.id],
			name: "FKdn50l1oul09kq3142ku39gnlp",
		}),
	],
);

export const pullRequestRequestedReviewers = pgTable(
	"pull_request_requested_reviewers",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestId: bigint("pull_request_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.pullRequestId],
			foreignColumns: [issue.id],
			name: "fk6dld06xx8rh9xhqfnca070a0i",
		}),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fkioq4g5aksr97l6qyl4g5l63tn",
		}),
		primaryKey({
			columns: [table.pullRequestId, table.userId],
			name: "pull_request_requested_reviewers_pkey",
		}),
	],
);

export const pullRequestReview = pgTable(
	"pull_request_review",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		commitId: varchar("commit_id", { length: 255 }),
		htmlUrl: varchar("html_url", { length: 255 }),
		isDismissed: boolean("is_dismissed").notNull(),
		state: varchar({ length: 255 }),
		submittedAt: timestamp("submitted_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestId: bigint("pull_request_id", { mode: "number" }),
		body: text(),
		createdAt: timestamp("created_at", { mode: "string" }),
		updatedAt: timestamp("updated_at", { mode: "string" }),
		authorCanPushToRepository: boolean("author_can_push_to_repository"),
	},
	(table) => [
		index("idx_pr_review_author_id").using("btree", table.authorId.asc().nullsLast()),
		index("idx_pr_review_pull_request_id").using("btree", table.pullRequestId.asc().nullsLast()),
		index("idx_pr_review_submitted_at").using("btree", table.submittedAt.asc().nullsLast()),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fkeehfcwrodfu61gremlcvhgir5",
		}),
		foreignKey({
			columns: [table.pullRequestId],
			foreignColumns: [issue.id],
			name: "fkio96gq2jetvy6a4in9nl8vkvd",
		}),
	],
);

export const pullRequestReviewComment = pgTable(
	"pull_request_review_comment",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		authorAssociation: varchar("author_association", { length: 255 }),
		commitId: varchar("commit_id", { length: 255 }),
		htmlUrl: varchar("html_url", { length: 255 }),
		line: integer().notNull(),
		originalCommitId: varchar("original_commit_id", { length: 255 }),
		originalLine: integer("original_line").notNull(),
		originalStartLine: integer("original_start_line"),
		path: varchar({ length: 255 }),
		startLine: integer("start_line"),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		authorId: bigint("author_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestId: bigint("pull_request_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		reviewId: bigint("review_id", { mode: "number" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		threadId: bigint("thread_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		inReplyToId: bigint("in_reply_to_id", { mode: "number" }),
		body: text(),
		diffHunk: text("diff_hunk"),
		outdated: boolean(),
	},
	(table) => [
		index("idx_pull_request_review_comment_thread").using(
			"btree",
			table.threadId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.reviewId],
			foreignColumns: [pullRequestReview.id],
			name: "fkbx1g5jpdegymhyv9pbk2jdgfw",
		}),
		foreignKey({
			columns: [table.pullRequestId],
			foreignColumns: [issue.id],
			name: "fkohqvdiswptbm0h8cniq7r1tgq",
		}),
		foreignKey({
			columns: [table.authorId],
			foreignColumns: [user.id],
			name: "fktl08ieowbl171xem2bciho7kw",
		}),
		foreignKey({
			columns: [table.threadId],
			foreignColumns: [pullRequestReviewThread.id],
			name: "fk_pr_review_comment_thread",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.inReplyToId],
			foreignColumns: [table.id],
			name: "fk_pr_review_comment_reply",
		}).onDelete("set null"),
	],
);

export const pullRequestReviewThread = pgTable(
	"pull_request_review_thread",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		state: varchar({ length: 20 }).default("UNRESOLVED").notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		pullRequestId: bigint("pull_request_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		rootCommentId: bigint("root_comment_id", { mode: "number" }),
		nodeId: varchar("node_id", { length: 128 }),
		path: text(),
		line: integer(),
		startLine: integer("start_line"),
		side: varchar({ length: 16 }),
		startSide: varchar("start_side", { length: 16 }),
		outdated: boolean(),
		collapsed: boolean(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		resolvedById: bigint("resolved_by_id", { mode: "number" }),
	},
	(table) => [
		index("idx_pull_request_review_thread_pull_request").using(
			"btree",
			table.pullRequestId.asc().nullsLast(),
		),
		index("idx_pull_request_review_thread_resolved_by").using(
			"btree",
			table.resolvedById.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.pullRequestId],
			foreignColumns: [issue.id],
			name: "fk_pr_review_thread_pull_request",
		}),
		foreignKey({
			columns: [table.rootCommentId],
			foreignColumns: [pullRequestReviewComment.id],
			name: "fk_pr_review_thread_root_comment",
		}),
		foreignKey({
			columns: [table.resolvedById],
			foreignColumns: [user.id],
			name: "fk_pull_request_review_thread_resolved_by",
		}).onDelete("set null"),
		unique("uq_pr_review_thread_root_comment").on(table.rootCommentId),
	],
);

export const repository = pgTable(
	"repository",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		defaultBranch: varchar("default_branch", { length: 255 }),
		description: text(),
		htmlUrl: varchar("html_url", { length: 512 }),
		isArchived: boolean("is_archived").notNull(),
		isDisabled: boolean("is_disabled").notNull(),
		isPrivate: boolean("is_private").notNull(),
		name: varchar({ length: 255 }),
		nameWithOwner: varchar("name_with_owner", { length: 150 }),
		pushedAt: timestamp("pushed_at", { withTimezone: true, mode: "string" }),
		visibility: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		organizationId: bigint("organization_id", { mode: "number" }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		hasDiscussionsEnabled: boolean("has_discussions_enabled").default(false).notNull(),
	},
	(table) => [
		index("idx_repository_name_with_owner").using("btree", table.nameWithOwner.asc().nullsLast()),
		index("idx_repository_organization_id").using("btree", table.organizationId.asc().nullsLast()),
		foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organization.id],
			name: "fk_repository_organization",
		}),
		unique("uq_repository_name_with_owner").on(table.nameWithOwner),
	],
);

export const repositoryCollaborator = pgTable(
	"repository_collaborator",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		permission: varchar({ length: 32 }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_repository_collaborator_repository",
		}),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fk_repository_collaborator_user",
		}),
		primaryKey({ columns: [table.repositoryId, table.userId], name: "pk_repository_collaborator" }),
	],
);

export const repositoryToMonitor = pgTable(
	"repository_to_monitor",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "repository_to_monitor_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		labelsSyncedAt: timestamp("labels_synced_at", { withTimezone: true, mode: "string" }),
		milestonesSyncedAt: timestamp("milestones_synced_at", { withTimezone: true, mode: "string" }),
		nameWithOwner: varchar("name_with_owner", { length: 255 }),
		repositorySyncedAt: timestamp("repository_synced_at", { withTimezone: true, mode: "string" }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }),
		backfillLastRunAt: timestamp("backfill_last_run_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		collaboratorsSyncedAt: timestamp("collaborators_synced_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		issueSyncCursor: varchar("issue_sync_cursor", { length: 255 }),
		pullRequestSyncCursor: varchar("pull_request_sync_cursor", { length: 255 }),
		issueBackfillHighWaterMark: integer("issue_backfill_high_water_mark"),
		issueBackfillCheckpoint: integer("issue_backfill_checkpoint"),
		pullRequestBackfillHighWaterMark: integer("pull_request_backfill_high_water_mark"),
		pullRequestBackfillCheckpoint: integer("pull_request_backfill_checkpoint"),
		discussionSyncCursor: varchar("discussion_sync_cursor", { length: 255 }),
		issuesSyncedAt: timestamp("issues_synced_at", { withTimezone: true, mode: "string" }),
		pullRequestsSyncedAt: timestamp("pull_requests_synced_at", {
			withTimezone: true,
			mode: "string",
		}),
		discussionsSyncedAt: timestamp("discussions_synced_at", { withTimezone: true, mode: "string" }),
	},
	(table) => [
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "FKdkxnkm4a2wyw0d5k63gh2st64",
		}),
	],
);

export const team = pgTable(
	"team",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" })
			.primaryKey()
			.generatedByDefaultAsIdentity({ name: "team_id_seq", startWith: 1, increment: 1, cache: 1 }),
		name: varchar({ length: 255 }),
		createdAt: timestamp("created_at", { precision: 6, withTimezone: true, mode: "string" }),
		description: text(),
		htmlUrl: varchar("html_url", { length: 512 }),
		lastSyncAt: timestamp("last_sync_at", { withTimezone: true, mode: "string" }),
		organization: varchar({ length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		parentId: bigint("parent_id", { mode: "number" }),
		privacy: varchar({ length: 32 }),
		updatedAt: timestamp("updated_at", { precision: 6, withTimezone: true, mode: "string" }),
	},
	(table) => [unique("uk_team_organization_name").on(table.name, table.organization)],
);

export const teamMembership = pgTable(
	"team_membership",
	{
		role: varchar({ length: 32 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		teamId: bigint("team_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "FKnkpwi3whks92uvhn5qe71v4k6",
		}),
		foreignKey({
			columns: [table.teamId],
			foreignColumns: [team.id],
			name: "FKrf92vmiawfvyhxcmigcg10opm",
		}),
		primaryKey({ columns: [table.userId, table.teamId], name: "team_membershipPK" }),
	],
);

export const teamRepositoryPermission = pgTable(
	"team_repository_permission",
	{
		permission: varchar({ length: 32 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		teamId: bigint("team_id", { mode: "number" }).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.teamId],
			foreignColumns: [team.id],
			name: "FK7qxvqq8p6690vtdux47lsg8b1",
		}),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "FK92gtctw6ca02527qjja7gns9f",
		}),
		primaryKey({
			columns: [table.repositoryId, table.teamId],
			name: "team_repository_permissionPK",
		}),
	],
);

export const user = pgTable(
	"user",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().notNull(),
		createdAt: timestamp("created_at", { withTimezone: true, mode: "string" }),
		updatedAt: timestamp("updated_at", { withTimezone: true, mode: "string" }),
		avatarUrl: varchar("avatar_url", { length: 255 }),
		email: varchar({ length: 255 }),
		htmlUrl: varchar("html_url", { length: 255 }),
		login: varchar({ length: 255 }),
		name: varchar({ length: 255 }),
		type: varchar({ length: 255 }),
	},
	(table) => [uniqueIndex("uk_user_login_lower").using("btree", sql`lower((login)::text)`)],
);

export const userPreferences = pgTable(
	"user_preferences",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "user_preferences_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		notificationsEnabled: boolean("notifications_enabled").default(true).notNull(),
		participateInResearch: boolean("participate_in_research").default(true).notNull(),
	},
	(table) => [
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fk_user_preferences_user",
		}).onDelete("cascade"),
		unique("uk_user_preferences_user_id").on(table.userId),
	],
);

export const workspace = pgTable(
	"workspace",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "workspace_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		usersSyncedAt: timestamp("users_synced_at", { withTimezone: true, mode: "string" }),
		accountLogin: varchar("account_login", { length: 120 }),
		gitProviderMode: varchar("git_provider_mode", { length: 255 }),
		githubRepositorySelection: varchar("github_repository_selection", { length: 255 }),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		installationId: bigint("installation_id", { mode: "number" }),
		installationLinkedAt: timestamp("installation_linked_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		organizationId: bigint("organization_id", { mode: "number" }),
		personalAccessToken: text("personal_access_token"),
		accountType: varchar("account_type", { length: 10 }).default("USER").notNull(),
		createdAt: timestamp("created_at", { precision: 6, withTimezone: true, mode: "string" })
			.defaultNow()
			.notNull(),
		displayName: varchar("display_name", { length: 120 }).default("").notNull(),
		isPubliclyViewable: boolean("is_publicly_viewable").default(false).notNull(),
		leaderboardNotificationChannelId: varchar("leaderboard_notification_channel_id", {
			length: 100,
		}),
		leaderboardNotificationEnabled: boolean("leaderboard_notification_enabled"),
		leaderboardNotificationTeam: varchar("leaderboard_notification_team", { length: 100 }),
		leaderboardScheduleDay: integer("leaderboard_schedule_day"),
		leaderboardScheduleTime: varchar("leaderboard_schedule_time", { length: 10 }),
		slackSigningSecret: text("slack_signing_secret"),
		slackToken: text("slack_token"),
		slug: varchar({ length: 64 }).notNull(),
		status: varchar({ length: 20 }).default("ACTIVE").notNull(),
		updatedAt: timestamp("updated_at", { precision: 6, withTimezone: true, mode: "string" }),
		membersSyncedAt: timestamp("members_synced_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		teamsSyncedAt: timestamp("teams_synced_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		subIssuesSyncedAt: timestamp("sub_issues_synced_at", { withTimezone: true, mode: "string" }),
		issueTypesSyncedAt: timestamp("issue_types_synced_at", { withTimezone: true, mode: "string" }),
		issueDependenciesSyncedAt: timestamp("issue_dependencies_synced_at", {
			withTimezone: true,
			mode: "string",
		}),
	},
	(table) => [
		foreignKey({
			columns: [table.organizationId],
			foreignColumns: [organization.id],
			name: "fk_workspace_organization",
		}),
		unique("uc_workspaceorganization_id_col").on(table.organizationId),
		unique("uc_workspaceslug_col").on(table.slug),
	],
);

export const workspaceMembership = pgTable(
	"workspace_membership",
	{
		createdAt: timestamp("created_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}).notNull(),
		leaguePoints: integer("league_points").notNull(),
		role: varchar({ length: 16 }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		userId: bigint("user_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_workspace_membership_user_id").using("btree", table.userId.asc().nullsLast()),
		foreignKey({
			columns: [table.userId],
			foreignColumns: [user.id],
			name: "fk_workspace_membership_user",
		}),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_workspace_membership_workspace",
		}),
		primaryKey({ columns: [table.userId, table.workspaceId], name: "workspace_membershipPK" }),
	],
);

export const workspaceSlugHistory = pgTable(
	"workspace_slug_history",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		id: bigint({ mode: "number" }).primaryKey().generatedByDefaultAsIdentity({
			name: "workspace_slug_history_id_seq",
			startWith: 1,
			increment: 1,
			cache: 1,
		}),
		changedAt: timestamp("changed_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}).notNull(),
		newSlug: varchar("new_slug", { length: 64 }).notNull(),
		oldSlug: varchar("old_slug", { length: 64 }).notNull(),
		redirectExpiresAt: timestamp("redirect_expires_at", {
			precision: 6,
			withTimezone: true,
			mode: "string",
		}),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
	},
	(table) => [
		index("idx_workspace_slug_history_old_slug").using("btree", table.oldSlug.asc().nullsLast()),
		index("idx_workspace_slug_history_redirect_expires_at").using(
			"btree",
			table.redirectExpiresAt.asc().nullsLast(),
		),
		index("idx_workspace_slug_history_workspace_id").using(
			"btree",
			table.workspaceId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_workspace_slug_history_workspace",
		}).onDelete("cascade"),
	],
);

export const workspaceTeamLabelFilter = pgTable(
	"workspace_team_label_filter",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		teamId: bigint("team_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		labelId: bigint("label_id", { mode: "number" }).notNull(),
	},
	(table) => [
		uniqueIndex("IX_workspace_team_label_filterPK").using(
			"btree",
			table.labelId.asc().nullsLast(),
			table.teamId.asc().nullsLast(),
			table.workspaceId.asc().nullsLast(),
		),
		index("idx_workspace_team_label_filter_team_id").using("btree", table.teamId.asc().nullsLast()),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_workspace_team_label_filter_workspace",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.teamId],
			foreignColumns: [team.id],
			name: "fk_workspace_team_label_filter_team",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.labelId],
			foreignColumns: [label.id],
			name: "fk_workspace_team_label_filter_label",
		}).onDelete("cascade"),
		primaryKey({
			columns: [table.workspaceId, table.teamId, table.labelId],
			name: "workspace_team_label_filterPK",
		}),
	],
);

export const workspaceTeamRepositorySettings = pgTable(
	"workspace_team_repository_settings",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		teamId: bigint("team_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		repositoryId: bigint("repository_id", { mode: "number" }).notNull(),
		hiddenFromContributions: boolean("hidden_from_contributions").default(false).notNull(),
	},
	(table) => [
		uniqueIndex("IX_workspace_team_repository_settingsPK").using(
			"btree",
			table.repositoryId.asc().nullsLast(),
			table.teamId.asc().nullsLast(),
			table.workspaceId.asc().nullsLast(),
		),
		index("idx_workspace_team_repo_settings_team_repo").using(
			"btree",
			table.teamId.asc().nullsLast(),
			table.repositoryId.asc().nullsLast(),
		),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_workspace_team_repo_settings_workspace",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.teamId],
			foreignColumns: [team.id],
			name: "fk_workspace_team_repo_settings_team",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.repositoryId],
			foreignColumns: [repository.id],
			name: "fk_workspace_team_repo_settings_repository",
		}).onDelete("cascade"),
		primaryKey({
			columns: [table.workspaceId, table.teamId, table.repositoryId],
			name: "workspace_team_repository_settingsPK",
		}),
	],
);

export const workspaceTeamSettings = pgTable(
	"workspace_team_settings",
	{
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		workspaceId: bigint("workspace_id", { mode: "number" }).notNull(),
		// You can use { mode: "bigint" } if numbers are exceeding js number limitations
		teamId: bigint("team_id", { mode: "number" }).notNull(),
		hidden: boolean().default(false).notNull(),
	},
	(table) => [
		uniqueIndex("IX_workspace_team_settingsPK").using(
			"btree",
			table.teamId.asc().nullsLast(),
			table.workspaceId.asc().nullsLast(),
		),
		index("idx_workspace_team_settings_team_id").using("btree", table.teamId.asc().nullsLast()),
		foreignKey({
			columns: [table.workspaceId],
			foreignColumns: [workspace.id],
			name: "fk_workspace_team_settings_workspace",
		}).onDelete("cascade"),
		foreignKey({
			columns: [table.teamId],
			foreignColumns: [team.id],
			name: "fk_workspace_team_settings_team",
		}).onDelete("cascade"),
		primaryKey({ columns: [table.workspaceId, table.teamId], name: "workspace_team_settingsPK" }),
	],
);
