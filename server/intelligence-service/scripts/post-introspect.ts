#!/usr/bin/env -S node --no-warnings
/**
 * Post-introspection patcher for generated schema.ts and relations.ts
 *
 * This script runs after `drizzle-kit introspect` and performs the following:
 * - Adds a ts-nocheck pragma to silence circular/self-reference type errors.
 * - Cleans unused imports from drizzle-orm/pg-core; sorts remaining names.
 * - Drops identity minValue/maxValue metadata to avoid precision-loss noise.
 * - Removes unused `sql` import from drizzle-orm if not referenced.
 * - Removes Liquibase changelog tables from the schema.
 * - Sorts table exports and relation exports alphabetically for deterministic output.
 * - Moves schema.ts and relations.ts from ./drizzle/ to ./src/shared/db/
 * - Adds header comments to relations.ts to indicate it's auto-generated.
 *
 * IMPORTANT: Both schema.ts and relations.ts are auto-generated by drizzle-kit.
 * Do not edit them manually - run `npm run db:introspect` to regenerate.
 *
 * Cross-platform determinism:
 * drizzle-kit introspect produces non-deterministic output order on different platforms.
 * This script normalizes the output to ensure identical results on macOS and Linux.
 * See: https://github.com/drizzle-team/drizzle-orm/issues/2530
 */
import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { Project, SyntaxKind } from "ts-morph";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const schemaPath = path.resolve(__dirname, "../drizzle/schema.ts");

let content: string;
try {
	content = fs.readFileSync(schemaPath, "utf8");
} catch (error) {
	if ((error as NodeJS.ErrnoException).code === "ENOENT") {
		console.error(`[post-introspect] schema.ts not found at ${schemaPath}`);
		process.exit(0);
	}
	throw error;
}

// Prepend pragmas if not already present
const headerBanner = `// @ts-nocheck\n// generated by drizzle-kit; ts diagnostics suppressed for generated types\n`;
if (!content.startsWith("// @ts-nocheck")) {
	content = headerBanner + content;
}

// Trim unused items in the import from drizzle-orm/pg-core if they aren't referenced
const importRegex = /import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/;
const match = content.match(importRegex);
if (match) {
	const importedRaw = match[1];
	if (!importedRaw) {
		console.log("No imports found in drizzle-orm/pg-core import");
		process.exit(0);
	}
	const imported = importedRaw
		.split(",")
		.map((s) => s.trim())
		.filter(Boolean);
	const used = new Set<string>();
	for (const name of imported) {
		const bare = name.replace(/^type\s+/, "");
		const re = new RegExp(`\\b${bare}\\b`, "m");
		if (re.test(content)) {
			used.add(name);
		}
	}
	const cleaned = imported.filter((n) => used.has(n)).sort((a, b) => a.localeCompare(b));
	if (cleaned.length > 0 && cleaned.length !== imported.length) {
		content = content.replace(
			importRegex,
			`import { ${cleaned.join(", ")} } from "drizzle-orm/pg-core"`,
		);
	}
}

// Remove gigantic numeric literals in identity metadata to avoid precision-loss warnings
content = content
	.replace(/,\s*minValue:\s*[^,}\n]+/g, "")
	.replace(/,\s*maxValue:\s*[^,}\n]+/g, "")
	.replace(/minValue:\s*[^,}\n]+,\s*/g, "")
	.replace(/maxValue:\s*[^,}\n]+,\s*/g, "");

// Fix malformed empty string defaults: drizzle-kit incorrectly generates `.default(')` for `''::character varying`
// This should be `.default('')`
content = content.replace(/\.default\('\)\.notNull\(\)/g, ".default('').notNull()");
content = content.replace(/\.default\('\)/g, ".default('')");

// Always remove `import { sql } from "drizzle-orm"` in generated schema; drizzle rarely uses it and it trips linters
content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*"drizzle-orm"\s*;?\s*\n?/g, "\n");
content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*'drizzle-orm'\s*;?\s*\n?/g, "\n");
content = content.replace(
	/^\s*import\s*\{\s*sql\s*\}\s*from\s*["']drizzle-orm["']\s*;?\s*$(?:\r?\n)?/gm,
	"",
);

// Fix drizzle-kit introspect bug: it incorrectly assigns operator classes from the SECOND column
// to the FIRST column in composite indexes. For example:
//   index(...).using("btree", table.threadId.op("timestamptz_ops"), table.createdAt.op("timestamptz_ops"))
// should be:
//   index(...).using("btree", table.threadId, table.createdAt)
// The operator classes are defaults for btree and don't need to be specified.
// Remove all .op("..._ops") from indexes as btree uses default operator classes
content = content.replace(/\.op\("[a-z0-9_]+_ops"\)/g, "");

// Also ensure AnyPgColumn is not left in imports if unused
content = content.replace(
	/import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/,
	(_full, inner: string) => {
		const parts = inner
			.split(",")
			.map((s) => s.trim())
			.filter(Boolean);
		const filtered = parts.filter((p) => !/^type\s+AnyPgColumn$/.test(p));
		return `import { ${filtered.join(", ")} } from "drizzle-orm/pg-core"`;
	},
);

// Remove Liquibase tables `databasechangelog` and `databasechangeloglock`
// This removes the entire pgTable block including its body and any builder callback.
// Strategy: match `export const <name> = pgTable("<name>", { ... })` optionally followed by `, (table) => [...]` and trailing semicolon.
const removePgTableBlock = (name: string) => {
	// A reasonably safe regex using non-greedy matching and balanced braces heuristics per block lines.
	const tableRegex = new RegExp(
		// export const name = pgTable("name",
		String.raw`\nexport\s+const\s+${name}\s*=\s*pgTable\(\s*(["'])${name}\1\s*,\s*\{[\s\S]*?\}\s*\)` +
			// optional table callback e.g., , (table) => [ ... ]
			String.raw`(?:\s*,\s*\([^)]*\)\s*=>\s*\[[\s\S]*?\]\s*)?` +
			// optional trailing semicolon and newlines
			String.raw`\s*;?\n`,
		"g",
	);
	content = content.replace(tableRegex, "\n");
};

removePgTableBlock("databasechangelog");
removePgTableBlock("databasechangeloglock");

fs.writeFileSync(schemaPath, content, "utf8");

// ─────────────────────────────────────────────────────────────────────────────
// AST-based sorting for deterministic output across platforms
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Sort export declarations alphabetically using AST manipulation.
 * This ensures deterministic order regardless of the order drizzle-kit generates them.
 */
function sortExportsAlphabetically(filePath: string): void {
	const project = new Project({
		skipFileDependencyResolution: true,
		skipLoadingLibFiles: true,
	});

	const sourceFile = project.addSourceFileAtPath(filePath);

	// Get all top-level variable statements that are exports
	const exportStatements: Array<{ name: string; text: string; leadingTrivia: string }> = [];
	const importStatements: string[] = [];
	const otherStatements: string[] = [];
	const headerComments: string[] = [];

	// Collect header comments (lines starting with //) before any imports
	const fullText = sourceFile.getFullText();
	const lines = fullText.split("\n");
	let inHeader = true;
	for (const line of lines) {
		if (inHeader && (line.startsWith("//") || line.trim() === "")) {
			if (line.startsWith("//")) {
				headerComments.push(line);
			}
		} else {
			inHeader = false;
		}
	}

	// Collect imports
	for (const importDecl of sourceFile.getImportDeclarations()) {
		const importText = importDecl.getFullText().trim();
		importStatements.push(importText);
	}

	// Collect and categorize variable declarations
	for (const statement of sourceFile.getStatements()) {
		if (statement.isKind(SyntaxKind.VariableStatement)) {
			const varStatement = statement;
			const isExported = varStatement.hasExportKeyword();
			if (isExported) {
				const declarations = varStatement.getDeclarationList().getDeclarations();
				const firstDecl = declarations[0];
				if (firstDecl) {
					const name = firstDecl.getName();
					// Get the leading trivia (comments) for this statement
					const leadingTrivia = statement
						.getLeadingCommentRanges()
						.map((r) => r.getText())
						.join("\n");
					exportStatements.push({
						name,
						text: statement.getText(),
						leadingTrivia,
					});
				}
			}
		} else if (!statement.isKind(SyntaxKind.ImportDeclaration)) {
			// Skip header comments we already captured
			const text = statement.getText().trim();
			if (!text.startsWith("//")) {
				otherStatements.push(statement.getFullText().trim());
			}
		}
	}

	// Sort exports alphabetically by name
	exportStatements.sort((a, b) => a.name.localeCompare(b.name));

	// Reconstruct the file
	const newContent = [
		...headerComments,
		...importStatements,
		"",
		...exportStatements.map((e) => {
			if (e.leadingTrivia) {
				return `${e.leadingTrivia}\n${e.text}`;
			}
			return e.text;
		}),
		...otherStatements,
		"",
	].join("\n");

	fs.writeFileSync(filePath, newContent, "utf8");
}

/**
 * Sort named imports within an import declaration.
 */
function sortNamedImports(filePath: string): void {
	const project = new Project({
		skipFileDependencyResolution: true,
		skipLoadingLibFiles: true,
	});

	const sourceFile = project.addSourceFileAtPath(filePath);

	for (const importDecl of sourceFile.getImportDeclarations()) {
		const namedImports = importDecl.getNamedImports();
		if (namedImports.length > 1) {
			const sortedNames = namedImports
				.map((ni) => {
					const alias = ni.getAliasNode()?.getText();
					const name = ni.getName();
					const isTypeOnly = ni.isTypeOnly();
					return {
						name,
						alias,
						isTypeOnly,
						sortKey: name.toLowerCase(),
					};
				})
				.sort((a, b) => a.sortKey.localeCompare(b.sortKey));

			// Remove existing named imports
			for (const ni of namedImports) {
				ni.remove();
			}

			// Re-add sorted imports
			importDecl.addNamedImports(
				sortedNames.map((s) => ({
					name: s.name,
					alias: s.alias,
					isTypeOnly: s.isTypeOnly,
				})),
			);
		}
	}

	sourceFile.saveSync();
}

// ─────────────────────────────────────────────────────────────────────────────
// File Processing
// ─────────────────────────────────────────────────────────────────────────────

const relationsSrc = path.resolve(__dirname, "../drizzle/relations.ts");
const relationsDst = path.resolve(__dirname, "../src/shared/db/relations.ts");
const schemaSrc = path.resolve(__dirname, "../drizzle/schema.ts");
const schemaDst = path.resolve(__dirname, "../src/shared/db/schema.ts");

// Process and move schema.ts
try {
	fs.copyFileSync(schemaSrc, schemaDst);
	fs.unlinkSync(schemaSrc);
	console.log("[post-introspect] Moved schema.ts to src/shared/db/");

	// Sort table exports alphabetically for deterministic output
	sortExportsAlphabetically(schemaDst);
	console.log("[post-introspect] Sorted schema.ts exports alphabetically");

	// Sort named imports within each import declaration
	sortNamedImports(schemaDst);
	console.log("[post-introspect] Sorted schema.ts imports alphabetically");
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// schema.ts doesn't exist, which is fine
}

// Process and move relations.ts
try {
	// Read the relations file and prepend header comment
	let relationsContent = fs.readFileSync(relationsSrc, "utf8");
	const relationsHeader = `// @ts-nocheck\n// This file is auto-generated by drizzle-kit introspect.\n// Do not edit manually - run \`npm run db:introspect\` to regenerate.\n`;
	if (!relationsContent.startsWith("// @ts-nocheck")) {
		relationsContent = relationsHeader + relationsContent;
	}

	// Normalize destructuring patterns in relations functions for consistent formatting
	// Drizzle-kit generates different spacing on different platforms:
	// macOS: ({ one, many }) vs Linux: ({one, many})
	// Normalize to: ({ one, many }) for consistency
	relationsContent = relationsContent.replace(
		/\(\{([a-z, ]+)\}\)\s*=>/g,
		(_match, params: string) => {
			const normalized = params
				.split(",")
				.map((p) => p.trim())
				.join(", ");
			return `({ ${normalized} }) =>`;
		},
	);

	fs.writeFileSync(relationsDst, relationsContent, "utf8");
	fs.unlinkSync(relationsSrc);
	console.log("[post-introspect] Moved relations.ts to src/shared/db/");

	// Sort relation exports alphabetically for deterministic output
	sortExportsAlphabetically(relationsDst);
	console.log("[post-introspect] Sorted relations.ts exports alphabetically");

	// Sort named imports within each import declaration
	sortNamedImports(relationsDst);
	console.log("[post-introspect] Sorted relations.ts imports alphabetically");
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// relations.ts doesn't exist, which is fine
}

// Ensure ../drizzle directory is removed even if residual files (e.g., .DS_Store) exist
const drizzleDir = path.resolve(__dirname, "../drizzle");
try {
	fs.rmSync(drizzleDir, { recursive: true, force: true });
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		console.warn(`[post-introspect] Failed to remove ${drizzleDir}:`, error);
	}
}

// Run biome format on the generated files to ensure consistent formatting across platforms
const filesToFormat = [schemaDst, relationsDst].filter((f) => fs.existsSync(f));
if (filesToFormat.length > 0) {
	try {
		execSync(`npx biome format --write ${filesToFormat.join(" ")}`, {
			cwd: path.resolve(__dirname, ".."),
			stdio: "inherit",
		});
		console.log("[post-introspect] Formatted files with biome");
	} catch (error) {
		console.warn("[post-introspect] Failed to run biome format:", error);
	}
}

console.log("[post-introspect] Completed schema normalization for cross-platform determinism");
