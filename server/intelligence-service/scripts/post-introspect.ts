#!/usr/bin/env -S node --no-warnings
/**
 * Post-introspection patcher for generated schema.ts
 *
 * This script runs after `drizzle-kit introspect` and performs the following:
 * - Adds a ts-nocheck pragma to silence circular/self-reference type errors.
 * - Cleans unused imports from drizzle-orm/pg-core; sorts remaining names alphabetically.
 * - Drops identity minValue/maxValue metadata to avoid precision-loss noise.
 * - Removes unused `sql` import from drizzle-orm if not used (keeps it for CHECK constraints).
 * - Removes Liquibase changelog tables from the schema.
 * - Sorts table exports alphabetically to ensure deterministic output.
 * - Deletes relations.ts (we don't use Drizzle relational queries).
 * - Moves schema.ts from ./drizzle/ to ./src/shared/db/
 *
 * IMPORTANT: schema.ts is auto-generated by drizzle-kit.
 * Do not edit it manually - run `npm run db:introspect` to regenerate.
 */
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const schemaPath = path.resolve(__dirname, "../drizzle/schema.ts");

let content: string;
try {
	content = fs.readFileSync(schemaPath, "utf8");
} catch (error) {
	if ((error as NodeJS.ErrnoException).code === "ENOENT") {
		console.error(`[post-introspect] schema.ts not found at ${schemaPath}`);
		process.exit(0);
	}
	throw error;
}

// Prepend pragmas if not already present
const headerBanner = `// @ts-nocheck\n// generated by drizzle-kit; ts diagnostics suppressed for generated types\n`;
if (!content.startsWith("// @ts-nocheck")) {
	content = headerBanner + content;
}

// Trim unused items in the import from drizzle-orm/pg-core if they aren't referenced
const importRegex = /import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/;
const match = content.match(importRegex);
if (match) {
	const importedRaw = match[1];
	if (!importedRaw) {
		console.log("No imports found in drizzle-orm/pg-core import");
		process.exit(0);
	}
	const imported = importedRaw
		.split(",")
		.map((s) => s.trim())
		.filter(Boolean);
	const used = new Set<string>();
	for (const name of imported) {
		const bare = name.replace(/^type\s+/, "");
		const re = new RegExp(`\\b${bare}\\b`, "m");
		if (re.test(content)) {
			used.add(name);
		}
	}
	const cleaned = imported.filter((n) => used.has(n)).sort((a, b) => a.localeCompare(b));
	if (cleaned.length > 0 && cleaned.length !== imported.length) {
		content = content.replace(
			importRegex,
			`import { ${cleaned.join(", ")} } from "drizzle-orm/pg-core"`,
		);
	}
}

// Remove gigantic numeric literals in identity metadata to avoid precision-loss warnings
content = content
	.replace(/,\s*minValue:\s*[^,}\n]+/g, "")
	.replace(/,\s*maxValue:\s*[^,}\n]+/g, "")
	.replace(/minValue:\s*[^,}\n]+,\s*/g, "")
	.replace(/maxValue:\s*[^,}\n]+,\s*/g, "");

// Fix malformed empty string defaults: drizzle-kit incorrectly generates `.default(')` for `''::character varying`
// This should be `.default('')`
content = content.replace(/\.default\('\)\.notNull\(\)/g, ".default('').notNull()");
content = content.replace(/\.default\('\)/g, ".default('')");

// Remove `import { sql } from "drizzle-orm"` only if sql template literal is not used in schema
// (e.g., CHECK constraints use sql`...` syntax and need the import)
const sqlTemplateUsageRegex = /\bsql`/;
if (!sqlTemplateUsageRegex.test(content)) {
	content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*"drizzle-orm"\s*;?\s*\n?/g, "\n");
	content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*'drizzle-orm'\s*;?\s*\n?/g, "\n");
	content = content.replace(
		/^\s*import\s*\{\s*sql\s*\}\s*from\s*["']drizzle-orm["']\s*;?\s*$(?:\r?\n)?/gm,
		"",
	);
}

// Fix drizzle-kit introspect bug: it incorrectly assigns operator classes from the SECOND column
// to the FIRST column in composite indexes. For example:
//   index(...).using("btree", table.threadId.op("timestamptz_ops"), table.createdAt.op("timestamptz_ops"))
// should be:
//   index(...).using("btree", table.threadId, table.createdAt)
// The operator classes are defaults for btree and don't need to be specified.
// Remove all .op("..._ops") from indexes as btree uses default operator classes
content = content.replace(/\.op\("[a-z0-9_]+_ops"\)/g, "");

// Also ensure AnyPgColumn is not left in imports if unused
content = content.replace(
	/import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/,
	(_full, inner: string) => {
		const parts = inner
			.split(",")
			.map((s) => s.trim())
			.filter(Boolean);
		const filtered = parts.filter((p) => !/^type\s+AnyPgColumn$/.test(p));
		return `import { ${filtered.join(", ")} } from "drizzle-orm/pg-core"`;
	},
);

// Remove Liquibase tables `databasechangelog` and `databasechangeloglock`
// This removes the entire pgTable block including its body and any builder callback.
// Strategy: match `export const <name> = pgTable("<name>", { ... })` optionally followed by `, (table) => [...]` and trailing semicolon.
const removePgTableBlock = (name: string) => {
	// A reasonably safe regex using non-greedy matching and balanced braces heuristics per block lines.
	const tableRegex = new RegExp(
		// export const name = pgTable("name",
		String.raw`\nexport\s+const\s+${name}\s*=\s*pgTable\(\s*(["'])${name}\1\s*,\s*\{[\s\S]*?\}\s*\)` +
			// optional table callback e.g., , (table) => [ ... ]
			String.raw`(?:\s*,\s*\([^)]*\)\s*=>\s*\[[\s\S]*?\]\s*)?` +
			// optional trailing semicolon and newlines
			String.raw`\s*;?\n`,
		"g",
	);
	content = content.replace(tableRegex, "\n");
};

removePgTableBlock("databasechangelog");
removePgTableBlock("databasechangeloglock");

// Sort table exports alphabetically to ensure deterministic output across introspection runs.
// Drizzle-kit introspect produces tables in non-deterministic order, which causes CI failures
// when comparing generated schema against committed version.
// Strategy: extract all `export const <name> = pgTable(...)` blocks and sort by table name.
{
	// Match table exports: `export const tableName = pgTable("tableName", { ... }, (table) => [...]);`
	// This regex captures the full block including optional builder callback
	const tableBlockRegex =
		/\nexport\s+const\s+(\w+)\s*=\s*pgTable\(\s*["'][\w]+["']\s*,\s*\{[\s\S]*?\}\s*(?:,\s*\([^)]*\)\s*=>\s*\[[\s\S]*?\]\s*)?\)\s*;/g;

	// Find all table blocks with their names
	const tableBlocks: Array<{ name: string; block: string }> = [];
	let tableMatch: RegExpExecArray | null = tableBlockRegex.exec(content);
	while (tableMatch !== null) {
		const tableName = tableMatch[1];
		if (tableName) {
			tableBlocks.push({ name: tableName, block: tableMatch[0] });
		}
		tableMatch = tableBlockRegex.exec(content);
	}

	if (tableBlocks.length > 0) {
		// Remove all table blocks from content
		for (const { block } of tableBlocks) {
			content = content.replace(block, "");
		}

		// Sort blocks alphabetically by table name (case-insensitive)
		tableBlocks.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));

		// Append sorted blocks at the end
		content = `${content.trimEnd()}\n${tableBlocks.map((t) => t.block).join("\n")}\n`;
	}
}

fs.writeFileSync(schemaPath, content, "utf8");

// Delete ./drizzle/relations.ts - we don't use Drizzle relational queries
// relations.ts is only needed for db.query.table.findMany({ with: {...} }) syntax
// which we don't use - we use standard SQL-like queries (db.select().from(table))
const relationsSrc = path.resolve(__dirname, "../drizzle/relations.ts");
try {
	fs.unlinkSync(relationsSrc);
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// relations.ts doesn't exist, which is fine
}

// Move ./drizzle/schema.ts to ./src/shared/db/schema.ts (overwrite if exists)
const schemaSrc = path.resolve(__dirname, "../drizzle/schema.ts");
const schemaDst = path.resolve(__dirname, "../src/shared/db/schema.ts");
try {
	fs.copyFileSync(schemaSrc, schemaDst);
	fs.unlinkSync(schemaSrc);
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// schema.ts doesn't exist, which is fine
}

// Ensure ../drizzle directory is removed even if residual files (e.g., .DS_Store) exist
const drizzleDir = path.resolve(__dirname, "../drizzle");
try {
	fs.rmSync(drizzleDir, { recursive: true, force: true });
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		console.warn(`[post-introspect] Failed to remove ${drizzleDir}:`, error);
	}
}

// Run biome format twice to ensure idempotent output
// (biome has known issues where the first format may not match subsequent formats)
import { execSync } from "node:child_process";

const filesToFormat = [schemaDst].filter((f) => fs.existsSync(f));
if (filesToFormat.length > 0) {
	try {
		// First pass: format + organize imports
		execSync(`npx biome check --write --unsafe ${filesToFormat.join(" ")}`, {
			cwd: path.resolve(__dirname, ".."),
			stdio: "inherit",
		});
		// Second pass: ensure formatting is idempotent
		execSync(`npx biome format --write ${filesToFormat.join(" ")}`, {
			cwd: path.resolve(__dirname, ".."),
			stdio: "inherit",
		});
	} catch (error) {
		console.warn("[post-introspect] Failed to run biome:", error);
	}
}

console.log("[post-introspect] Patched schema.ts with ts-nocheck and cleanup");
