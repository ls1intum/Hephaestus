#!/usr/bin/env -S node --no-warnings
/**
 * Post-introspection patcher for generated schema.ts and relations.ts
 *
 * This script runs after `drizzle-kit introspect` and performs the following:
 * - Adds a ts-nocheck pragma to silence circular/self-reference type errors.
 * - Cleans unused imports from drizzle-orm/pg-core; sorts remaining names.
 * - Drops identity minValue/maxValue metadata to avoid precision-loss noise.
 * - Removes unused `sql` import from drizzle-orm if not referenced.
 * - Removes Liquibase changelog tables from the schema.
 * - Moves schema.ts and relations.ts from ./drizzle/ to ./src/shared/db/
 * - Adds header comments to relations.ts to indicate it's auto-generated.
 *
 * IMPORTANT: Both schema.ts and relations.ts are auto-generated by drizzle-kit.
 * Do not edit them manually - run `npm run db:introspect` to regenerate.
 */
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const schemaPath = path.resolve(__dirname, "../drizzle/schema.ts");

let content: string;
try {
	content = fs.readFileSync(schemaPath, "utf8");
} catch (error) {
	if ((error as NodeJS.ErrnoException).code === "ENOENT") {
		console.error(`[post-introspect] schema.ts not found at ${schemaPath}`);
		process.exit(0);
	}
	throw error;
}

// Prepend pragmas if not already present
const headerBanner = `// @ts-nocheck\n// generated by drizzle-kit; ts diagnostics suppressed for generated types\n`;
if (!content.startsWith("// @ts-nocheck")) {
	content = headerBanner + content;
}

// Trim unused items in the import from drizzle-orm/pg-core if they aren't referenced
const importRegex = /import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/;
const match = content.match(importRegex);
if (match) {
	const importedRaw = match[1];
	if (!importedRaw) {
		console.log("No imports found in drizzle-orm/pg-core import");
		process.exit(0);
	}
	const imported = importedRaw
		.split(",")
		.map((s) => s.trim())
		.filter(Boolean);
	const used = new Set<string>();
	for (const name of imported) {
		const bare = name.replace(/^type\s+/, "");
		const re = new RegExp(`\\b${bare}\\b`, "m");
		if (re.test(content)) {
			used.add(name);
		}
	}
	const cleaned = imported.filter((n) => used.has(n)).sort((a, b) => a.localeCompare(b));
	if (cleaned.length > 0 && cleaned.length !== imported.length) {
		content = content.replace(
			importRegex,
			`import { ${cleaned.join(", ")} } from "drizzle-orm/pg-core"`,
		);
	}
}

// Remove gigantic numeric literals in identity metadata to avoid precision-loss warnings
content = content
	.replace(/,\s*minValue:\s*[^,}\n]+/g, "")
	.replace(/,\s*maxValue:\s*[^,}\n]+/g, "")
	.replace(/minValue:\s*[^,}\n]+,\s*/g, "")
	.replace(/maxValue:\s*[^,}\n]+,\s*/g, "");

// Fix malformed empty string defaults: drizzle-kit incorrectly generates `.default(')` for `''::character varying`
// This should be `.default('')`
content = content.replace(/\.default\('\)\.notNull\(\)/g, ".default('').notNull()");
content = content.replace(/\.default\('\)/g, ".default('')");

// Always remove `import { sql } from "drizzle-orm"` in generated schema; drizzle rarely uses it and it trips linters
content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*"drizzle-orm"\s*;?\s*\n?/g, "\n");
content = content.replace(/\n?import\s*\{\s*sql\s*\}\s*from\s*'drizzle-orm'\s*;?\s*\n?/g, "\n");
content = content.replace(
	/^\s*import\s*\{\s*sql\s*\}\s*from\s*["']drizzle-orm["']\s*;?\s*$(?:\r?\n)?/gm,
	"",
);

// Also ensure AnyPgColumn is not left in imports if unused
content = content.replace(
	/import\s*\{([^}]+)\}\s*from\s*"drizzle-orm\/pg-core"/,
	(_full, inner: string) => {
		const parts = inner
			.split(",")
			.map((s) => s.trim())
			.filter(Boolean);
		const filtered = parts.filter((p) => !/^type\s+AnyPgColumn$/.test(p));
		return `import { ${filtered.join(", ")} } from "drizzle-orm/pg-core"`;
	},
);

// Remove Liquibase tables `databasechangelog` and `databasechangeloglock`
// This removes the entire pgTable block including its body and any builder callback.
// Strategy: match `export const <name> = pgTable("<name>", { ... })` optionally followed by `, (table) => [...]` and trailing semicolon.
const removePgTableBlock = (name: string) => {
	// A reasonably safe regex using non-greedy matching and balanced braces heuristics per block lines.
	const tableRegex = new RegExp(
		// export const name = pgTable("name",
		String.raw`\nexport\s+const\s+${name}\s*=\s*pgTable\(\s*(["'])${name}\1\s*,\s*\{[\s\S]*?\}\s*\)` +
			// optional table callback e.g., , (table) => [ ... ]
			String.raw`(?:\s*,\s*\([^)]*\)\s*=>\s*\[[\s\S]*?\]\s*)?` +
			// optional trailing semicolon and newlines
			String.raw`\s*;?\n`,
		"g",
	);
	content = content.replace(tableRegex, "\n");
};

removePgTableBlock("databasechangelog");
removePgTableBlock("databasechangeloglock");

fs.writeFileSync(schemaPath, content, "utf8");

// Move ./drizzle/relations.ts to ./src/shared/db/relations.ts (overwrite if exists)
const relationsSrc = path.resolve(__dirname, "../drizzle/relations.ts");
const relationsDst = path.resolve(__dirname, "../src/shared/db/relations.ts");
try {
	// Read the relations file and prepend header comment
	let relationsContent = fs.readFileSync(relationsSrc, "utf8");
	const relationsHeader = `// @ts-nocheck\n// This file is auto-generated by drizzle-kit introspect.\n// Do not edit manually - run \`npm run db:introspect\` to regenerate.\n`;
	if (!relationsContent.startsWith("// @ts-nocheck")) {
		relationsContent = relationsHeader + relationsContent;
	}
	fs.writeFileSync(relationsDst, relationsContent, "utf8");
	fs.unlinkSync(relationsSrc);
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// relations.ts doesn't exist, which is fine
}

// Move ./drizzle/schema.ts to ./src/shared/db/schema.ts (overwrite if exists)
const schemaSrc = path.resolve(__dirname, "../drizzle/schema.ts");
const schemaDst = path.resolve(__dirname, "../src/shared/db/schema.ts");
try {
	fs.copyFileSync(schemaSrc, schemaDst);
	fs.unlinkSync(schemaSrc);
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		throw error;
	}
	// schema.ts doesn't exist, which is fine
}

// Ensure ../drizzle directory is removed even if residual files (e.g., .DS_Store) exist
const drizzleDir = path.resolve(__dirname, "../drizzle");
try {
	fs.rmSync(drizzleDir, { recursive: true, force: true });
} catch (error) {
	if ((error as NodeJS.ErrnoException).code !== "ENOENT") {
		console.warn(`[post-introspect] Failed to remove ${drizzleDir}:`, error);
	}
}

console.log("[post-introspect] Patched schema.ts with ts-nocheck and cleanup");
